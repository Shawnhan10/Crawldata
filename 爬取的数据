不同的子序列 II - 领扣 (LeetCode)
给定一个字符串S，计算S的不同非空子序列的个数。

因为结果可能很大，所以返回答案模 10^9 + 7.



示例 1：

输入：abc
输出：7
解释：7 个不同的子序列分别是 a, b, c, ab, ac, bc, 以及 abc。


示例 2：

输入：aba
输出：6
解释：6 个不同的子序列分别是 a, b, ab, ba, aa 以及 aba。


示例 3：

输入：aaa
输出：3
解释：3 个不同的子序列分别是 a, aa 以及 aaa。






提示：


	S只包含小写字母。
	1 <= S.length <= 2000





最小面积矩形 - 领扣 (LeetCode)
给定在 xy 平面上的一组点，确定由这些点组成的矩形的最小面积，其中矩形的边平行于 x 轴和 y 轴。

如果没有任何矩形，就返回 0。



示例 1：

输入：[[1,1],[1,3],[3,1],[3,3],[2,2]]
输出：4


示例 2：

输入：[[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]
输出：2




提示：


	1 <= points.length <= 500
	0 <=points[i][0] <=40000
	0 <=points[i][1] <=40000
	所有的点都是不同的。

给定二叉搜索树的根结点root，返回 L 和 R（含）之间的所有结点的值的和。

二叉搜索树保证具有唯一的值。



示例 1：

输入：root = [10,5,15,3,7,null,18], L = 7, R = 15
输出：32


示例2：

输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10
输出：23




提示：


	树中的结点数量最多为10000个。
	最终的答案保证小于2^31。

二叉搜索树的范围和 - 领扣 (LeetCode)
你有一个日志数组 logs。每条日志都是以空格分隔的字串。

对于每条日志，其第一个字为字母数字标识符。然后，要么：


	标识符后面的每个字将仅由小写字母组成，或；
	标识符后面的每个字将仅由数字组成。


我们将这两种日志分别称为字母日志和数字日志。保证每个日志在其标识符后面至少有一个字。

将日志重新排序，使得所有字母日志都排在数字日志之前。字母日志按字母顺序排序，忽略标识符，标识符仅用于表示关系。数字日志应该按原来的顺序排列。

返回日志的最终顺序。



示例 ：

输入：[a1 9 2 3 1,g1 act car,zo4 4 7,ab1 off key dog,a8 act zoo]
输出：[g1 act car,a8 act zoo,ab1 off key dog,a1 9 2 3 1,zo4 4 7]




提示：


	0 <= logs.length <= 100
	3 <= logs[i].length <= 100
	logs[i]保证有一个标识符，并且标识符后面有一个字。

重新排列日志文件 - 领扣 (LeetCode)
戳印序列 - 领扣 (LeetCode)
你想要用小写字母组成一个目标字符串target。

开始的时候，序列由target.length个&#39;?&#39;记号组成。而你有一个小写字母印章stamp。

在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行10 * target.length 个回合。

举个例子，如果初始序列为 ?????，而你的印章 stamp是abc，那么在第一回合，你可以得到abc??、?abc?、??abc。（请注意，印章必须完全包含在序列的边界内才能盖下去。）

如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。

例如，如果序列是 ababc，印章是 abc，那么我们就可以返回与操作????? -&gt; abc?? -&gt; ababc 相对应的答案 [0, 2]；

另外，如果可以印出序列，那么需要保证可以在 10 * target.length个回合内完成。任何超过此数字的答案将不被接受。



示例 1：

输入：stamp = abc, target = ababc
输出：[0,2]
（[1,0,2] 以及其他一些可能的结果也将作为答案被接受）


示例 2：

输入：stamp = abca, target = aabcaca
输出：[3,0,1]




提示：


	1 <= stamp.length <= target.length <= 1000
	stamp 和target只包含小写字母。

骑士拨号器 - 领扣 (LeetCode)
国际象棋中的骑士可以按下图所示进行移动：

.     


这一次，我们将&ldquo;骑士&rdquo; 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳N-1 步。每一步必须是从一个数字键跳到另一个数字键。

每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下N 位数字。

你能用这种方式拨出多少个不同的号码？

因为答案可能很大，所以输出答案模10^9 + 7。






示例 1：

输入：1
输出：10


示例 2：

输入：2
输出：20


示例 3：

输入：3
输出：46




提示：


	1 <= N <= 5000

最短的桥 - 领扣 (LeetCode)
在给定的二维二进制数组A中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）

现在，我们可以将0变为1，以使两座岛连接起来，变成一座岛。

返回必须翻转的0 的最小数目。（可以保证答案至少是 1。）



示例 1：

输入：[[0,1],[1,0]]
输出：1


示例 2：

输入：[[0,1,0],[0,0,0],[0,0,1]]
输出：2


示例 3：

输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
输出：1



提示：


	1 <= A.length =A[0].length <= 100
	A[i][j] == 0 或A[i][j] == 1



最近的请求次数 - 领扣 (LeetCode)
写一个RecentCounter类来计算最近的请求。

它只有一个方法：ping(int t)，其中t代表以毫秒为单位的某个时间。

返回从 3000 毫秒前到现在的ping数。

任何处于[t - 3000, t]时间范围之内的 ping都将会被计算在内，包括当前（指 t时刻）的 ping。

保证每次对 ping 的调用都使用比之前更大的 t 值。



示例：

输入：inputs = [RecentCounter,ping,ping,ping,ping], inputs = [[],[1],[100],[3001],[3002]]
输出：[null,1,2,3,3]



提示：


	每个测试用例最多调用10000次ping。
	每个测试用例会使用严格递增的 t 值来调用ping。
	每次调用 ping都有1 <= t <= 10^9。



对于某些固定的N，如果数组A是整数1, 2, ..., N组成的排列，使得：

对于每个i < j，都不存在k 满足i < k < j使得A[k] * 2 = A[i] + A[j]。

那么数组 A是漂亮数组。



给定N，返回任意漂亮数组A（保证存在一个）。



示例 1：

输入：4
输出：[2,1,4,3]


示例 2：

输入：5
输出：[3,1,2,5,4]



提示：


	1 <= N <= 1000



漂亮数组 - 领扣 (LeetCode)
给定一个方形整数数组A，我们想要得到通过 A 的下降路径的最小和。

下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。



示例：

输入：[[1,2,3],[4,5,6],[7,8,9]]
输出：12
解释：
可能的下降路径有：



	[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]
	[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]
	[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]


和最小的下降路径是[1,4,7]，所以答案是12。



提示：


	1 <= A.length == A[0].length <= 100
	-100 <= A[i][j] <= 100

下降路径最小和 - 领扣 (LeetCode)
在由若干0和1 组成的数组A中，有多少个和为 S的非空子数组。



示例：

输入：A = [1,0,1,0,1], S = 2
输出：4
解释：
如下面黑体所示，有 4 个满足题目要求的子数组：
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]




提示：


	A.length <= 30000
	0 <= S <= A.length
	A[i]为0或1

和相同的二元子数组 - 领扣 (LeetCode)
每封电子邮件都由一个本地名称和一个域名组成，以 @ 符号分隔。

例如，在alice@leetcode.com中，alice是本地名称，而leetcode.com是域名。

除了小写字母，这些电子邮件还可能包含 &#39;,&#39; 或 &#39;+&#39;。

如果在电子邮件地址的本地名称部分中的某些字符之间添加句点（&#39;.&#39;），则发往那里的邮件将会转发到本地名称中没有点的同一地址。例如，alice.z@leetcode.com&rdquo; 和 &ldquo;alicez@leetcode.com&rdquo;会转发到同一电子邮件地址。 （请注意，此规则不适用于域名。）

如果在本地名称中添加加号（&#39;+&#39;），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件，例如 m.y+name@email.com 将转发到 my@email.com。 （同样，此规则不适用于域名。）

可以同时使用这两个规则。

给定电子邮件列表 emails，我们会向列表中的每个地址发送一封电子邮件。实际收到邮件的不同地址有多少？



示例：

输入：[test.email+alex@leetcode.com,test.e.mail+bob.cathy@leetcode.com,testemail+david@lee.tcode.com]
输出：2
解释：实际收到邮件的是 testemail@leetcode.com 和 testemail@lee.tcode.com。




提示：


	1 <= emails[i].length<= 100
	1 <= emails.length <= 100
	每封 emails[i] 都包含有且仅有一个 &#39;@&#39; 字符。

独特的电子邮件地址 - 领扣 (LeetCode)
尽量减少恶意软件的传播 II - 领扣 (LeetCode)
(这个问题与尽量减少恶意软件的传播是一样的，不同之处用粗体表示。)

在节点网络中，只有当graph[i][j] = 1时，每个节点i能够直接连接到另一个节点j。

一些节点initial最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。

假设M(initial)是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。

我们可以从初始列表中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。如果移除这一节点将最小化M(initial)，则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。






示例 1：

输出：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
输入：0


示例 2：

输入：graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
输出：1


示例 3：

输入：graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
输出：1




提示：


	1 < graph.length = graph[0].length <= 300
	0 <= graph[i][j] == graph[j][i] <= 1
	graph[i][i] = 1
	1 <= initial.length < graph.length
	0 <= initial[i] < graph.length

将字符串翻转到单调递增 - 领扣 (LeetCode)
如果一个由&#39;0&#39; 和 &#39;1&#39;组成的字符串，是以一些 &#39;0&#39;（可能没有 &#39;0&#39;）后面跟着一些 &#39;1&#39;（也可能没有 &#39;1&#39;）的形式组成的，那么该字符串是单调递增的。

我们给出一个由字符 &#39;0&#39; 和 &#39;1&#39;组成的字符串S，我们可以将任何&#39;0&#39; 翻转为&#39;1&#39;或者将&#39;1&#39;翻转为&#39;0&#39;。

返回使 S 单调递增的最小翻转次数。



示例 1：

输入：00110
输出：1
解释：我们翻转最后一位得到 00111.


示例 2：

输入：010110
输出：2
解释：我们翻转得到 011111，或者是 000111。


示例 3：

输入：00011000
输出：2
解释：我们翻转得到 00000000。




提示：


	1 <= S.length <= 20000
	S 中只包含字符&#39;0&#39;和&#39;1&#39;

长按键入 - 领扣 (LeetCode)
你的朋友正在使用键盘输入他的名字name。偶尔，在键入字符c时，按键可能会被长按，而字符可能被输入 1 次或多次。

你将会检查键盘输入的字符typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回True。



示例 1：

输入：name = alex, typed = aaleex
输出：true
解释：&#39;alex&#39; 中的 &#39;a&#39; 和 &#39;e&#39; 被长按。


示例 2：

输入：name = saeed, typed = ssaaedd
输出：false
解释：&#39;e&#39; 一定需要被键入两次，但在 typed 的输出中不是这样。


示例 3：

输入：name = leelee, typed = lleeelee
输出：true


示例 4：

输入：name = laiden, typed = laiden
输出：true
解释：长按名字中的字符并不是必要的。




提示：


	name.length <= 1000
	typed.length <= 1000
	name 和typed的字符都是小写字母。





在节点网络中，只有当 graph[i][j] = 1时，每个节点i能够直接连接到另一个节点 j。

一些节点initial最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。

假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。

我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)，则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。

请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。






示例 1：

输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
输出：0


示例 2：

输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
输出：0


示例 3：

输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
输出：1




提示：


	1 < graph.length = graph[0].length <= 300
	0 <= graph[i][j] == graph[j][i] <= 1
	graph[i][i] = 1
	1 <= initial.length < graph.length
	0 <= initial[i] < graph.length

尽量减少恶意软件的传播 - 领扣 (LeetCode)
三数之和的多种可能 - 领扣 (LeetCode)
给定一个整数数组A，以及一个整数target作为目标值，返回满足 i < j < k 且A[i] + A[j] + A[k] == target的元组i, j, k的数量。

由于结果会非常大，请返回 结果除以 10^9 + 7 的余数。



示例 1：

输入：A = [1,1,2,2,3,3,4,4,5,5], target = 8
输出：20
解释：
按值枚举（A[i]，A[j]，A[k]）：
(1, 2, 5) 出现 8 次；
(1, 3, 4) 出现 8 次；
(2, 2, 4) 出现 2 次；
(2, 3, 3) 出现 2 次。


示例 2：

输入：A = [1,1,2,2,2,2], target = 5
输出：12
解释：
A[i] = 1，A[j] = A[k] = 2 出现 12 次：
我们从 [1,1] 中选择一个 1，有 2 种情况，
从 [2,2,2,2] 中选出两个 2，有 6 种情况。




提示：


	3 <= A.length <= 3000
	0 <= A[i] <= 100
	0 <= target <= 300

给定一个非负整数数组A， A 中一半整数是奇数，一半整数是偶数。

对数组进行排序，以便当A[i] 为奇数时，i也是奇数；当A[i]为偶数时， i 也是偶数。

你可以返回任何满足上述条件的数组作为答案。



示例：

输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。




提示：


	2 <= A.length <= 20000
	A.length % 2 == 0
	0 <= A[i] <= 1000



按奇偶排序数组 II - 领扣 (LeetCode)
给定一个由&#39;(&#39;和&#39;)&#39;括号组成的字符串 S，我们需要添加最少的括号（ &#39;(&#39;或是&#39;)&#39;，可以在任何位置），以使得到的括号字符串有效。

从形式上讲，只有满足下面几点之一，括号字符串才是有效的：


	它是一个空字符串，或者
	它可以被写成AB（A与B连接）, 其中A 和B都是有效字符串，或者
	它可以被写作(A)，其中A是有效字符串。


给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。



示例 1：

输入：())
输出：1


示例 2：

输入：(((
输出：3


示例 3：

输入：()
输出：0


示例 4：

输入：()))((
输出：4



提示：


	S.length <= 1000
	S 只包含&#39;(&#39; 和&#39;)&#39;字符。



使括号有效的最少添加 - 领扣 (LeetCode)
播放列表的数量 - 领扣 (LeetCode)
你的音乐播放器里有N首不同的歌，在旅途中，你的旅伴想要听 L首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：


	每首歌至少播放一次。
	一首歌只有在其他 K 首歌播放完之后才能再次播放。


返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模10^9 + 7的结果。



示例 1：

输入：N = 3, L = 3, K = 1
输出：6
解释：有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]，[2, 3, 1]，[3, 1, 2]，[3, 2, 1].


示例 2：

输入：N = 2, L = 3, K = 0
输出：6
解释：有 6 种可能的播放列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2]


示例 3：

输入：N = 2, L = 3, K = 1
输出：2
解释：有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2]




提示：


	0 <= K < N <= L <= 100

完全二叉树是每一层（除最后一层外）都是完全填充（即，结点数达到最大）的，并且所有的结点都尽可能地集中在左侧。

设计一个用完全二叉树初始化的数据结构CBTInserter，它支持以下几种操作：


	CBTInserter(TreeNode root)使用头结点为root的给定树初始化该数据结构；
	CBTInserter.insert(int v) 将TreeNode插入到存在值为node.val =v 的树中以使其保持完全二叉树的状态，并返回插入的 TreeNode的父结点的值；
	CBTInserter.get_root() 将返回树的头结点。







示例 1：

输入：inputs = [CBTInserter,insert,get_root], inputs = [[[1]],[2],[]]
输出：[null,1,[1,2]]


示例 2：

输入：inputs = [CBTInserter,insert,insert,get_root], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]
输出：[null,3,4,[1,2,3,4,5,6,7,8]]




提示：


	最初给定的树是完全二叉树，且包含1到1000个结点。
	每个测试用例最多调用CBTInserter.insert 操作10000次。
	给定结点或插入结点的每个值都在0到5000之间。

完全二叉树插入器 - 领扣 (LeetCode)
环形子数组的最大和 - 领扣 (LeetCode)
给定一个由整数数组 A表示的环形数组 C，求 C的非空子数组的最大可能和。

在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 <= i < A.length时C[i] = A[i]，而当i &gt;= 0时C[i+A.length] = C[i]）

此外，子数组最多只能包含固定缓冲区 A中的每个元素一次。（形式上，对于子数组C[i], C[i+1], ..., C[j]，不存在i <= k1, k2 <= j其中k1 % A.length= k2 % A.length）



示例 1：

输入：[1,-2,3,-2]
输出：3
解释：从子数组 [3] 得到最大和 3


示例 2：

输入：[5,-3,5]
输出：10
解释：从子数组 [5,5] 得到最大和 5 + 5 = 10


示例 3：

输入：[3,-1,2,-1]
输出：4
解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4


示例 4：

输入：[3,-2,2,-3]
输出：3
解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3


示例 5：

输入：[-2,-3,-1]
输出：-1
解释：从子数组 [-1] 得到最大和 -1




提示：


	-30000 <= A[i] <= 30000
	1 <= A.length <= 30000

给定一个字符串S，返回&ldquo;反转后的&rdquo;字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。






示例 1：

输入：ab-cd
输出：dc-ba


示例 2：

输入：a-bC-dEf-ghIj
输出：j-Ih-gfE-dCba


示例 3：

输入：Test1ng-Leet=code-Q!
输出：Qedo1ct-eeLg=ntse-T!




提示：


	S.length <= 100
	33 <= S[i].ASCIIcode <= 122
	S 中不包含\ or 

仅仅反转字母 - 领扣 (LeetCode)
单词子集 - 领扣 (LeetCode)
我们给出两个单词数组 A和B。每个单词都是一串小写字母。

现在，如果b 中的每个字母都出现在 a 中，包括重复出现的字母，那么称单词 b 是单词 a 的子集。 例如，&ldquo;wrr&rdquo; 是 &ldquo;warrior&rdquo; 的子集，但不是 &ldquo;world&rdquo; 的子集。

如果对 B 中的每一个单词b，b 都是 a 的子集，那么我们称A 中的单词 a 是通用的。

你可以按任意顺序以列表形式返回A 中所有的通用单词。






示例 1：

输入：A = [amazon,apple,facebook,google,leetcode], B = [e,o]
输出：[facebook,google,leetcode]


示例 2：

输入：A = [amazon,apple,facebook,google,leetcode], B = [l,e]
输出：[apple,google,leetcode]


示例 3：

输入：A = [amazon,apple,facebook,google,leetcode], B = [e,oo]
输出：[facebook,google]


示例 4：

输入：A = [amazon,apple,facebook,google,leetcode], B = [lo,eo]
输出：[google,leetcode]


示例 5：

输入：A = [amazon,apple,facebook,google,leetcode], B = [ec,oc,ceo]
输出：[facebook,leetcode]




提示：


	1 <= A.length, B.length <= 10000
	1 <= A[i].length, B[i].length<= 10
	A[i]和B[i]只由小写字母组成。
	A[i]中所有的单词都是独一无二的，也就是说不存在i != j使得A[i] == A[j]。

分割数组 - 领扣 (LeetCode)
给定一个数组A，将其划分为两个不相交（没有公共元素）的连续子数组left和right，使得：


	left中的每个元素都小于或等于right中的每个元素。
	left 和right都是非空的。
	left要尽可能小。


在完成这样的分组后返回left的长度。可以保证存在这样的划分方法。



示例 1：

输入：[5,0,3,8,6]
输出：3
解释：left = [5,0,3]，right = [8,6]


示例 2：

输入：[1,1,1,0,6,12]
输出：4
解释：left = [1,1,1,0]，right = [6,12]




提示：


	2 <= A.length<= 30000
	0 <= A[i] <= 10^6
	可以保证至少有一种方法能够按题目所描述的那样对 A 进行划分。



给定一副牌，每张牌上都写着一个整数。

此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：


	每组都有X张牌。
	组内所有的牌上都写着相同的整数。


仅当你可选的 X &gt;= 2 时返回true。



示例 1：

输入：[1,2,3,4,4,3,2,1]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]


示例 2：

输入：[1,1,1,2,2,2,3,3]
输出：false
解释：没有满足要求的分组。


示例 3：

输入：[1]
输出：false
解释：没有满足要求的分组。


示例 4：

输入：[1,1]
输出：true
解释：可行的分组是 [1,1]


示例 5：

输入：[1,1,2,2,2,2]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[2,2]



提示：


	1 <= deck.length <= 10000
	0 <= deck[i] <10000



卡牌分组 - 领扣 (LeetCode)
两个玩家分别扮演猫（Cat）和老鼠（Mouse）在无向图上进行游戏，他们轮流行动。

该图按下述规则给出：graph[a]是所有结点 b 的列表，使得 ab 是图的一条边。

老鼠从结点 1 开始并率先出发，猫从结点 2 开始且随后出发，在结点 0 处有一个洞。

在每个玩家的回合中，他们必须沿着与他们所在位置相吻合的图的一条边移动。例如，如果老鼠位于结点 1，那么它只能移动到graph[1]中的（任何）结点去。

此外，猫无法移动到洞（结点 0）里。

然后，游戏在出现以下三种情形之一时结束：


	如果猫和老鼠占据相同的结点，猫获胜。
	如果老鼠躲入洞里，老鼠获胜。
	如果某一位置重复出现（即，玩家们的位置和移动顺序都与上一个回合相同），游戏平局。


给定graph，并假设两个玩家都以最佳状态参与游戏，如果老鼠获胜，则返回1；如果猫获胜，则返回 2；如果平局，则返回 0。






示例：

输入：[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
输出：0
解释：
4---3---1
| |
2---5
\/
 0




提示：


	3 <= graph.length <= 200
	保证 graph[1]非空。
	保证graph[2]包含非零元素。

猫和老鼠 - 领扣 (LeetCode)
在选举中，第i张票是在时间为times[i]时投给persons[i]的。

现在，我们想要实现下面的查询函数： TopVotedCandidate.q(int t) 将返回在t 时刻主导选举的候选人的编号。

在t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。

示例：

输入：[TopVotedCandidate,q,q,q,q,q,q], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]
输出：[null,0,1,1,0,0,1]
解释：
时间为 3，票数分布情况是 [0]，编号为 0 的候选人领先。
时间为 12，票数分布情况是 [0,1,1]，编号为 1 的候选人领先。
时间为 25，票数分布情况是 [0,1,1,0,0,1]，编号为 1 的候选人领先（因为最近的投票结果是平局）。
在时间 15、24 和 8 处继续执行 3 个查询。




提示：


	1 <= persons.length = times.length <= 5000
	0 <= persons[i] <= persons.length
	times是严格递增的数组，所有元素都在[0, 10^9]范围中。
	每个测试用例最多调用10000次TopVotedCandidate.q。
	TopVotedCandidate.q(int t)被调用时总是满足t &gt;= times[0]。

在线选举 - 领扣 (LeetCode)
给定一个整数数组 A，对于每个整数 A[i]，我们可以选择x = -K或是x = K，并将x加到A[i]中。

在此过程之后，我们得到一些数组B。

返回 B的最大值和 B的最小值之间可能存在的最小差值。






示例 1：

输入：A = [1], K = 0
输出：0
解释：B = [1]


示例 2：

输入：A = [0,10], K = 2
输出：6
解释：B = [2,8]


示例 3：

输入：A = [1,3,6], K = 3
输出：3
解释：B = [4,6,3]




提示：


	1 <= A.length <= 10000
	0 <= A[i] <= 10000
	0 <= K <= 10000

最小差值 II - 领扣 (LeetCode)
爬坡和梯子 - 领扣 (LeetCode)
在一块 N x N 的板子board上，从板的左下角开始，每一行交替方向，按从1 到 N*N的数字给方格编号。例如，对于一块 6 x 6 大小的板子，可以编号如下：

36 35 34 33 32 31
25 26 27 28 29 30
24 23 22 21 20 19
13 14 15 16 17 18
12 11 10 09 08 07
01 02 03 04 05 06


从板子的方块1 开始（总是在最后一行、第一列）出发。

从方块 x 开始，每一次移动都包含以下内容：


	你选择一个目标方块 S，它的编号是 x+1，x+2，x+3，x+4，x+5，或者 x+6，只要这个数字满足 <= N*N。
	如果 S 有一个坡或梯子，你就移动到那个坡或梯子的目的地。否则，你会移动到 S。


在 r 行 c 列上的方格里有 &ldquo;坡&rdquo; 或 &ldquo;梯子&rdquo;；如果 board[r][c] != -1，那个坡或梯子的目的地将会是 board[r][c]。

注意，你每次移动最多只能爬过一个坡或梯子一次：就算目的地是另一个坡或梯子的起点，你也不会继续移动。

返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 -1。



示例：

输入：[
[-1,-1,-1,-1,-1,-1],
[-1,-1,-1,-1,-1,-1],
[-1,-1,-1,-1,-1,-1],
[-1,35,-1,-1,13,-1],
[-1,-1,-1,-1,-1,-1],
[-1,15,-1,-1,-1,-1]]
输出：4
解释：
首先，从方格 1 [第 5 行，第 0 列] 开始。
你决定移动到方格 2，并必须爬过梯子移动到到方格 15。
然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过坡到方格 13。
然后你决定移动到方格 14，且必须通过梯子移动到方格 35。
然后你决定移动到方格 36, 游戏结束。
可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。




提示：


	2 <= board.length = board[0].length<= 20
	board[i][j]介于1和N*N之间或者等于-1。
	编号为1的方格上没有坡或梯子。
	编号为N*N的方格上没有坡或梯子。

给定一个整数数组 A，对于每个整数 A[i]，我们可以选择任意x 满足-K <= x <= K，并将x加到A[i]中。

在此过程之后，我们得到一些数组B。

返回 B的最大值和 B的最小值之间可能存在的最小差值。






示例 1：

输入：A = [1], K = 0
输出：0
解释：B = [1]


示例 2：

输入：A = [0,10], K = 2
输出：6
解释：B = [2,8]


示例 3：

输入：A = [1,3,6], K = 3
输出：0
解释：B = [3,3,3] 或 B = [4,4,4]




提示：


	1 <= A.length <= 10000
	0 <= A[i] <= 10000
	0 <= K <= 10000

最小差值 I - 领扣 (LeetCode)
给定一个整数数组 A，找到 min(B)的总和，其中 B 的范围为A 的每个（连续）子数组。

由于答案可能很大，因此返回答案模 10^9 + 7。



示例：

输入：[3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。



提示：


	1 <= A <= 30000
	1 <= A[i] <= 30000



子数组的最小值之和 - 领扣 (LeetCode)
如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。

现在，给定两个正整数L 和R （以字符串形式表示），返回包含在范围 [L, R] 中的超级回文数的数目。



示例：

输入：L = 4, R = 1000
输出：4
解释：
4，9，121，以及 484 是超级回文数。
注意 676 不是一个超级回文数： 26 * 26 = 676，但是 26 不是回文数。



提示：


	1 <= len(L) <= 18
	1 <= len(R) <= 18
	L 和R是表示[1, 10^18)范围的整数的字符串。
	int(L) <= int(R)



超级回文数 - 领扣 (LeetCode)
按奇偶排序数组 - 领扣 (LeetCode)
给定一个非负整数数组 A，返回一个由 A 的所有偶数元素组成的数组，后面跟 A 的所有奇数元素。

你可以返回满足此条件的任何数组作为答案。



示例：

输入：[3,1,2,4]
输出：[2,4,3,1]
输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。




提示：


	1 <= A.length <= 5000
	0 <= A[i] <= 5000

水果成篮 - 领扣 (LeetCode)
在一排树中，第 i 棵树产生tree[i] 型的水果。
你可以从你选择的任何树开始，然后重复执行以下步骤：


	把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。
	移动到当前树右侧的下一棵树。如果右边没有树，就停下来。


请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。

你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。
用这个程序你能收集的水果总量是多少？



示例 1：

输入：[1,2,1]
输出：3
解释：我们可以收集 [1,2,1]。


示例 2：

输入：[0,1,2,2]
输出：3
解释：我们可以收集 [1,2,2].
如果我们从第一棵树开始，我们将只能收集到 [0, 1]。


示例 3：

输入：[1,2,3,2,2]
输出：4
解释：我们可以收集 [2,3,2,2].
如果我们从第一棵树开始，我们将只能收集到 [1, 2]。


示例 4：

输入：[3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：我们可以收集 [1,2,1,1,2].
如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 个水果。




提示：


	1 <= tree.length <= 40000
	0 <= tree[i] < tree.length

DI 序列的有效排列 - 领扣 (LeetCode)
我们给出 S，一个源于{&#39;D&#39;, &#39;I&#39;}的长度为 n的字符串 。（这些字母代表 &ldquo;减少&rdquo; 和 &ldquo;增加&rdquo;。）
有效排列是对整数 {0, 1, ..., n}的一个排列P[0], P[1], ..., P[n]，使得对所有的i：


	如果 S[i] == &#39;D&#39;，那么P[i] &gt; P[i+1]，以及；
	如果 S[i] == &#39;I&#39;，那么 P[i] < P[i+1]。


有多少个有效排列？因为答案可能很大，所以请返回你的答案模 10^9 + 7.



示例：

输入：DID
输出：5
解释：
(0, 1, 2, 3) 的五个有效排列是：
(1, 0, 3, 2)
(2, 0, 3, 1)
(2, 1, 3, 0)
(3, 0, 2, 1)
(3, 1, 2, 0)




提示：


	1 <= S.length <= 200
	S 仅由集合 {&#39;D&#39;, &#39;I&#39;}中的字符组成。



我们有一组排序的数字 D，它是 {&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;}的非空子集。（请注意，&#39;0&#39; 不包括在内。）

现在，我们用这些数字进行组合写数字，想用多少次就用多少次。例如D = {&#39;1&#39;,&#39;3&#39;,&#39;5&#39;}，我们可以写出像&#39;13&#39;, &#39;551&#39;, &#39;1351315&#39;这样的数字。

返回可以用 D 中的数字写出的小于或等于 N 的正整数的数目。



示例 1：

输入：D = [1,3,5,7], N = 100
输出：20
解释：
可写出的 20 个数字是：
1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.


示例 2：

输入：D = [1,4,9], N = 1000000000
输出：29523
解释：
我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，
81 个四位数字，243 个五位数字，729 个六位数字，
2187 个七位数字，6561 个八位数字和 19683 个九位数字。
总共，可以使用D中的数字写出 29523 个整数。



提示：


	D 是按排序顺序的数字 &#39;1&#39;-&#39;9&#39; 的子集。
	1 <= N <= 10^9

最大为 N 的数字组合 - 领扣 (LeetCode)
编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。

今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。

例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。



示例：

输入：[StockSpanner,next,next,next,next,next,next,next], [[],[100],[80],[60],[70],[60],[75],[85]]
输出：[null,1,1,1,2,1,4,6]
解释：
首先，初始化 S = StockSpanner()，然后：
S.next(100) 被调用并返回 1，
S.next(80) 被调用并返回 1，
S.next(60) 被调用并返回 1，
S.next(70) 被调用并返回 2，
S.next(60) 被调用并返回 1，
S.next(75) 被调用并返回 4，
S.next(85) 被调用并返回 6。

注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格
(包括今天的价格 75) 小于或等于今天的价格。




提示：


	调用StockSpanner.next(int price)时，将有1 <= price <= 10^5。
	每个测试用例最多可以调用 10000 次 StockSpanner.next。
	在所有测试用例中，最多调用150000次StockSpanner.next。
	此问题的总时间限制减少了 50%。

股票价格跨度 - 领扣 (LeetCode)
编写一个遍历游程编码序列的迭代器。

迭代器由 RLEIterator(int[] A) 初始化，其中A是某个序列的游程编码。更具体地，对于所有偶数 i，A[i] 告诉我们在序列中重复非负整数值 A[i + 1] 的次数。

迭代器支持一个函数：next(int n)，它耗尽接下来的 n 个元素（n &gt;= 1）并返回以这种方式耗去的最后一个元素。如果没有剩余的元素可供耗尽，则 next返回-1 。

例如，我们以A = [3,8,0,9,2,5]开始，这是序列[8,8,8,5,5]的游程编码。这是因为该序列可以读作 &ldquo;三个八，零个九，两个五&rdquo;。



示例：

输入：[RLEIterator,next,next,next,next], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]
输出：[null,8,8,5,-1]
解释：
RLEIterator 由 RLEIterator([3,8,0,9,2,5]) 初始化。
这映射到序列 [8,8,8,5,5]。
然后调用 RLEIterator.next 4次。

.next(2) 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。

.next(1) 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。

.next(1) 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。

.next(2) 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，
但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。




提示：


	0 <= A.length <= 1000
	A.length是偶数。
	0 <= A[i] <= 10^9
	每个测试用例最多调用1000次RLEIterator.next(int n)。
	每次调用RLEIterator.next(int n)都有1 <= n <= 10^9。

RLE 迭代器 - 领扣 (LeetCode)
给出了一个由小写字母组成的字符串 S。然后，我们可以进行任意次数的移动。

在每次移动中，我们选择前 K 个字母中的一个（从左侧开始），将其从原位置移除，并放置在字符串的末尾。

返回我们在任意次数的移动之后可以拥有的按字典顺序排列的最小字符串。



示例 1：

输入：S = cba, K = 1
输出：acb
解释：
在第一步中，我们将第一个字符（&ldquo;c&rdquo;）移动到最后，获得字符串 &ldquo;bac&rdquo;。
在第二步中，我们将第一个字符（&ldquo;b&rdquo;）移动到最后，获得最终结果 &ldquo;acb&rdquo;。


示例 2：

输入：S = baaca, K = 3
输出：aaabc
解释：
在第一步中，我们将第一个字符（&ldquo;b&rdquo;）移动到最后，获得字符串 &ldquo;aacab&rdquo;。
在第二步中，我们将第三个字符（&ldquo;c&rdquo;）移动到最后，获得最终结果 &ldquo;aaabc&rdquo;。




提示：


	1 <= K <= S.length<= 1000
	S只由小写字母组成。

有序队列 - 领扣 (LeetCode)
我们有一个非负整数数组A。

对于每个（连续的）子数组B =[A[i], A[i+1], ..., A[j]] （i <= j），我们对B中的每个元素进行按位或操作，获得结果A[i] | A[i+1] | ... | A[j]。

返回可能结果的数量。 （多次出现的结果在最终答案中仅计算一次。）



示例 1：

输入：[0]
输出：1
解释：
只有一个可能的结果 0 。


示例 2：

输入：[1,1,2]
输出：3
解释：
可能的子数组为 [1]，[1]，[2]，[1, 1]，[1, 2]，[1, 1, 2]。
产生的结果为 1，1，2，1，3，3 。
有三个唯一值，所以答案是 3 。


示例3：

输入：[1,2,4]
输出：6
解释：
可能的结果是 1，2，3，4，6，以及 7 。




提示：


	1 <= A.length <= 50000
	0 <= A[i] <= 10^9

子数组按位或操作 - 领扣 (LeetCode)
给定一个树，按中序遍历重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。



示例 ：

输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]

       5
      / \
    3    6
   / \    \
  2   4    8
/        / \ 
1        7   9

输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

 1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
           \
            7
             \
              8
               \
                 9  



提示：


	给定树中的结点数介于 1 和100 之间。
	每个结点都有一个从 0 到 1000 范围内的唯一整数值。

递增顺序查找树 - 领扣 (LeetCode)
如果数组是单调递增或单调递减的，那么它是单调的。

如果对于所有 i <= j，A[i] <= A[j]，那么数组 A 是单调递增的。 如果对于所有 i <= j，A[i]&gt; = A[j]，那么数组 A 是单调递减的。

当给定的数组 A是单调数组时返回 true，否则返回 false。






示例 1：

输入：[1,2,2,3]
输出：true


示例 2：

输入：[6,5,4,4]
输出：true


示例 3：

输入：[1,3,2]
输出：false


示例 4：

输入：[1,2,4,5]
输出：true


示例5：

输入：[1,1,1]
输出：true




提示：


	1 <= A.length <= 50000
	-100000 <= A[i] <= 100000

单调数列 - 领扣 (LeetCode)
实现 FreqStack，模拟类似栈的数据结构的操作的一个类。

FreqStack有两个函数：


	push(int x)，将整数x推入栈中。
	pop()，它移除并返回栈中出现最频繁的元素。
	
		如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。
	
	




示例：

输入：
[FreqStack,push,push,push,push,push,push,pop,pop,pop,pop],
[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
输出：[null,null,null,null,null,null,null,5,7,5,4]
解释：
执行六次 .push 操作后，栈自底向上为 [5,7,5,7,4,5]。然后：

pop() -&gt; 返回 5，因为 5 是出现频率最高的。
栈变成 [5,7,5,7,4]。

pop() -&gt; 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈顶。
栈变成 [5,7,5,4]。

pop() -&gt; 返回 5 。
栈变成 [5,7,4]。

pop() -&gt; 返回 4 。
栈变成 [5,7]。




提示：


	对FreqStack.push(int x)的调用中0 <= x <= 10^9。
	如果栈的元素数目为零，则保证不会调用 FreqStack.pop()。
	单个测试样例中，对FreqStack.push的总调用次数不会超过10000。
	单个测试样例中，对FreqStack.pop的总调用次数不会超过10000。
	所有测试样例中，对FreqStack.push和 FreqStack.pop的总调用次数不会超过150000。



最大频率栈 - 领扣 (LeetCode)
所有可能的满二叉树 - 领扣 (LeetCode)
满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。

返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。

答案中每个树的每个结点都必须有 node.val=0。

你可以按任何顺序返回树的最终列表。



示例：

输入：7
输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
解释：





提示：


	1 <= N <= 20

特殊等价字符串组 - 领扣 (LeetCode)
你将得到一个字符串数组 A。

如果经过任意次数的移动，S == T，那么两个字符串 S 和 T 是特殊等价的。



一次移动包括选择两个索引 i 和 j，且i％2 == j％2，并且交换 S[j] 和 S [i]。

现在规定，A 中的特殊等价字符串组是 A 的非空子集 S，这样不在 S 中的任何字符串与 S 中的任何字符串都不是特殊等价的。



返回 A中特殊等价字符串组的数量。






示例 1：

输入：[a,b,c,a,c,c]
输出：3
解释：3 组 [a,a]，[b]，[c,c,c]


示例 2：

输入：[aa,bb,ab,ba]
输出：4
解释：4 组 [aa]，[bb]，[ab]，[ba]


示例 3：

输入：[abc,acb,bac,bca,cab,cba]
输出：3
解释：3 组 [abc,cba]，[acb,bca]，[bac,cab]


示例 4：

输入：[abcd,cdab,adcb,cbad]
输出：1
解释：1 组 [abcd,cdab,adcb,cbad]




提示：


	1 <= A.length <= 1000
	1 <= A[i].length <= 20
	所有A[i]都具有相同的长度。
	所有A[i]都只由小写字母组成。

三维形体的表面积 - 领扣 (LeetCode)
在N*N的网格上，我们放置一些1 * 1 * 1的立方体。

每个值v = grid[i][j]表示v个正方体叠放在单元格(i, j)上。

返回结果形体的总表面积。






示例 1：

输入：[[2]]
输出：10


示例 2：

输入：[[1,2],[3,4]]
输出：34


示例 3：

输入：[[1,0],[0,2]]
输出：16


示例 4：

输入：[[1,1,1],[1,0,1],[1,1,1]]
输出：32


示例5：

输入：[[2,2,2],[2,1,2],[2,2,2]]
输出：46




提示：


	1 <= N <= 50
	0 <= grid[i][j] <= 50

给定一个整数数组 A ，考虑 A 的所有非空子序列。

对于任意序列 S ，设 S 的宽度是 S 的最大元素和最小元素的差。

返回 A 的所有子序列的宽度之和。

由于答案可能非常大，请返回答案模 10^9+7。



示例：

输入：[2,1,3]
输出：6
解释：
子序列为 [1]，[2]，[3]，[2,1]，[2,3]，[1,3]，[2,1,3] 。
相应的宽度是 0，0，0，1，1，2，2 。
这些宽度之和是 6 。




提示：


	1 <= A.length <= 20000
	1 <= A[i] <= 20000

子序列宽度之和 - 领扣 (LeetCode)
你有一个单词列表words和一个模式pattern，你想知道 words 中的哪些单词与模式匹配。

如果存在字母的排列 p，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。

（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）

返回 words 中与给定模式匹配的单词列表。

你可以按任何顺序返回答案。



示例：

输入：words = [abc,deq,mee,aqq,dkd,ccc], pattern = abb
输出：[mee,aqq]
解释：
mee 与模式匹配，因为存在排列 {a -&gt; m, b -&gt; e, ...}。
ccc 与模式不匹配，因为 {a -&gt; c, b -&gt; c, ...} 不是排列。
因为 a 和 b 映射到同一个字母。



提示：


	1 <= words.length <= 50
	1 <= pattern.length = words[i].length<= 20

查找和替换模式 - 领扣 (LeetCode)
返回与给定的前序和后序遍历匹配的任何二叉树。

pre和post遍历中的值是不同的正整数。



示例：

输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]




提示：


	1 <= pre.length == post.length <= 30
	pre[]和post[]都是1, 2, ..., pre.length的排列
	每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。

根据前序和后序遍历构造二叉树 - 领扣 (LeetCode)
爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i块糖的大小，B[j] 是鲍勃拥有的第 j块糖的大小。

因为他们是朋友，所以他们想交换一个糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）

返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1]是 Bob 必须交换的糖果棒的大小。

如果有多个答案，你可以返回其中任何一个。保证答案存在。



示例 1：

输入：A = [1,1], B = [2,2]
输出：[1,2]


示例 2：

输入：A = [1,2], B = [2,3]
输出：[1,2]


示例 3：

输入：A = [2], B = [1,3]
输出：[2,3]


示例 4：

输入：A = [1,2,5], B = [2,4]
输出：[5,4]




提示：


	1 <= A.length <= 10000
	1 <= B.length <= 10000
	1 <= A[i] <= 100000
	1 <= B[i] <= 100000
	保证爱丽丝与鲍勃的糖果总量不同。
	答案肯定存在。

公平的糖果交换 - 领扣 (LeetCode)
你将获得K个鸡蛋，并可以使用一栋从1到N共有 N层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层F ，满足0 <= F <= N 任何从高于 F的楼层落下的鸡蛋都会碎，从F楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层X扔下（满足1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？






示例 1：

输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。


示例 2：

输入：K = 2, N = 6
输出：3


示例 3：

输入：K = 3, N = 14
输出：4




提示：


	1 <= K <= 100
	1 <= N <= 10000

鸡蛋掉落 - 领扣 (LeetCode)
可能的二分法 - 领扣 (LeetCode)
给定一组N人（编号为1, 2, ..., N），我们想把每个人分进任意大小的两组。

每个人都可能不喜欢其他人，那么他们不应该属于同一组。

形式上，如果 dislikes[i] = [a, b]，表示不允许将编号为 a 和 b 的人归入同一组。

当可以用这种方法将每个人分进两组时，返回 true；否则返回 false。






示例 1：

输入：N = 4, dislikes = [[1,2],[1,3],[2,4]]
输出：true
解释：group1 [1,4], group2 [2,3]


示例 2：

输入：N = 3, dislikes = [[1,2],[1,3],[2,3]]
输出：false


示例 3：

输入：N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]
输出：false




提示：


	1 <= N <= 2000
	0 <= dislikes.length <= 10000
	1 <= dislikes[i][j] <= N
	dislikes[i][0] < dislikes[i][1]
	对于dislikes[i] == dislikes[j]不存在i != j

在R行C列的矩阵上，我们从(r0, c0)面朝东面开始

这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。

现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。

每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。

最终，我们到过网格的所有R * C个空间。

按照访问顺序返回表示网格位置的坐标列表。



示例 1：

输入：R = 1, C = 4, r0 = 0, c0 = 0
输出：[[0,0],[0,1],[0,2],[0,3]]






示例 2：

输入：R = 5, C = 6, r0 = 1, c0 = 4
输出：[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]






提示：


	1 <= R <= 100
	1 <= C <= 100
	0 <= r0 < R
	0 <= c0 < C

螺旋矩阵 III - 领扣 (LeetCode)
给定两个句子A和B。（句子是一串由空格分隔的单词。每个单词仅由小写字母组成。）

如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。

返回所有不常用单词的列表。

您可以按任何顺序返回列表。






示例 1：

输入：A = this apple is sweet, B = this apple is sour
输出：[sweet,sour]


示例2：

输入：A = apple apple, B = banana
输出：[banana]




提示：


	0 <= A.length <= 200
	0 <= B.length <= 200
	A 和B都只包含空格和小写字母。

两句话中的不常见单词 - 领扣 (LeetCode)
三维形体投影面积 - 领扣 (LeetCode)
在N*N的网格中，我们放置了一些与 x，y，z 三轴对齐的1 * 1 * 1立方体。

每个值v = grid[i][j]表示 v个正方体叠放在单元格(i, j)上。

现在，我们查看这些立方体在 xy、yz和 zx平面上的投影。

投影就像影子，将三维形体映射到一个二维平面上。

在这里，从顶部、前面和侧面看立方体时，我们会看到&ldquo;影子&rdquo;。

返回所有三个投影的总面积。















示例 1：

输入：[[2]]
输出：5


示例 2：

输入：[[1,2],[3,4]]
输出：17
解释：
这里有该形体在三个轴对齐平面上的三个投影(&ldquo;阴影部分&rdquo;)。



示例 3：

输入：[[1,0],[0,2]]
输出：8


示例 4：

输入：[[1,1,1],[1,0,1],[1,1,1]]
输出：14


示例 5：

输入：[[2,2,2],[2,1,2],[2,2,2]]
输出：21




提示：


	1 <= grid.length = grid[0].length<= 50
	0 <= grid[i][j] <= 50

从具有0 到 N-1 的结点的无向图（&ldquo;原始图&rdquo;）开始，对一些边进行细分。

该图给出如下：edges[k]是整数对(i, j, n)组成的列表，使(i, j) 是原始图的边。

n 是该边上新结点的总数

然后，将边(i, j)从原始图中删除，将n个新结点(x_1, x_2, ..., x_n)添加到原始图中，

将n+1条新边(i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j)添加到原始图中。

现在，你将从原始图中的结点0处出发，并且每次移动，你都将沿着一条边行进。

返回最多 M 次移动可以达到的结点数。



示例 1：

输入：edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3
输出：13
解释：
在 M = 6 次移动之后在最终图中可到达的结点如下所示。



示例 2：

输入：edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4
输出：23



提示：


	0 <= edges.length <= 10000
	0 <= edges[i][0] <edges[i][1] < N
	不存在任何i != j情况下edges[i][0] == edges[j][0]且edges[i][1] == edges[j][1].
	原始图没有平行的边。
	0 <= edges[i][2] <= 10000
	0 <= M <= 10^9
	1 <= N <= 3000



细分图中的可到达结点 - 领扣 (LeetCode)
第i个人的体重为people[i]，每艘船可以承载的最大重量为limit。

每艘船最多可同时载两人，但条件是这些人的重量之和最多为limit。

返回载到每一个人所需的最小船数。(保证每个人都能被船载)。



示例 1：

输入：people = [1,2], limit = 3
输出：1
解释：1 艘船载 (1, 2)


示例 2：

输入：people = [3,2,2,1], limit = 3
输出：3
解释：3 艘船分别载 (1, 2), (2) 和 (3)


示例 3：

输入：people = [3,5,3,4], limit = 5
输出：4
解释：4 艘船分别载 (3), (3), (4), (5)

提示：


	1 <=people.length <= 50000
	1 <= people[i] <=limit <= 30000

救生艇 - 领扣 (LeetCode)
索引处的解码字符串 - 领扣 (LeetCode)
给定一个编码字符串 S。为了找出解码字符串并将其写入磁带，从编码字符串中每次读取一个字符，并采取以下步骤：


	如果所读的字符是字母，则将该字母写在磁带上。
	如果所读的字符是数字（例如 d），则整个当前磁带总共会被重复写d-1 次。


现在，对于给定的编码字符串 S 和索引 K，查找并返回解码字符串中的第K个字母。



示例 1：

输入：S = leet2code3, K = 10
输出：o
解释：
解码后的字符串为 leetleetcodeleetleetcodeleetleetcode。
字符串中的第 10 个字母是 o。


示例 2：

输入：S = ha22, K = 5
输出：h
解释：
解码后的字符串为 hahahaha。第 5 个字母是 h。


示例 3：

输入：S = a2345678999999999999999, K = 1
输出：a
解释：
解码后的字符串为 a 重复 8301530446056247680 次。第 1 个字母是 a。




提示：


	2 <= S.length <= 100
	S只包含小写字母与数字 2 到 9 。
	S以字母开头。
	1 <= K <= 10^9
	解码后的字符串保证少于2^63个字母。

在圆内随机生成点 - 领扣 (LeetCode)
给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数randPoint。

说明:


	输入值和输出值都将是浮点数。
	圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。
	圆周上的点也认为是在圆中。
	randPoint返回一个包含随机点的x坐标和y坐标的大小为2的数组。


示例 1：


输入: 
[Solution,randPoint,randPoint,randPoint]
[[1,0,0],[],[],[]]
输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]


示例 2：


输入: 
[Solution,randPoint,randPoint,randPoint]
[[10,5,-7.5],[],[],[]]
输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]

输入语法说明：

输入是两个列表：调用成员函数名和调用的参数。Solution的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。randPoint没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。
给定一个非重叠轴对齐矩形的列表 rects，写一个函数 pick 随机均匀地选取矩形覆盖的空间中的整数点。

提示：


	整数点是具有整数坐标的点。
	矩形周边上的点包含在矩形覆盖的空间中。
	第 i 个矩形 rects [i] = [x1，y1，x2，y2]，其中[x1，y1] 是左下角的整数坐标，[x2，y2] 是右上角的整数坐标。
	每个矩形的长度和宽度不超过 2000。
	1 <= rects.length<= 100
	pick 以整数坐标数组[p_x, p_y]的形式返回一个点。
	pick 最多被调用10000次。




示例 1：


输入: 
[Solution,pick,pick,pick]
[[[[1,1,5,5]]],[],[],[]]
输出: 
[null,[4,1],[4,1],[3,3]]


示例 2：


输入: 
[Solution,pick,pick,pick,pick,pick]
[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]
输出: 
[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]



输入语法的说明：

输入是两个列表：调用的子例程及其参数。Solution 的构造函数有一个参数，即矩形数组 rects。pick 没有参数。参数总是用列表包装的，即使没有也是如此。


非重叠矩形中的随机点 - 领扣 (LeetCode)
随机翻转矩阵 - 领扣 (LeetCode)
题中给出一个 n 行 n 列的二维矩阵 (n_rows,n_cols)，且所有值被初始化为 0。要求编写一个 flip 函数，均匀随机的将矩阵中的 0 变为 1，并返回该值的位置下标 [row_id,col_id]；同样编写一个 reset 函数，将所有的值都重新置为 0。尽量最少调用随机函数 Math.random()，并且优化时间和空间复杂度。

注意:

1.1 <= n_rows, n_cols <= 10000

2. 0 <= row.id < n_rows 并且 0 <= col.id < n_cols

3.当矩阵中没有值为 0 时，不可以调用 flip 函数

4.调用 flip 和 reset 函数的次数加起来不会超过 1000 次

示例 1：


输入: 
[Solution,flip,flip,flip,flip]
[[2,3],[],[],[],[]]
输出: [null,[0,1],[1,2],[1,0],[1,1]]


示例 2：


输入: 
[Solution,flip,flip,reset,flip]
[[1,2],[],[],[],[]]
输出: [null,[0,0],[0,1],null,[0,0]]

输入语法解释：

输入包含两个列表：被调用的子程序和他们的参数。Solution 的构造函数有两个参数，分别为 n_rows 和 n_cols。flip和 reset 没有参数，参数总会以列表形式给出，哪怕该列表为空
按权重随机选择 - 领扣 (LeetCode)
给定一个正整数数组w ，其中w[i]代表位置i的权重，请写一个函数pickIndex，它可以随机地获取位置i，选取位置i的概率与w[i]成正比。

说明:


	1 <= w.length <= 10000
	1 <= w[i] <= 10^5
	pickIndex将被调用不超过10000次


示例1:


输入: 
[Solution,pickIndex]
[[[1]],[]]
输出: [null,0]


示例2:


输入: 
[Solution,pickIndex,pickIndex,pickIndex,pickIndex,pickIndex]
[[[1,3]],[],[],[],[],[]]
输出: [null,0,1,1,1,0]

输入语法说明：

输入是两个列表：调用成员函数名和调用的参数。Solution的构造函数有一个参数，即数组w。pickIndex没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。
盈利计划 - 领扣 (LeetCode)
帮派里有 G 名成员，他们可能犯下各种各样的罪行。

第i种犯罪会产生profit[i]的利润，它要求group[i]名成员共同参与。

让我们把这些犯罪的任何子集称为盈利计划，该计划至少产生P 的利润。

有多少种方案可以选择？因为答案很大，所以返回它模10^9 + 7的值。



示例1：

输入：G = 5, P = 3, group = [2,2], profit = [2,3]
输出：2
解释： 
至少产生 3 的利润，该帮派可以犯下罪 0 和罪 1 ，或仅犯下罪 1 。
总的来说，有两种方案。


示例2:

输入：G = 10, P = 5, group = [2,3,5], profit = [6,7,8]
输出：7
解释：
至少产生 5 的利润，只要他们犯其中一种罪就行，所以该帮派可以犯下任何罪行 。
有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。




提示：


	1 <= G <= 100
	0 <= P <= 100
	1 <= group[i] <= 100
	0 <= profit[i] <= 100
	1 <= group.length = profit.length <= 100



如果正整数可以被 A 或 B 整除，那么它是神奇的。

返回第 N 个神奇数字。由于答案可能非常大，返回它模10^9 + 7的结果。






示例 1：

输入：N = 1, A = 2, B = 3
输出：2


示例2：

输入：N = 4, A = 2, B = 3
输出：6


示例 3：

输入：N = 5, A = 2, B = 4
输出：10


示例 4：

输入：N = 3, A = 6, B = 4
输出：8




提示：


	1 <= N<= 10^9
	2 <= A<= 40000
	2 <= B<= 40000

第 N 个神奇数字 - 领扣 (LeetCode)
石子游戏 - 领扣 (LeetCode)
亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子piles[i]。

游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。

亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。

假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回true，当李赢得比赛时返回false。



示例：

输入：[5,3,4,5]
输出：true
解释：
亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。
如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。




提示：


	2 <= piles.length <= 500
	piles.length 是偶数。
	1 <= piles[i] <= 500
	sum(piles)是奇数。

给定一个带有头结点head的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。



示例 1：

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.


示例2：

输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。




提示：


	给定链表的结点数介于1和100之间。

链表的中间结点 - 领扣 (LeetCode)
珂珂喜欢吃香蕉。这里有N堆香蕉，第 i 堆中有piles[i]根香蕉。警卫已经离开了，将在H小时后回来。

珂珂可以决定她吃香蕉的速度K（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。






示例 1：

输入: piles = [3,6,7,11], H = 8
输出: 4


示例2：

输入: piles = [30,11,23,4,20], H = 5
输出: 30


示例3：

输入: piles = [30,11,23,4,20], H = 6
输出: 23




提示：


	1 <= piles.length <= 10^4
	piles.length <= H <= 10^9
	1 <= piles[i] <= 10^9

爱吃香蕉的珂珂 - 领扣 (LeetCode)
模拟行走机器人 - 领扣 (LeetCode)
机器人在一个无限大小的网格上行走，从点(0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：


	-2：向左转90 度
	-1：向右转 90 度
	1 <= x <= 9：向前移动x个单位长度


在网格上有一些格子被视为障碍物。

第 i个障碍物位于网格点 (obstacles[i][0], obstacles[i][1])

如果机器人试图走到障碍物上方，那么它将停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。

返回从原点到机器人的最大欧式距离的平方。



示例 1：

输入: commands = [4,-1,3], obstacles = []
输出: 25
解释: 机器人将会到达 (3, 4)


示例2：

输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
输出: 65
解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处




提示：


	0 <= commands.length <= 10000
	0 <= obstacles.length <= 10000
	-30000 <= obstacle[i][0] <= 30000
	-30000 <= obstacle[i][1] <= 30000
	答案保证小于2 ^ 31

最长的斐波那契子序列的长度 - 领扣 (LeetCode)
如果序列X_1, X_2, ..., X_n满足下列条件，就说它是斐波那契式的：


	n &gt;= 3
	对于所有i + 2 <= n，都有X_i + X_{i+1} = X_{i+2}


给定一个严格递增的正整数数组形成序列，找到 A 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。

（回想一下，子序列是从原序列 A中派生出来的，它从 A中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如，[3, 5, 8]是[3, 4, 5, 6, 7, 8]的一个子序列）






示例 1：

输入: [1,2,3,4,5,6,7,8]
输出: 5
解释:
最长的斐波那契式子序列为：[1,2,3,5,8] 。


示例2：

输入: [1,3,7,11,12,14,18]
输出: 3
解释:
最长的斐波那契式子序列有：
[1,11,12]，[3,11,14] 以及 [7,11,18] 。




提示：


	3 <= A.length <= 1000
	1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9
	（对于以 Java，C，C++，以及C# 的提交，时间限制被减少了 50%）

请考虑一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个叶值序列 。



举个例子，如上图所示，给定一颗叶值序列为(6, 7, 4, 9, 8)的树。

如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是叶相似的。

如果给定的两个头结点分别为root1 和root2的树是叶相似的，则返回true；否则返回 false 。



提示：


	给定的两颗树可能会有1到100个结点。

叶子相似的树 - 领扣 (LeetCode)
用 Rand7() 实现 Rand10() - 领扣 (LeetCode)
已有方法rand7可生成 1 到 7 范围内的均匀随机整数，试写一个方法rand10生成 1 到 10 范围内的均匀随机整数。

不要使用系统的Math.random()方法。






示例 1:


输入: 1
输出: [7]


示例 2:


输入: 2
输出: [8,4]


示例 3:


输入: 3
输出: [8,1,10]




提示:


	rand7已定义。
	传入参数:n表示rand10的调用次数。




进阶:


	rand7()调用次数的期望值是多少?
	你能否尽量少调用 rand7() ?

最低加油次数 - 领扣 (LeetCode)
汽车从起点出发驶向目的地，该目的地位于出发位置东面 target英里处。

沿途有加油站，每个station[i]代表一个加油站，它位于出发位置东面station[i][0]英里处，并且有station[i][1]升汽油。

假设汽车油箱的容量是无限的，其中最初有startFuel升燃料。它每行驶 1 英里就会用掉 1 升汽油。

当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。

为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。

注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。



示例 1：

输入：target = 1, startFuel = 1, stations = []
输出：0
解释：我们可以在不加油的情况下到达目的地。


示例 2：

输入：target = 100, startFuel = 1, stations = [[10,100]]
输出：-1
解释：我们无法抵达目的地，甚至无法到达第一个加油站。


示例 3：

输入：target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
输出：2
解释：
我们出发时有 10 升燃料。
我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。
然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），
并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。
我们沿途在1两个加油站停靠，所以返回 2 。




提示：


	1 <= target, startFuel, stations[i][1] <= 10^9
	0 <= stations.length <= 500
	0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target

给定两个大小相等的数组A和B，A 相对于 B 的优势可以用满足A[i] &gt; B[i]的索引 i的数目来描述。

返回A的任意排列，使其相对于 B的优势最大化。



示例 1：

输入：A = [2,7,11,15], B = [1,10,4,11]
输出：[2,11,7,15]


示例 2：

输入：A = [12,24,8,32], B = [13,25,32,11]
输出：[24,32,8,12]




提示：


	1 <= A.length = B.length <= 10000
	0 <= A[i] <= 10^9
	0 <= B[i] <= 10^9

优势洗牌 - 领扣 (LeetCode)
从正整数 N开始，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。

如果我们可以通过上述方式得到2 的幂，返回 true；否则，返回 false。






示例 1：

输入：1
输出：true


示例 2：

输入：10
输出：false


示例 3：

输入：16
输出：true


示例 4：

输入：24
输出：false


示例 5：

输入：46
输出：true




提示：


	1 <= N <= 10^9

重新排序得到 2 的幂 - 领扣 (LeetCode)
给定一个正整数N，找到并返回 N的二进制表示中两个连续的 1 之间的最长距离。

如果没有两个连续的 1，返回 0 。






示例 1：

输入：22
输出：2
解释：
22 的二进制是 0b10110 。
在 22 的二进制表示中，有三个 1，组成两对连续的 1 。
第一对连续的 1 中，两个 1 之间的距离为 2 。
第二对连续的 1 中，两个 1 之间的距离为 1 。
答案取两个距离之中最大的，也就是 2 。


示例 2：

输入：5
输出：2
解释：
5 的二进制是 0b101 。


示例 3：

输入：6
输出：1
解释：
6 的二进制是 0b110 。


示例 4：

输入：8
输出：0
解释：
8 的二进制是 0b1000 。
在 8 的二进制表示中没有连续的 1，所以返回 0 。




提示：


	1 <= N <= 10^9

二进制间距 - 领扣 (LeetCode)
转置矩阵 - 领扣 (LeetCode)
给定一个矩阵A，返回A的转置矩阵。

矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。



示例 1：

输入：[[1,2,3],[4,5,6],[7,8,9]]
输出：[[1,4,7],[2,5,8],[3,6,9]]


示例 2：

输入：[[1,2,3],[4,5,6]]
输出：[[1,4],[2,5],[3,6]]




提示：


	1 <= A.length<= 1000
	1 <= A[0].length<= 1000

求出大于或等于N的最小回文素数。

回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是素数。

例如，2，3，5，7，11 以及13 是素数。

回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是回文数。

例如，12321 是回文数。



示例 1：

输入：6
输出：7


示例2：

输入：8
输出：11


示例3：

输入：13
输出：101



提示：


	1 <= N <= 10^8
	答案肯定存在，且小于2 * 10^8。





回文素数 - 领扣 (LeetCode)
给定一个根为root的二叉树，每个结点的深度是它到根的最短距离。

如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。

一个结点的子树是该结点加上它的所有后代的集合。

返回能满足&ldquo;以该结点为根的子树中包含所有最深的结点&rdquo;这一条件的具有最大深度的结点。



示例：

输入：[3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：

我们返回值为 2 的结点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的结点。
输入 [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4] 是对给定的树的序列化表述。
输出 [2, 7, 4] 是对根结点的值为 2 的子树的序列化表述。
输入和输出都具有 TreeNode 类型。




提示：


	树中结点的数量介于1 和500 之间。
	每个结点的值都是独一无二的。

具有所有最深结点的最小子树 - 领扣 (LeetCode)
给定一个二维网格grid。.代表一个空房间，#代表一堵墙，@是起点，（a,b, ...）代表钥匙，（A,B, ...）代表锁。

我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。

假设 K 为钥匙/锁的个数，且满足1 <= K <= 6，字母表中的前 K 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。

返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回-1。



示例 1：

输入：[@.a.#,###.#,b.A.B]
输出：8


示例 2：

输入：[@..aA,..B#.,....b]
输出：6




提示：


	1 <= grid.length<= 30
	1 <= grid[0].length<= 30
	grid[i][j]只含有&#39;.&#39;,&#39;#&#39;,&#39;@&#39;,&#39;a&#39;-&#39;f&#39;以及&#39;A&#39;-&#39;F&#39;
	钥匙的数目范围是[1, 6]，每个钥匙都对应一个不同的字母，正好打开一个对应的锁。

获取所有钥匙的最短路径 - 领扣 (LeetCode)
给定一个包含 [0，n ) 中独特的整数的黑名单 B，写一个函数从 [ 0，n ) 中返回一个不在 B 中的随机整数。

对它进行优化使其尽量少调用系统方法 Math.random() 。

提示:


	1 <= N <= 1000000000
	0 <= B.length < min(100000, N)
	[0, N)不包含N，详细参见interval notation。


示例 1:


输入: 
[Solution,pick,pick,pick]
[[1,[]],[],[],[]]
输出: [null,0,0,0]


示例 2:


输入: 
[Solution,pick,pick,pick]
[[2,[]],[],[],[]]
输出: [null,1,1,1]


示例 3:


输入: 
[Solution,pick,pick,pick]
[[3,[1]],[],[],[]]
Output: [null,0,0,2]


示例 4:


输入: 
[Solution,pick,pick,pick]
[[4,[2]],[],[],[]]
输出: [null,1,3,1]


输入语法说明：

输入是两个列表：调用成员函数名和调用的参数。Solution的构造函数有两个参数，N和黑名单B。pick没有参数，输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。
黑名单中的随机数 - 领扣 (LeetCode)
二叉树中所有距离为 K 的结点 - 领扣 (LeetCode)
给定一个二叉树（具有根结点root），一个目标结点target，和一个整数值 K 。

返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。






示例 1：

输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2

输出：[7,4,1]

解释：
所求结点为与目标结点（值为 5）距离为 2 的结点，
值分别为 7，4，以及 1



注意，输入的 root 和 target 实际上是树上的结点。
上面的输入仅仅是对这些对象进行了序列化描述。




提示：


	给定的树是非空的，且最多有K个结点。
	树上的每个结点都具有唯一的值0 <= node.val <= 500。
	目标结点target是树上的结点。
	0 <= K <= 1000.

返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。

如果没有和至少为K的非空子数组，返回-1。






示例 1：

输入：A = [1], K = 1
输出：1


示例 2：

输入：A = [1,2], K = 4
输出：-1


示例 3：

输入：A = [2,-1,2], K = 3
输出：3




提示：


	1 <= A.length <= 50000
	-10 ^ 5<= A[i] <= 10 ^ 5
	1 <= K <= 10 ^ 9

和至少为 K 的最短子数组 - 领扣 (LeetCode)
翻转矩阵后的得分 - 领扣 (LeetCode)
有一个二维矩阵A 其中每个元素的值为0或1。

移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。

在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

返回尽可能高的分数。






示例：

输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
输出：39
解释：
转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39



提示：


	1 <= A.length <= 20
	1 <= A[0].length <= 20
	A[i][j]是0 或1

在柠檬水摊上，每一杯柠檬水的售价为5美元。

顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

如果你能给每位顾客正确找零，返回true，否则返回 false。

示例 1：

输入：[5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。


示例 2：

输入：[5,5,10]
输出：true


示例 3：

输入：[10,10]
输出：false


示例 4：

输入：[5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。




提示：


	0 <= bills.length <= 10000
	bills[i]不是5就是10或是20

柠檬水找零 - 领扣 (LeetCode)
亲密字符串 - 领扣 (LeetCode)
给定两个由小写字母构成的字符串A和B，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回true；否则返回 false 。



示例 1：

输入： A = ab, B = ba
输出： true


示例 2：

输入： A = ab, B = ab
输出： false


示例 3:

输入： A = aa, B = aa
输出： true


示例 4：

输入： A = aaaaaaabc, B = aaaaaaacb
输出： true


示例 5：

输入： A = , B = aa
输出： false




提示：


	0 <= A.length <= 20000
	0 <= B.length <= 20000
	A和B仅由小写字母构成。

有一个特殊的正方形房间，每面墙上都有一面镜子。除西南角以外，每个角落都放有一个接受器，编号为0，1，以及2。

正方形房间的墙壁长度为p，一束激光从西南角射出，首先会与东墙相遇，入射点到接收器 0 的距离为 q 。

返回光线最先遇到的接收器的编号（保证光线最终会遇到一个接收器）。



示例：

输入： p = 2, q = 1
输出： 2
解释： 这条光线在第一次被反射回左边的墙时就遇到了接收器 2 。




提示：


	1 <= p <= 1000
	0 <= q <= p

镜面反射 - 领扣 (LeetCode)
雇佣 K 名工人的最低成本 - 领扣 (LeetCode)
有 N名工人。第i名工人的工作质量为quality[i]，其最低期望工资为wage[i]。

现在我们想雇佣K名工人组成一个工资组。在雇佣一组 K 名工人时，我们必须按照下述规则向他们支付工资：


	对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。
	工资组中的每名工人至少应当得到他们的最低期望工资。


返回组成一个满足上述条件的工资组至少需要多少钱。






示例 1：

输入： quality = [10,20,5], wage = [70,50,30], K = 2
输出： 105.00000
解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。

示例 2：

输入： quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3
输出： 30.66667
解释： 我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。



提示：


	1 <= K <= N <= 10000，其中N = quality.length = wage.length
	1 <= quality[i] <= 10000
	1 <= wage[i] <= 10000
	与正确答案误差在10^-5之内的答案将被视为正确的。

括号的分数 - 领扣 (LeetCode)
给定一个平衡括号字符串S，按下述规则计算该字符串的分数：


	() 得 1 分。
	AB 得A + B分，其中 A 和 B 是平衡括号字符串。
	(A) 得2 * A分，其中 A 是平衡括号字符串。




示例 1：

输入： ()
输出： 1


示例 2：

输入： (())
输出： 2


示例3：

输入： ()()
输出： 2


示例4：

输入： (()(()))
输出： 6




提示：


	S是平衡括号字符串，且只含有(和)。
	2 <= S.length <= 50

考场就座 - 领扣 (LeetCode)
在考场里，一排有N个座位，分别编号为0, 1, 2, ..., N-1。

当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)

返回ExamRoom(int N)类，它有两个公开的函数：其中，函数ExamRoom.seat()会返回一个int（整型数据），代表学生坐的位置；函数ExamRoom.leave(int p)代表坐在座位 p 上的学生现在离开了考场。请确保每次调用ExamRoom.leave(p)时都有学生坐在座位p上。



示例：

输入：[ExamRoom,seat,seat,seat,seat,leave,seat], [[10],[],[],[],[],[4],[]]
输出：[null,0,9,4,2,null,5]
解释：
ExamRoom(10) -&gt; null
seat() -&gt; 0，没有人在考场里，那么学生坐在 0 号座位上。
seat() -&gt; 9，学生最后坐在 9 号座位上。
seat() -&gt; 4，学生最后坐在 4 号座位上。
seat() -&gt; 2，学生最后坐在 2 号座位上。
leave(4) -&gt; null
seat() -&gt; 5，学生最后坐在 5 号座位上。




提示：


	1 <= N <= 10^9
	在所有的测试样例中ExamRoom.seat()和ExamRoom.leave()最多被调用10^4次。
	调用ExamRoom.leave(p)时需要确保当前有学生坐在座位 p 上。

相似度为 K 的字符串 - 领扣 (LeetCode)
如果可以通过将 A 中的两个小写字母精确地交换位置 K 次得到与 B 相等的字符串，我们称字符串A和B的相似度为 K（K为非负整数）。

给定两个字母异位词A和B，返回 A 和 B的相似度 K 的最小值。



示例 1：

输入：A = ab, B = ba
输出：1


示例 2：

输入：A = abc, B = bca
输出：2


示例 3：

输入：A = abac, B = baca
输出：2


示例 4：

输入：A = aabc, B = abca
输出：2



提示：


	1 <= A.length == B.length <= 20
	A和B只包含集合{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;}中的小写字母。

车队 - 领扣 (LeetCode)
N 辆车沿着一条车道驶向位于target英里之外的共同目的地。

每辆车i以恒定的速度speed[i]（英里/小时），从初始位置position[i]（英里） 沿车道驶向目的地。

一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车以相同的速度紧接着行驶。

此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。

车队是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。

即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。



会有多少车队到达目的地?



示例：

输入：target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
输出：3
解释：
从 10 和 8 开始的车会组成一个车队，它们在 12 处相遇。
从 0 处开始的车无法追上其它车，所以它自己就是一个车队。
从 5 和 3 开始的车会组成一个车队，它们在 6 处相遇。
请注意，在到达目的地之前没有其它车会遇到这些车队，所以答案是 3。



提示：


	0 <= N <= 10 ^ 4
	0 < target<= 10 ^ 6
	0 <speed[i] <= 10 ^ 6
	0 <= position[i] < target
	所有车的初始位置各不相同。

我们把符合下列属性的数组A称作山脉：


	A.length &gt;= 3
	存在 0 < i< A.length - 1 使得A[0] < A[1] < ... A[i-1] < A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]


给定一个确定为山脉的数组，返回任何满足A[0] < A[1] < ... A[i-1] < A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]的 i的值。



示例 1：

输入：[0,1,0]
输出：1


示例 2：

输入：[0,2,1,0]
输出：1



提示：


	3 <= A.length <= 10000
	0 <= A[i] <= 10^6
	A 是如上定义的山脉



山脉数组的峰顶索引 - 领扣 (LeetCode)
在一组 N 个人（编号为0, 1, 2, ..., N-1）中，每个人都有不同数目的钱，以及不同程度的安静（quietness）。

为了方便起见，我们将编号为x的人简称为 personx。

如果能够肯定 personx比 persony更有钱的话，我们会说richer[i] = [x, y]。注意richer可能只是有效观察的一个子集。

另外，如果 personx的安静程度为q，我们会说quiet[x] = q。

现在，返回答案answer，其中answer[x] = y的前提是，在所有拥有的钱不少于personx的人中，persony是最安静的人（也就是安静值quiet[y]最小的人）。

示例：

输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
输出：[5,5,2,5,4,5,6,7]
解释： 
answer[0] = 5，
person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。
唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，
但是目前还不清楚他是否比 person 0 更有钱。

answer[7] = 7，
在所有拥有的钱肯定不少于 person 7 的人中(这可能包括 person 3，4，5，6 以及 7)，
最安静(有较低安静值 quiet[x])的人是 person 7。

其他的答案也可以用类似的推理来解释。


提示：


	1 <= quiet.length = N <= 500
	0 <= quiet[i] < N，所有quiet[i]都不相同。
	0 <= richer.length <= N * (N-1) / 2
	0 <= richer[i][j] < N
	richer[i][0] != richer[i][1]
	richer[i]都是不同的。
	对richer的观察在逻辑上是一致的。

喧闹和富有 - 领扣 (LeetCode)
矩形面积 II - 领扣 (LeetCode)
我们给出了一个（轴对齐的）矩形列表rectangles。 对于rectangle[i] = [x1, y1, x2, y2]，其中（x1，y1）是矩形i左下角的坐标，（x2，y2）是该矩形右上角的坐标。

找出平面中所有矩形叠加覆盖后的总面积。 由于答案可能太大，请返回它对 10 ^ 9 + 7 取模的结果。



示例 1：

输入：[[0,0,2,2],[1,0,2,3],[1,0,3,1]]
输出：6
解释：如图所示。


示例 2：

输入：[[0,0,1000000000,1000000000]]
输出：49
解释：答案是 10^18 对 (10^9 + 7) 取模的结果， 即 (10^9)^2 &rarr; (-7)^2 = 49 。


提示：


	1 <= rectangles.length <= 200
	rectanges[i].length = 4
	0 <= rectangles[i][j] <= 10^9
	矩形叠加覆盖后的总面积不会超越2^63 - 1，这意味着可以用一个64 位有符号整数来保存面积结果。

到最近的人的最大距离 - 领扣 (LeetCode)
在一排座位（seats）中，1代表有人坐在座位上，0代表座位上是空的。

至少有一个空座位，且至少有一人坐在座位上。

亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。

返回他到离他最近的人的最大距离。

示例 1：

输入：[1,0,0,0,1,0,1]
输出：2
解释：
如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。
如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。
因此，他到离他最近的人的最大距离是 2 。 


示例 2：

输入：[1,0,0,0]
输出：3
解释： 
如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。
这是可能的最大距离，所以答案是 3 。


提示：


	1 <= seats.length <= 20000
	seats中只含有 0 和 1，至少有一个 0，且至少有一个 1。

字母移位 - 领扣 (LeetCode)
有一个由小写字母组成的字符串 S，和一个整数数组 shifts。

我们将字母表中的下一个字母称为原字母的 移位（由于字母表是环绕的， &#39;z&#39;将会变成&#39;a&#39;）。

例如&middot;，shift(&#39;a&#39;) = &#39;b&#39;，shift(&#39;t&#39;) = &#39;u&#39;,， 以及shift(&#39;z&#39;) = &#39;a&#39;。

对于每个shifts[i] = x， 我们会将 S中的前i+1个字母移位x次。

返回将所有这些移位都应用到 S 后最终得到的字符串。

示例：

输入：S = abc, shifts = [3,5,9]
输出：rpl
解释： 
我们以 abc 开始。
将 S 中的第 1 个字母移位 3 次后，我们得到 dbc。
再将 S 中的前 2 个字母移位 5 次后，我们得到 igc。
最后将 S 中的这 3 个字母移位 9 次后，我们得到答案 rpl。


提示：


	1 <= S.length = shifts.length <= 20000
	0 <= shifts[i] <= 10 ^ 9

给出graph为有 N 个节点（编号为0, 1, 2, ..., N-1）的无向连通图。

graph.length = N，且只有节点 i和 j连通时，j != i在列表graph[i]中恰好出现一次。

返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。






示例 1：

输入：[[1,2,3],[0],[0],[0]]
输出：4
解释：一个可能的路径为 [1,0,2,0,3]

示例 2：

输入：[[1],[0,2,4],[1,3,4],[2],[1,2]]
输出：4
解释：一个可能的路径为 [0,1,4,2,3]




提示：


	1 <= graph.length <= 12
	0 <= graph[i].length <graph.length

访问所有节点的最短路径 - 领扣 (LeetCode)
一手顺子 - 领扣 (LeetCode)
爱丽丝有一手（hand）由整数数组给定的牌。

现在她想把牌重新排列成组，使得每个组的大小都是 W，且由 W 张连续的牌组成。

如果她可以完成分组就返回 true，否则返回 false。






示例 1：

输入：hand = [1,2,3,6,2,3,4,7,8], W = 3
输出：true
解释：爱丽丝的手牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。

示例 2：

输入：hand = [1,2,3,4,5], W = 4
输出：false
解释：爱丽丝的手牌无法被重新排列成几个大小为 4 的组。



提示：


	1 <= hand.length <= 10000
	0 <= hand[i]<= 10^9
	1 <= W <= hand.length

数组中的最长山脉 - 领扣 (LeetCode)
我们把数组 A 中符合下列属性的任意连续子数组 B 称为 &ldquo;山脉&rdquo;：


	B.length &gt;= 3
	存在 0 < i< B.length - 1 使得 B[0] < B[1] < ... B[i-1] < B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]


（注意：B 可以是 A 的任意子数组，包括整个数组 A。）

给出一个整数数组 A，返回最长 &ldquo;山脉&rdquo;的长度。

如果不含有 &ldquo;山脉&rdquo;则返回 0。



示例 1：

输入：[2,1,4,7,3,2,5]
输出：5
解释：最长的 &ldquo;山脉&rdquo; 是 [1,4,7,3,2]，长度为 5。


示例 2：

输入：[2,2,2]
输出：0
解释：不含 &ldquo;山脉&rdquo;。




提示：


	0 <= A.length <= 10000
	0 <= A[i] <= 10000

给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。



示例 1：

输入：S = ab#c, T = ad#c
输出：true
解释：S 和 T 都会变成 &ldquo;ac&rdquo;。


示例 2：

输入：S = ab##, T = c#d#
输出：true
解释：S 和 T 都会变成 &ldquo;&rdquo;。


示例 3：

输入：S = a##c, T = #a#c
输出：true
解释：S 和 T 都会变成 &ldquo;c&rdquo;。


示例 4：

输入：S = a#c, T = b
输出：false
解释：S 会变成 &ldquo;c&rdquo;，但 T 仍然是 &ldquo;b&rdquo;。



提示：


	1 <= S.length <= 200
	1 <= T.length <= 200
	S 和 T 只含有小写字母以及字符 &#39;#&#39;。



比较含退格的字符串 - 领扣 (LeetCode)
猜猜这个单词 - 领扣 (LeetCode)
这个问题是 LeetCode 平台新增的交互式问题 。

我们给出了一个由一些独特的单词组成的单词列表，每个单词都是 6 个字母长，并且这个列表中的一个单词将被选作秘密。

你可以调用 master.guess(word) 来猜单词。你所猜的单词应当是存在于原列表并且由 6 个小写字母组成的类型字符串。

此函数将会返回一个整型数字，表示你的猜测与秘密单词的准确匹配（值和位置同时匹配）的数目。此外，如果你的猜测不在给定的单词列表中，它将返回 -1。

对于每个测试用例，你有 10 次机会来猜出这个单词。当所有调用都结束时，如果您对 master.guess 的调用不超过 10 次，并且至少有一次猜到秘密，那么您将通过该测试用例。

除了下面示例给出的测试用例外，还会有 5 个额外的测试用例，每个单词列表中将会有 100 个单词。这些测试用例中的每个单词的字母都是从 &#39;a&#39; 到 &#39;z&#39;中随机选取的，并且保证给定单词列表中的每个单词都是唯一的。

示例 1:
输入:secret = acckzz, wordlist = [acckzz,ccbazz,eiowzz,abcczz]

解释:

master.guess(aaaaaa) 返回 -1, 因为aaaaaa不在 wordlist 中.
master.guess(acckzz) 返回 6, 因为acckzz 就是秘密，6个字母完全匹配。
master.guess(ccbazz) 返回 3, 因为ccbazz有 3 个匹配项。
master.guess(eiowzz) 返回 2, 因为eiowzz有 2 个匹配项。
master.guess(abcczz) 返回 4, 因为abcczz 有 4 个匹配项。

我们调用了 5 次master.guess，其中一次猜到了秘密，所以我们通过了这个测试用例。


提示：任何试图绕过评判的解决方案都将导致比赛资格被取消。
将数组拆分成斐波那契序列 - 领扣 (LeetCode)
给定一个数字字符串 S，比如 S = 123456579，我们可以将它分成斐波那契式的序列 [123, 456, 579]。

形式上，斐波那契式序列是一个非负整数列表 F，且满足：


	0 <= F[i] <= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；
	F.length &gt;= 3；
	对于所有的0 <= i < F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。


另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。

返回从 S 拆分出来的所有斐波那契式的序列块，如果不能拆分则返回 []。

示例 1：

输入：123456579
输出：[123,456,579]


示例 2：

输入: 11235813
输出: [1,1,2,3,5,8,13]


示例 3：

输入: 112358130
输出: []
解释: 这项任务无法完成。


示例 4：

输入：0123
输出：[]
解释：每个块的数字不能以零开头，因此 01，2，3 不是有效答案。


示例 5：

输入: 1101111
输出: [110, 1, 111]
解释: 输出 [11,0,11,11] 也同样被接受。


提示：


	1 <= S.length<= 200
	字符串 S 中只含有数字。

有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。

在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。

最初，除 0 号房间外的其余所有房间都被锁住。

你可以自由地在房间之间来回走动。

如果能进入每个房间返回 true，否则返回 false。




示例 1：

输入: [[1],[2],[3],[]]
输出: true
解释:  
我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。
然后我们去 2 号房间，拿到钥匙 3。
最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。


示例 2：

输入：[[1,3],[3,0,1],[2],[0]]
输出：false
解释：我们不能进入 2 号房间。


提示：


	1 <= rooms.length <=1000
	0 <= rooms[i].length <= 1000
	所有房间中的钥匙数量总计不超过3000。

钥匙和房间 - 领扣 (LeetCode)
矩阵中的幻方 - 领扣 (LeetCode)
3 x 3 的幻方是一个填充有从 1 到 9 的不同数字的 3 x 3 矩阵，其中每行，每列以及两条对角线上的各数之和都相等。

给定一个由整数组成的 N &times; N 矩阵，其中有多少个 3 &times; 3 的 &ldquo;幻方&rdquo; 子矩阵？（每个子矩阵都是连续的）。



示例 1:

输入: [[4,3,8,4],
      [9,5,1,9],
      [2,7,6,2]]
输出: 1
解释: 
下面的子矩阵是一个 3 x 3 的幻方：
438
951
276

而这一个不是：
384
519
762

总的来说，在本示例所给定的矩阵中只有一个 3 x 3 的幻方子矩阵。


提示:


	1 <= grid.length = grid[0].length<= 10
	0 <= grid[i][j] <= 15

相似字符串组 - 领扣 (LeetCode)
如果我们交换字符串X 中的两个不同位置的字母，使得它和字符串Y 相等，那么称 X 和 Y 两个字符串相似。

例如，tars 和 rats 是相似的 (交换 0 与 2 的位置)；rats 和 arts 也是相似的，但是 star 不与 tars，rats，或 arts 相似。

总之，它们通过相似性形成了两个关联组：{tars, rats, arts} 和 {star}。注意，tars 和 arts 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。

我们给出了一个不包含重复的字符串列表 A。列表中的每个字符串都是 A 中其它所有字符串的一个字母异位词。请问 A 中有多少个相似字符串组？

示例：

输入：[tars,rats,arts,star]
输出：2

提示：


	A.length <= 2000
	A[i].length <= 1000
	A.length * A[i].length <= 20000
	A 中的所有单词都只包含小写字母。
	A 中的所有单词都具有相同的长度，且是彼此的字谜。
	此问题的判断限制时间已经延长。


备注：

 字母异位词[anagram]，一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。
推多米诺 - 领扣 (LeetCode)
一行中有 N 张多米诺骨牌，我们将每张多米诺骨牌垂直竖立。

在开始时，我们同时把一些多米诺骨牌向左或向右推。



每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。

同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。

如果同时有多米诺骨牌落在一张垂直竖立的多米诺骨牌的两边，由于受力平衡， 该骨牌仍然保持不变。

就这个问题而言，我们会认为正在下降的多米诺骨牌不会对其它正在下降或已经下降的多米诺骨牌施加额外的力。

给定表示初始状态的字符串 S 。如果第 i 张多米诺骨牌被推向左边，则 S[i] = &#39;L&#39;；如果第 i 张多米诺骨牌被推向右边，则 S[i] = &#39;R&#39;；如果第 i 张多米诺骨牌没有被推动，则 S[i] = &#39;.&#39;。

返回表示最终状态的字符串。

示例 1：

输入：.L.R...LR..L..
输出：LL.RR.LLRRLL..

示例 2：

输入：RR.L
输出：RR.L
说明：第一张多米诺骨牌没有给第二张施加额外的力。

提示：


	0 <= N <= 10^5
	表示多米诺骨牌状态的字符串只含有 &#39;L&#39;，&#39;R&#39;; 以及 &#39;.&#39;;

爱丽丝参与一个大致基于纸牌游戏 &ldquo;21点&rdquo; 规则的游戏，描述如下：

爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。

当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？

示例 1：

输入：N = 10, K = 1, W = 10
输出：1.00000
说明：爱丽丝得到一张卡，然后停止。

示例 2：

输入：N = 6, K = 1, W = 10
输出：0.60000
说明：爱丽丝得到一张卡，然后停止。
在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。

示例 3：

输入：N = 21, K = 17, W = 10
输出：0.73278

提示：


	0 <= K <= N <= 10000
	1 <= W <= 10000
	如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。
	此问题的判断限制时间已经减少。

新21点 - 领扣 (LeetCode)
矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。

如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形，判断它们是否重叠并返回结果。

示例 1：

输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true


示例 2：

输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false


说明：


	两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。
	矩形中的所有坐标都处于 -10^9 和 10^9 之间。

矩形重叠 - 领扣 (LeetCode)
图像重叠 - 领扣 (LeetCode)
给出两个图像 A 和 B，A 和 B为大小相同的二维正方形矩阵。（并且为二进制矩阵，只包含0和1）。

我们转换其中一个图像，向左，右，上，或下滑动任何数量的单位，并把它放在另一个图像的上面。之后，该转换的重叠是指两个图像都具有 1 的位置的数目。

（请注意，转换不包括向任何方向旋转。）

最大可能的重叠是什么？

示例 1:

输入：A = [[1,1,0],
          [0,1,0],
         [0,1,0]]
    B = [[0,0,0],
         [0,1,1],
         [0,0,1]]
输出：3
解释: 将 A 向右移动一个单位，然后向下移动一个单位。

注意:


	1 <= A.length = A[0].length = B.length = B[0].length <= 30
	0 <=A[i][j], B[i][j] <= 1

树中距离之和 - 领扣 (LeetCode)
给定一个无向、连通的树。树中有 N 个标记为 0...N-1 的节点以及 N-1条边。

第 i 条边连接节点edges[i][0] 和 edges[i][1]。

返回一个表示节点 i 与其他所有节点距离之和的列表 ans。

示例 1:


输入: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
输出: [8,12,6,10,10,10]
解释: 
如下为给定的树的示意图：
  0
 / \
1   2
   /|\
  3 4 5

我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) 
也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。


说明:1 <= N <= 10000
对于某些字符串 S，我们将执行一些替换操作，用新的字母组替换原有的字母组（不一定大小相同）。

每个替换操作具有 3 个参数：起始索引 i，源字 x 和目标字 y。规则是如果 x 从原始字符串 S 中的位置 i 开始，那么我们将用 y 替换出现的 x。如果没有，我们什么都不做。

举个例子，如果我们有 S= &ldquo;abcd&rdquo; 并且我们有一些替换操作 i = 2，x = &ldquo;cd&rdquo;，y = &ldquo;ffff&rdquo;，那么因为 &ldquo;cd&rdquo; 从原始字符串 S 中的位置 2 开始，我们将用&ldquo;ffff&rdquo; 替换它。

再来看 S = &ldquo;abcd&rdquo; 上的另一个例子，如果我们有替换操作 i = 0，x = &ldquo;ab&rdquo;，y = &ldquo;eee&rdquo;，以及另一个替换操作 i = 2，x = &ldquo;ec&rdquo;，y = &ldquo;ffff&rdquo;，那么第二个操作将不执行任何操作，因为原始字符串中S[2] = &#39;c&#39;，与 x[0] = &#39;e&#39; 不匹配。

所有这些操作同时发生。保证在替换时不会有任何重叠：S = abc, indexes = [0, 1],sources = [ab,bc] 不是有效的测试用例。



示例 1：

输入：S = abcd, indexes = [0,2], sources = [a,cd], targets = [eee,ffff]
输出：eeebffff
解释：
a 从 S 中的索引 0 开始，所以它被替换为 eee。
cd 从 S 中的索引 2 开始，所以它被替换为 ffff。


示例 2：

输入：S = abcd, indexes = [0,2], sources = [ab,ec], targets = [eee,ffff]
输出：eeecd
解释：
ab 从 S 中的索引 0 开始，所以它被替换为 eee。
ec 没有从原始的 S 中的索引 2 开始，所以它没有被替换。




提示：


	0 <=indexes.length =sources.length =targets.length <= 100
	0<indexes[i]< S.length <= 1000
	给定输入中的所有字符都是小写字母。



字符串中的查找与替换 - 领扣 (LeetCode)
给定一个二进制矩阵A，我们想先水平翻转图像，然后反转图像并返回结果。

水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转[1, 1, 0]的结果是[0, 1, 1]。

反转图片的意思是图片中的0全部被1替换，1全部被0替换。例如，反转[0, 1, 1]的结果是[1, 0, 0]。

示例 1:


输入: [[1,1,0],[1,0,1],[0,0,0]]
输出: [[1,0,0],[0,1,0],[1,1,1]]
解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]


示例 2:


输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]


说明:


	1 <= A.length = A[0].length <= 20
	0 <= A[i][j]<=1

翻转图像 - 领扣 (LeetCode)
设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为&ldquo;环形缓冲器&rdquo;。
循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。
你的实现应该支持如下操作：


	MyCircularQueue(k): 构造器，设置队列长度为 k 。
	Front: 从队首获取元素。如果队列为空，返回 -1 。
	Rear: 获取队尾元素。如果队列为空，返回 -1 。
	enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
	deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
	isEmpty(): 检查循环队列是否为空。
	isFull(): 检查循环队列是否已满。


示例：


MyCircularQueue circularQueue = new MycircularQueue(3); // 设置长度为3

circularQueue.enQueue(1); // 返回true

circularQueue.enQueue(2); // 返回true

circularQueue.enQueue(3); // 返回true

circularQueue.enQueue(4); // 返回false,队列已满

circularQueue.Rear(); // 返回3

circularQueue.isFull(); // 返回true

circularQueue.deQueue(); // 返回true

circularQueue.enQueue(4); // 返回true

circularQueue.Rear(); // 返回4




提示：


	所有的值都在 1 至 1000 的范围内；
	操作数将在 1 至 1000 的范围内；
	请不要使用内置的队列库。

设计循环队列 - 领扣 (LeetCode)
设计实现双端队列。
你的实现需要支持以下操作：


	MyCircularDeque(k)：构造函数,双端队列的大小为k。
	insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。
	insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。
	deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。
	deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。
	getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。
	getRear()：获得双端队列的最后一个元素。如果双端队列为空，返回 -1。
	isEmpty()：检查双端队列是否为空。
	isFull()：检查双端队列是否满了。


示例：

MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3
circularDeque.insertLast(1);			        // 返回 true
circularDeque.insertLast(2);			        // 返回 true
circularDeque.insertFront(3);			        // 返回 true
circularDeque.insertFront(4);			        // 已经满了，返回 false
circularDeque.getRear();  				// 返回 2
circularDeque.isFull();				        // 返回 true
circularDeque.deleteLast();			        // 返回 true
circularDeque.insertFront(4);			        // 返回 true
circularDeque.getFront();				// 返回 4




提示：


	所有值的范围为 [1, 1000]
	操作次数的范围为 [1, 1000]
	请不要使用内置的双端队列库。

设计循环双端队列 - 领扣 (LeetCode)
隐藏个人信息 - 领扣 (LeetCode)
给你一条个人信息 string S，它可能是一个邮箱地址，也可能是一个电话号码。

我们将隐藏它的隐私信息，通过如下规则:

1. 电子邮箱

定义名称 <name&gt; 的长度大于2，并且只包含小写字母 a-z 和大写字母 A-Z。

电子邮箱地址由名称 <name&gt; 开头，紧接着是符号&#39;@&#39;，后面接着一个名称 <name&gt;，再接着一个点号 &#39;.&#39;，然后是一个名称 <name&gt;。

电子邮箱地址确定为有效的，并且格式是name1@name2.name3。

为了隐藏电子邮箱，所有的名称 <name&gt; 必须被转换成小写的，并且第一个名称 <name&gt; 的第一个字母和最后一个字母的中间的所有字母由 5 个 &#39;*&#39; 代替。

2. 电话号码

电话号码是一串包括数组 0-9，以及 {&#39;+&#39;, &#39;-&#39;, &#39;(&#39;, &#39;)&#39;, &#39;&#39;} 这几个字符的字符串。你可以假设电话号码包含 10 到 13 个数字。

电话号码的最后 10 个数字组成本地号码，在这之前的数字组成国际号码。注意，国际号码是可选的。我们只暴露最后 4 个数字并隐藏所有其他数字。

本地号码是有格式的，并且如 ***-***-1111 这样显示，这里的 1 表示暴露的数字。

为了隐藏有国际号码的电话号码，像 +111 111 111 1111，我们以 +***-***-***-1111 的格式来显示。在本地号码前面的 &#39;+&#39; 号和第一个 &#39;-&#39; 号仅当电话号码中包含国际号码时存在。例如，一个 12 位的电话号码应当以 +**- 开头进行显示。

注意：像 (，)，  这样的不相干的字符以及不符合上述格式的额外的减号或者加号都应当被删除。



最后，将提供的信息正确隐藏后返回。



示例 1：


输入: LeetCode@LeetCode.com
输出: l*****e@leetcode.com
解释： 
所有的名称转换成小写, 第一个名称的第一个字符和最后一个字符中间由 5 个星号代替。
因此，leetcode -&gt; l*****e。


示例 2：


输入: AB@qq.com
输出: a*****b@qq.com
解释:
第一个名称ab的第一个字符和最后一个字符的中间必须有 5 个星号
因此，ab -&gt; a*****b。


示例 3：


输入: 1(234)567-890
输出: ***-***-7890
解释:
10 个数字的电话号码，那意味着所有的数字都是本地号码。


示例 4：


输入: 86-(10)12345678
输出: +**-***-***-5678
解释:
12 位数字，2 个数字是国际号码另外 10 个数字是本地号码 。


注意:


	S.length<=40。
	邮箱的长度至少是 8。
	电话号码的长度至少是 10。

较大分组的位置 - 领扣 (LeetCode)
在一个由小写字母构成的字符串S中，包含由一些连续的相同字符所构成的分组。

例如，在字符串 S = abbxxxxzyy中，就含有 a, bb, xxxx, z 和 yy 这样的一些分组。

我们称所有包含大于或等于三个连续字符的分组为较大分组。找到每一个较大分组的起始和终止位置。

最终结果按照字典顺序输出。

示例1:


输入: abbxxxxzzy
输出: [[3,6]]
解释: xxxx 是一个起始于 3 且终止于 6 的较大分组。


示例 2:


输入: abc
输出: []
解释: a,b 和 c 均不是符合要求的较大分组。


示例 3:


输入: abcdddeeeeaabbbcd
输出: [[3,5],[6,9],[12,14]]

说明:1 <= S.length <= 1000
给定一个正整数 N，试求有多少组连续正整数满足所有数字之和为 N?

示例 1:


输入: 5
输出: 2
解释: 5 = 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。

示例 2:


输入: 9
输出: 3
解释: 9 = 9 = 4 + 5 = 2 + 3 + 4

示例 3:


输入: 15
输出: 4
解释: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5

说明:1 <= N <= 10 ^ 9
连续整数求和 - 领扣 (LeetCode)
如果一个字符在字符串S中有且仅有出现一次，那么我们称其为独特字符。

例如，在字符串S = LETTER中，L和R可以被称为独特字符。

我们再定义UNIQ(S)作为字符串S中独特字符的个数。

那么，在S = LETTER中，UNIQ(LETTER) = 2。

对于给定字符串S，计算其所有非空子串的独特字符的个数，即UNIQ(substring)。

如果出现两个或者多个相同的子串，将其认为是不同的两个子串。

考虑到答案可能会非常大，规定返回格式为：结果 mod10 ^ 9 + 7。

示例 1:


输入: ABC
输出: 10
解释: 所有可能的子串为：A,B,C,AB,BC 和 ABC。
     其中，每一个子串都由独特字符构成。
     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10


示例 2:


输入: ABA
输出: 8
解释: 除了子串 UNIQ(&#39;ABA&#39;) = 1，其余与示例1相同。


说明: 0 <= S.length <= 10000。
独特字符串 - 领扣 (LeetCode)
最大人工岛 - 领扣 (LeetCode)
在二维地图上，0代表海洋，1代表陆地，我们最多只能将一格0 海洋变成1变成陆地。

进行填海之后，地图上最大的岛屿面积是多少？（上、下、左、右四个方向相连的1可形成岛屿）

示例 1:


输入: [[1, 0], [0, 1]]
输出: 3
解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。


示例 2:


输入: [[1, 1], [1, 0]]
输出: 4
解释: 将一格0变成1，岛屿的面积扩大为 4。

示例 3:


输入: [[1, 1], [1, 1]]
输出: 4
解释: 没有0可以让我们变成1，面积依然为 4。

说明:


	1 <= grid.length = grid[0].length <= 50
	0 <= grid[i][j] <= 1

安排工作以达到最大收益 - 领扣 (LeetCode)
有一些工作：difficulty[i]表示第i个工作的难度，profit[i]表示第i个工作的收益。

现在我们有一些工人。worker[i]是第i个工人的能力，即该工人只能完成难度小于等于worker[i]的工作。

每一个工人都最多只能安排一个工作，但是一个工作可以完成多次。

举个例子，如果3个工人都尝试完成一份报酬为1的同样工作，那么总收益为 $3。如果一个工人不能完成任何工作，他的收益为 $0 。

我们能得到的最大收益是多少？

示例：

输入: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
输出: 100 
解释: 工人被分配的工作难度是 [4,4,6,6] ，分别获得 [20,20,30,30] 的收益。

提示:


	1 <= difficulty.length = profit.length <= 10000
	1 <= worker.length <= 10000
	difficulty[i], profit[i], worker[i] 的范围是[1, 10^5]

适龄的朋友 - 领扣 (LeetCode)
人们会互相发送好友请求，现在给定一个包含有他们年龄的数组，ages[i]表示第 i 个人的年龄。

当满足以下条件时，A 不能给 B（A、B不为同一人）发送好友请求：


	age[B]<= 0.5 * age[A]+ 7
	age[B]&gt; age[A]
	age[B]&gt; 100 &amp;&amp;age[A]< 100


否则，A 可以给 B 发送好友请求。

注意如果 A 向 B 发出了请求，不等于 B 接受了 A 的请求。而且，人们不会给自己发送好友请求。

求总共会发出多少份好友请求?

示例 1:


输入: [16,16]
输出: 2
解释: 二人可以互发好友申请。


示例 2:


输入: [16,17,18]
输出: 2
解释: 好友请求可产生于 17 -&gt; 16, 18 -&gt; 17.

示例 3:


输入: [20,30,100,110,120]
输出: 3
解释: 好友请求可产生于 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100.


说明:


	1 <= ages.length<= 20000.
	1 <= ages[i] <= 120.

山羊拉丁文 - 领扣 (LeetCode)
给定一个由空格分割单词的句子S。每个单词只包含大写或小写字母。

我们要将句子转换为&ldquo;Goat Latin&rdquo;（一种类似于 猪拉丁文- Pig Latin 的虚构语言）。

山羊拉丁文的规则如下：


	如果单词以元音开头（a, e, i, o, u），在单词后添加ma。
	例如，单词apple变为applema。
	
	如果单词以辅音字母开头（即非元音字母），移除第一个字符并将它放到末尾，之后再添加ma。
	例如，单词goat变为oatgma。
	
	根据单词在句子中的索引，在单词最后添加与索引相同数量的字母&#39;a&#39;，索引从1开始。
	例如，在第一个单词后添加a，在第二个单词后添加aa，以此类推。


返回将S转换为山羊拉丁文后的句子。

示例 1:


输入: I speak Goat Latin
输出: Imaa peaksmaaa oatGmaaaa atinLmaaaaa


示例 2:


输入: The quick brown fox jumped over the lazy dog
输出: heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa


说明:


	S中仅包含大小写字母和空格。单词间有且仅有一个空格。
	1 <= S.length <= 150。

带因子的二叉树 - 领扣 (LeetCode)
给出一个含有不重复整数元素的数组，每个整数均大于 1。

我们用这些整数来构建二叉树，每个整数可以使用任意次数。

其中：每个非叶结点的值应等于它的两个子结点的值的乘积。

满足条件的二叉树一共有多少个？返回的结果应模除 10 ** 9 + 7。



示例 1:


输入: A = [2, 4]
输出: 3
解释: 我们可以得到这些二叉树: [2], [4], [4, 2, 2]

示例 2:


输入: A = [2, 4, 5, 10]
输出: 7
解释: 我们可以得到这些二叉树: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].



提示:


	1 <= A.length <=1000.
	2 <=A[i]<=10 ^ 9.

在桌子上有 N 张卡片，每张卡片的正面和背面都写着一个正数（正面与背面上的数有可能不一样）。

我们可以先翻转任意张卡片，然后选择其中一张卡片。

如果选中的那张卡片背面的数字 X 与任意一张卡片的正面的数字都不同，那么这个数字是我们想要的数字。

哪个数是这些想要的数字中最小的数（找到这些数中的最小值）呢？如果没有一个数字符合要求的，输出 0。

其中, fronts[i]和backs[i]分别代表第i张卡片的正面和背面的数字。

如果我们通过翻转卡片来交换正面与背面上的数，那么当初在正面的数就变成背面的数，背面的数就变成正面的数。

示例：


输入：fronts = [1,2,4,4,7], backs = [1,3,4,1,3]
输出：2
解释：假设我们翻转第二张卡片，那么在正面的数变成了 [1,3,4,4,7] ， 背面的数变成了 [1,2,4,1,3]。
接着我们选择第二张卡片，因为现在该卡片的背面的数是 2，2 与任意卡片上正面的数都不同，所以 2 就是我们想要的数字。



提示：


	1 <= fronts.length == backs.length<=1000
	1 <=fronts[i]<= 2000
	1 <= backs[i]<= 2000

翻转卡片游戏 - 领扣 (LeetCode)
给定一个字符串S和一个字符C。返回一个代表字符串S中每个字符到字符串S中的字符C的最短距离的数组。

示例 1:


输入: S = loveleetcode, C = &#39;e&#39;
输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]


说明:


	字符串S的长度范围为[1, 10000]。
	C是一个单字符，且保证是字符串S里的字符。
	S和C中的所有字母均为小写字母。

字符的最短距离 - 领扣 (LeetCode)
给定一个单词列表，我们将这个列表编码成一个索引字符串S与一个索引列表 A。

例如，如果这个列表是 [time, me, bell]，我们就可以将其表示为 S = time#bell# 和 indexes = [0, 2, 5]。

对于每一个索引，我们可以通过从字符串 S中索引的位置开始读取字符串，直到 # 结束，来恢复我们之前的单词列表。

那么成功对给定单词列表进行编码的最小字符串长度是多少呢？



示例：

输入: words = [time, me, bell]
输出: 10
说明: S = time#bell# ， indexes = [0, 2, 5] 。




提示：


	1 <= words.length<= 2000
	1 <=words[i].length<= 7
	每个单词都是小写字母 。

单词的压缩编码 - 领扣 (LeetCode)
设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val和next。val是当前节点的值，next是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性prev以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

在链表类中实现这些功能：


	get(index)：获取链表中第index个节点的值。如果索引无效，则返回-1。
	addAtHead(val)：在链表的第一个元素之前添加一个值为val的节点。插入后，新节点将成为链表的第一个节点。
	addAtTail(val)：将值为val 的节点追加到链表的最后一个元素。
	addAtIndex(index,val)：在链表中的第index个节点之前添加值为val 的节点。如果index等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。
	deleteAtIndex(index)：如果索引index 有效，则删除链表中的第index 个节点。




示例：

MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3
linkedList.get(1);            //返回3




提示：


	所有值都在[1, 1000]之内。
	操作次数将在[1, 1000]之内。
	请不要使用内置的 LinkedList 库。

设计链表 - 领扣 (LeetCode)
最常见的单词 - 领扣 (LeetCode)
给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。题目保证至少有一个词不在禁用列表中，而且答案唯一。

禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。



示例：

输入: 
paragraph = Bob hit a ball, the hit BALL flew far after it was hit.
banned = [hit]
输出: ball
解释: 
hit 出现了3次，但它是一个禁用的单词。
ball 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。 
注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 ball,）， 
hit不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。




说明：


	1 <= 段落长度 <= 1000.
	1 <= 禁用单词个数 <= 100.
	1 <= 禁用单词长度 <= 10.
	答案是唯一的, 且都是小写字母(即使在 paragraph 里是大写的，即使是一些特定的名词，答案都是小写的。)
	paragraph只包含字母、空格和下列标点符号!?&#39;,;.
	不存在没有连字符或者带有连字符的单词。
	单词里只包含字母，不会出现省略号或者其他标点符号。

你的赛车起始停留在位置 0，速度为 +1，正行驶在一个无限长的数轴上。（车也可以向负数方向行驶。）

你的车会根据一系列由 A（加速）和 R（倒车）组成的指令进行自动驾驶。

当车得到指令 A 时, 将会做出以下操作：position += speed, speed *= 2。

当车得到指令 R 时, 将会做出以下操作：如果当前速度是正数，则将车速调整为speed = -1；否则将车速调整为speed = 1。 (当前所处位置不变。)

例如，当得到一系列指令 AAR 后, 你的车将会走过位置 0-&gt;1-&gt;3-&gt;3，并且速度变化为1-&gt;2-&gt;4-&gt;-1。

现在给定一个目标位置，请给出能够到达目标位置的最短指令列表的长度。

示例 1:
输入: 
target = 3
输出: 2
解释: 
最短指令列表为 AA
位置变化为 0-&gt;1-&gt;3


示例 2:
输入: 
target = 6
输出: 5
解释: 
最短指令列表为 AAARA
位置变化为 0-&gt;1-&gt;3-&gt;7-&gt;7-&gt;6


说明: 


	1 <= target（目标位置） <= 10000。

赛车 - 领扣 (LeetCode)
链表组件 - 领扣 (LeetCode)
给定一个链表（链表结点包含一个整型值）的头结点head。

同时给定列表G，该列表是上述链表中整型值的一个子集。

返回列表G中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表G中）构成的集合。

示例1：


输入: 
head: 0-&gt;1-&gt;2-&gt;3
G = [0, 1, 3]
输出: 2
解释: 
链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。

示例 2：


输入: 
head: 0-&gt;1-&gt;2-&gt;3-&gt;4
G = [0, 3, 1, 4]
输出: 2
解释: 
链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。

注意:


	如果N是给定链表head的长度，1 <= N <= 10000。
	链表中每个结点的值所在范围为[0, N - 1]。
	1 <= G.length <= 10000
	G 是链表中所有结点的值的一个子集.

模糊坐标 - 领扣 (LeetCode)
我们有一些二维坐标，如(1, 3)或(2, 0.5)，然后我们移除所有逗号，小数点和空格，得到一个字符串S。返回所有可能的原始字符串到一个列表中。

原始的坐标表示法不会存在多余的零，所以不会出现类似于00, 0.0, 0.00, 1.0, 001, 00.01或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现&ldquo;.1&rdquo;形式的数字。

最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。




示例 1:
输入: (123)
输出: [(1, 23), (12, 3), (1.2, 3), (1, 2.3)]



示例 2:
输入: (00011)
输出: [(0.001, 1), (0, 0.011)]
解释: 
0.0, 00, 0001 或 00.01 是不被允许的。



示例 3:
输入: (0123)
输出: [(0, 123), (0, 12.3), (0, 1.23), (0.1, 23), (0.1, 2.3), (0.12, 3)]



示例 4:
输入: (100)
输出: [(10, 0)]
解释: 
1.0 是不被允许的。




提示: 


	4 <= S.length <= 12.
	S[0] = (, S[S.length - 1] = ), 且字符串S中的其他元素都是数字。



我们有一系列公交路线。每一条路线 routes[i]上都有一辆公交车在上面循环行驶。例如，有一条路线routes[0] = [1, 5, 7]，表示第一辆 (下标为0) 公交车会一直按照1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;...的车站路线行驶。

假设我们从S车站开始（初始时不在公交车上），要去往T站。 期间仅可乘坐公交车，求出最少乘坐的公交车数量。返回 -1 表示不可能到达终点车站。


示例:
输入: 
routes = [[1, 2, 7], [3, 6, 7]]
S = 1
T = 6
输出: 2
解释: 
最优策略是先乘坐第一辆公交车到达车站 7, 然后换乘第二辆公交车到车站 6。


说明: 


	1 <= routes.length <= 500.
	1 <= routes[i].length <= 500.
	0 <= routes[i][j] < 10 ^ 6.

公交路线 - 领扣 (LeetCode)
给定二叉树根结点root，此外树的每个结点的值要么是 0，要么是 1。

返回移除了所有不包含 1 的子树的原二叉树。

( 节点 X 的子树为 X 本身，以及所有 X 的后代。)


示例1:
输入: [1,null,0,0,1]
输出: [1,null,0,null,1]
 
解释: 
只有红色节点满足条件&ldquo;所有不包含 1 的子树&rdquo;。
右图为返回的答案。





示例2:
输入: [1,0,1,0,0,0,1]
输出: [1,null,1,null,1]






示例3:
输入: [1,1,0,1,1,0,1,0]
输出: [1,1,0,1,1,null,1]





说明: 


	给定的二叉树最多有100个节点。
	每个节点的值只会为0 或1。

二叉树剪枝 - 领扣 (LeetCode)
我们将给定的数组A分成K个相邻的非空子数组 ，我们的分数由每个子数组内的平均值的总和构成。计算我们所能得到的最大分数是多少。

注意我们必须使用 A 数组中的每一个数进行分组，并且分数不一定需要是整数。


示例:
输入: 
A = [9,1,2,3,9]
K = 3
输出: 20
解释: 
A 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20.
我们也可以把 A 分成[9, 1], [2], [3, 9].
这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.


说明: 


	1 <= A.length <= 100.
	1 <= A[i] <= 10000.
	1 <= K <= A.length.
	答案误差在10^-6内被视为是正确的。

最大平均值和的分组 - 领扣 (LeetCode)
给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。


示例:
输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]
输出: 2
解释: 
这五个点如下图所示。组成的橙色三角形是最大的，面积为2。




注意: 


	3 <= points.length <= 50.
	不存在重复的点。
	-50 <= points[i][j] <= 50.
	结果误差值在10^-6以内都认为是正确答案。

最大三角形面积 - 领扣 (LeetCode)
一个网站域名，如discuss.leetcode.com，包含了多个子域名。作为顶级域名，常用的有com，下一级则有leetcode.com，最低的一级为discuss.leetcode.com。当我们访问域名discuss.leetcode.com时，也同时访问了其父域名leetcode.com以及顶级域名com。

给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如：9001 discuss.leetcode.com。

接下来会给出一组访问次数和域名组合的列表cpdomains。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。


示例 1:
输入: 
[9001 discuss.leetcode.com]
输出: 
[9001 discuss.leetcode.com, 9001 leetcode.com, 9001 com]
说明: 
例子中仅包含一个网站域名：discuss.leetcode.com。按照前文假设，子域名leetcode.com和com都会被访问，所以它们都被访问了9001次。



示例 2
输入: 
[900 google.mail.com, 50 yahoo.com, 1 intel.mail.com, 5 wiki.org]
输出: 
[901 mail.com,50 yahoo.com,900 google.mail.com,5 wiki.org,5 org,1 intel.mail.com,951 com]
说明: 
按照假设，会访问google.mail.com 900次，yahoo.com 50次，intel.mail.com 1次，wiki.org 5次。
而对于父域名，会访问mail.com 900+1 = 901次，com 900 + 50 + 1 = 951次，和 org 5 次。


注意事项：


	cpdomains的长度小于100。
	每个域名的长度小于100。
	每个域名地址包含一个或两个.符号。
	输入中任意一个域名的访问次数都小于10000。

子域名访问计数 - 领扣 (LeetCode)
黑板异或游戏 - 领扣 (LeetCode)
一个黑板上写着一个非负整数数组 nums[i] 。小红和小明轮流从黑板上擦掉一个数字，小红先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。(另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为0。）

换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。

假设两个玩家每步都使用最优解，当且仅当小红获胜时返回 true。


示例:
输入: nums = [1, 1, 2]
输出: false
解释: 
小红有两个选择: 擦掉数字 1 或 2。
如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么小明可以擦掉任意数字，因为小红会成为擦掉最后一个数字的人，她总是会输。
如果小红擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。小红仍然会输掉游戏。


说明: 


	0 <= N <= 1000
	0 <= nums[i] <= 2^16

有时候人们会用额外的字母来表示额外的情感，比如 hello -&gt; heeellooo, hi -&gt; hiii。我们将连续的相同的字母分组，并且相邻组的字母都不相同。我们将一个拥有三个或以上字母的组定义为扩张状态（extended），如第一个例子中的 e 和 o 以及第二个例子中的 i。 此外，abbcccaaaa 将有分组a , bb , ccc , dddd；其中 ccc 和 aaaa 处于扩张状态。

对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。我们允许选择一个字母组（如包含字母c），然后往其中添加相同的字母c使其长度达到 3 或以上。注意，我们不能将一个只包含一个字母的字母组，如 h，扩张到一个包含两个字母的组，如 hh；所有的扩张必须使该字母组变成扩张状态（至少包含三个字母）。

输入一组单词，输出其中可扩张的单词数量。


示例：
输入： 
S = heeellooo
words = [hello, hi, helo]
输出：1
解释：
我们能通过扩张hello的e和o来得到heeellooo。
我们不能通过扩张helo来得到heeellooo因为ll不处于扩张状态。


说明：


	0 <= len(S) <= 100。
	0 <= len(words) <= 100。
	0 <= len(words[i]) <= 100。
	S和所有在words中的单词都只由小写字母组成。

情感丰富的文字 - 领扣 (LeetCode)
有A和B 两种类型的汤。一开始每种类型的汤有N毫升。有四种分配操作：


	提供 100ml 的汤A 和 0ml 的汤B。
	提供 75ml 的汤A 和 25ml 的汤B。
	提供 50ml 的汤A 和 50ml 的汤B。
	提供 25ml 的汤A 和 75ml 的汤B。


当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为0.25的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。

注意不存在先分配100 ml汤B的操作。

需要返回的值：汤A先分配完的概率 + 汤A和汤B同时分配完的概率 / 2。


示例:
输入: N = 50
输出: 0.625
解释:
如果我们选择前两个操作，A将首先变为空。对于第三个操作，A和B会同时变为空。对于第四个操作，B将首先变为空。
所以A变为空的总概率加上A和B同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。


注释: 


	0 <= N <= 10^9。
	
	返回值在10^-6的范围将被认为是正确的。
	

分汤 - 领扣 (LeetCode)
保持城市天际线 - 领扣 (LeetCode)
在二维数组grid中，grid[i][j]代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。

最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的&ldquo;天际线&rdquo;必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。 请看下面的例子。

建筑物高度可以增加的最大总和是多少？


例子：
输入： grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
输出： 35
解释： 
The grid is:
[ [3, 0, 8, 4], 
  [2, 4, 5, 7],
  [9, 2, 6, 3],
  [0, 3, 1, 0] ]

从数组竖直方向（即顶部，底部）看&ldquo;天际线&rdquo;是：[9, 4, 8, 7]
从水平水平方向（即左侧，右侧）看&ldquo;天际线&rdquo;是：[8, 7, 9, 3]

在不影响天际线的情况下对建筑物进行增高后，新数组如下：

gridNew = [ [8, 4, 8, 7],
            [7, 4, 7, 7],
            [9, 4, 8, 7],
            [3, 3, 3, 3] ]


说明: 


	1 < grid.length = grid[0].length <= 50。
	grid[i][j] 的高度范围是： [0, 100]。
	一座建筑物占据一个grid[i][j]：换言之，它们是 1 x 1 x grid[i][j] 的长方体。

写字符串需要的行数 - 领扣 (LeetCode)
我们要把给定的字符串 S从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组widths，这个数组widths[0] 代表 &#39;a&#39; 需要的单位，widths[1] 代表 &#39;b&#39; 需要的单位，...，widths[25] 代表 &#39;z&#39; 需要的单位。

现在回答两个问题：至少多少行能放下S，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。


示例 1:
输入: 
widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = abcdefghijklmnopqrstuvwxyz
输出: [3, 60]
解释: 
所有的字符拥有相同的占用单位10。所以书写所有的26个字母，
我们需要2个整行和占用60个单位的一行。



示例 2:
输入: 
widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = bbbcccdddaaa
输出: [2, 4]
解释: 
除去字母&#39;a&#39;所有的字符都是相同的单位10，并且字符串 bbbcccdddaa 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.
最后一个字母 &#39;a&#39; 将会被写到第二行，因为第一行只剩下2个单位了。
所以，这个答案是2行，第二行有4个单位宽度。




注:


	字符串S 的长度在[1, 1000] 的范围。
	S 只包含小写字母。
	widths 是长度为26的数组。
	widths[i]值的范围在[2, 10]。

给定的整数数组 A ，我们要将 A数组 中的每个元素移动到 B数组 或者 C数组中。（B数组和C数组在开始的时候都为空）

返回true ，当且仅当在我们的完成这样的移动后，可使得B数组的平均值和C数组的平均值相等，并且B数组和C数组都不为空。


示例:
输入: 
[1,2,3,4,5,6,7,8]
输出: true
解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。


注意:


	A 数组的长度范围为 [1, 30].
	A[i] 的数据范围为 [0, 10000].

数组的均值分割 - 领扣 (LeetCode)
国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串，比如: a 对应 .-, b 对应 -..., c 对应 -.-., 等等。

为了方便，所有26个英文字母对应摩尔斯密码表如下：

[.-,-...,-.-.,-..,.,..-.,--.,....,..,.---,-.-,.-..,--,-.,---,.--.,--.-,.-.,...,-,..-,...-,.--,-..-,-.--,--..]

给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，cab 可以写成 -.-..--...，(即 -.-. + -... + .-字符串的结合)。我们将这样一个连接过程称作单词翻译。

返回我们可以获得所有词不同单词翻译的数量。

例如:
输入: words = [gin, zen, gig, msg]
输出: 2
解释: 
各单词翻译如下:
gin -&gt; --...-.
zen -&gt; --...-.
gig -&gt; --...--.
msg -&gt; --...--.

共有 2 种不同翻译, --...-. 和 --...--..




注意:


	单词列表words的长度不会超过 100。
	每个单词words[i]的长度范围为[1, 12]。
	每个单词words[i]只包含小写字母。

唯一摩尔斯密码词 - 领扣 (LeetCode)
我们有一组包含1和0的网格；其中1表示砖块。当且仅当一块砖直接连接到网格的顶部，或者它至少连接着(4个方向)相邻的砖块之一时，它才不会落下。

我们会依次消除一些砖块。每当我们消除(i, j) 位置时， 对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这个消除而落下。

返回一个数组表示每次消除操作对应落下的砖块数目。


示例 1：
输入：
grid = [[1,0,0,0],[1,1,1,0]]
hits = [[1,0]]
输出: [2]
解释: 
如果我们消除(1, 0)位置的砖块, 在(1, 1) 和(1, 2) 的砖块会落下。所以我们应该返回2。


示例 2：
输入：
grid = [[1,0,0,0],[1,1,0,0]]
hits = [[1,1],[1,0]]
输出：[0,0]
解释：
当我们消除(1, 0)的砖块时，(1, 1)的砖块已经由于上一步消除而消失了。所以每次消除操作不会造成砖块落下。注意(1, 0)砖块不会记作落下的砖块。

注意:


	网格的行数和列数的范围是[1, 200]。
	消除的数字不会超过网格的区域。
	可以保证每次的消除都不相同，并且位于网格的内部。
	一个消除的位置可能没有砖块，如果这样的话，就不会有砖块落下。

打砖块 - 领扣 (LeetCode)
在有向图中, 我们从某个节点和每个转向处开始, 沿着图的有向边走。 如果我们到达的节点是终点 (即它没有连出的有向边), 我们停止。

现在, 如果我们最后能走到终点，那么我们的起始节点是最终安全的。 更具体地说, 存在一个自然数 K, 无论选择从哪里开始行走, 我们走了不到 K 步后必能停止在一个终点。

哪些节点最终是安全的？ 结果返回一个有序的数组。

该有向图有 N 个节点，标签为 0, 1, ..., N-1, 其中 N 是graph的节点数. 图以以下的形式给出: graph[i] 是节点 j 的一个列表，满足 (i, j) 是图的一条有向边。


示例：
输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]
输出：[2,4,5,6]
这里是上图的示意图。





提示：


	graph 节点数不超过 10000.
	图的边数不会超过 32000.
	每个 graph[i] 被排序为不同的整数列表， 在区间 [0, graph.length - 1]中选取。

找到最终的安全状态 - 领扣 (LeetCode)
我们有两个长度相等且不为空的整型数组A和B。

我们可以交换A[i]和B[i]的元素。注意这两个元素在各自的序列中应该处于相同的位置。

在交换过一些元素之后，数组A和B都应该是严格递增的（数组严格递增的条件仅为A[0] < A[1] < A[2] < ... < A[A.length - 1]）。

给定数组A和B，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。


示例:
输入: A = [1,3,5,4], B = [1,2,3,7]
输出: 1
解释: 
交换 A[3] 和 B[3] 后，两个数组如下:
A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]
两个数组均为严格递增的。

注意:


	A, B两个数组的长度总是相等的，且长度的范围为[1, 1000]。
	A[i], B[i]均为[0, 2000]区间内的整数。

使序列递增的最小交换次数 - 领扣 (LeetCode)
不使用任何内建的哈希表库设计一个哈希映射

具体地说，你的设计应该包含以下的功能


	put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。
	get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。
	remove(key)：如果映射中存在这个键，删除这个数值对。



示例：


MyHashMap hashMap = new MyHashMap();
hashMap.put(1, 1);     
hashMap.put(2, 2);     
hashMap.get(1);      // 返回 1
hashMap.get(3);      // 返回 -1 (未找到)
hashMap.put(2, 1);     // 更新已有的值
hashMap.get(2);      // 返回 1 
hashMap.remove(2);     // 删除键为2的数据
hashMap.get(2);      // 返回 -1 (未找到) 



注意：


	所有的值都在[1, 1000000]的范围内。
	操作的总数目在[1, 10000]范围内。
	不要使用内建的哈希库。

设计哈希映射 - 领扣 (LeetCode)
不使用任何内建的哈希表库设计一个哈希集合

具体地说，你的设计应该包含以下的功能


	add(value)：向哈希集合中插入一个值。
	contains(value) ：返回哈希集合中是否存在这个值。
	remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。



示例:

MyHashSet hashSet = new MyHashSet();
hashSet.add(1);     
hashSet.add(2);     
hashSet.contains(1); // 返回 true
hashSet.contains(3); // 返回 false (未找到)
hashSet.add(2);     
hashSet.contains(2); // 返回 true
hashSet.remove(2);     
hashSet.contains(2); // 返回  false (已经被删除)



注意：


	所有的值都在[1, 1000000]的范围内。
	操作的总数目在[1, 10000]范围内。
	不要使用内建的哈希集合库。

设计哈希集合 - 领扣 (LeetCode)
我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。

从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）

例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。



现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（i 和 j都从0开始）。




示例 1:
输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.0
解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。

示例 2:
输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.5
解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。


注意:


	poured的范围[0, 10 ^ 9]。
	query_glass和query_row的范围[0, 99]。

香槟塔 - 领扣 (LeetCode)
得分最高的最小轮调 - 领扣 (LeetCode)
给定一个数组A，我们可以将它按一个非负整数 K进行轮调，这样可以使数组变为A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1]的形式。此后，任何值小于或等于其索引的项都可以记作一分。

例如，如果数组为[2, 4, 1, 3, 0]，我们按K = 2进行轮调后，它将变成[1, 3, 0, 2, 4]。这将记作 3 分，因为 1 &gt; 0 [no points], 3 &gt; 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point]。

在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调索引 K。如果有多个答案，返回满足条件的最小的索引 K。

示例 1：
输入：[2, 3, 1, 4, 0]
输出：3
解释：
下面列出了每个 K 的得分：
K = 0,  A = [2,3,1,4,0],    score 2
K = 1,  A = [3,1,4,0,2],    score 3
K = 2,  A = [1,4,0,2,3],    score 3
K = 3,  A = [4,0,2,3,1],    score 4
K = 4,  A = [0,2,3,1,4],    score 3
所以我们应当选择K = 3，得分最高。



示例 2：
输入：[1, 3, 0, 2, 4]
输出：0
解释：
A 无论怎么变化总是有 3 分。
所以我们将选择最小的 K，即 0。


提示：


	A的长度最大为20000。
	A[i] 的取值范围是[0, A.length]。

所有可能的路径 - 领扣 (LeetCode)
给一个有n个结点的有向无环图，找到所有从0到n-1的路径并输出（不要求按顺序）

二维数组的第 i 个数组中的单元都表示有向图中 i 号结点所能到达的下一些结点（译者注：有向图是有方向的，即规定了a&rarr;b你就不能从b&rarr;a）空就是没有下一个结点了。

示例:
输入: [[1,2], [3], [3], []] 
输出: [[0,1,3],[0,2,3]] 
解释: 图是这样的:
0---&gt;1
|    |
v    v
2---&gt;3
这有两条路: 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3.


提示:


	结点的数字会在范围[2, 15]内。
	你可以把路径以任意顺序输出，但在路径内的结点的顺序必须保证。

旋转字符串 - 领扣 (LeetCode)
给定两个字符串, A和B。

A的旋转操作就是将A 最左边的字符移动到最右边。例如, 若A = &#39;abcde&#39;，在移动一次之后结果就是&#39;bcdea&#39;。如果在若干次旋转操作之后，A能变成B，那么返回True。


示例 1:
输入: A = &#39;abcde&#39;, B = &#39;cdeab&#39;
输出: true

示例 2:
输入: A = &#39;abcde&#39;, B = &#39;abced&#39;
输出: false

注意：


	A 和B长度不超过100。

给定一个元素都是正整数的数组A，正整数 L以及R(L <= R)。

求连续、非空且其中最大元素满足大于等于L小于等于R的子数组个数。

例如 :
输入: 
A = [2, 1, 4, 3]
L = 2
R = 3
输出: 3
解释: 满足条件的子数组: [2], [2, 1], [3].


注意:


	L, R 和A[i] 都是整数，范围在[0, 10^9]。
	数组A的长度范围在[1, 50000]。

区间子数组个数 - 领扣 (LeetCode)
用字符串数组作为井字游戏的游戏板board。当且仅当在井字游戏过程中，玩家有可能将字符放置成游戏板所显示的状态时，才返回 true。

该游戏板是一个 3 x 3 数组，由字符 ，X和O组成。字符 代表一个空位。

以下是井字游戏的规则：


	玩家轮流将字符放入空位（ ）中。
	第一个玩家总是放字符 &ldquo;X&rdquo;，且第二个玩家总是放字符 &ldquo;O&rdquo;。
	&ldquo;X&rdquo; 和 &ldquo;O&rdquo; 只允许放置在空位中，不允许对已放有字符的位置进行填充。
	当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。
	当所有位置非空时，也算为游戏结束。
	如果游戏结束，玩家不允许再放置字符。



示例 1:
输入: board = [O ,  ,  ]
输出: false
解释: 第一个玩家总是放置&ldquo;X&rdquo;。

示例 2:
输入: board = [XOX,  X ,    ]
输出: false
解释: 玩家应该是轮流放置的。

示例 3:
输入: board = [XXX,    , OOO]
输出: false

示例 4:
输入: board = [XOX, O O, XOX]
输出: true


说明:


	游戏板board是长度为 3 的字符串数组，其中每个字符串board[i]的长度为3。
	board[i][j]是集合{ , X, O}中的一个字符。

有效的井字游戏 - 领扣 (LeetCode)
阶乘函数后K个零 - 领扣 (LeetCode)
f(x)是x!末尾是0的数量。（回想一下x! = 1 * 2 * 3 * ... * x，且0! = 1）

例如，f(3) = 0，因为3! = 6的末尾没有0；而f(11) = 2，因为11!= 39916800末端有2个0。给定K，找出多少个非负整数x，有f(x) = K的性质。


示例 1:
输入:K = 0
输出:5
解释:0!, 1!, 2!, 3!, and 4!均符合 K = 0 的条件。

示例 2:
输入:K = 5
输出:0
解释:没有匹配到这样的 x!，符合K = 5 的条件。


注意：


	
	K是范围在[0, 10^9]的整数。
	

给定字符串 S 和单词字典 words, 求words[i]中是S的子序列的单词个数。


示例:
输入: 
S = abcde
words = [a, bb, acd, ace]
输出: 3
解释: 有三个是S 的子序列的单词: a, acd, ace。


注意:


	所有在words和S里的单词都只由小写字母组成。
	S 的长度在[1, 50000]。
	words的长度在[1, 5000]。
	words[i]的长度在[1, 50]。

匹配子序列的单词数 - 领扣 (LeetCode)
自定义字符串排序 - 领扣 (LeetCode)
字符串S和 T 只包含小写字符。在S中，所有字符只会出现一次。

S 已经根据某种规则进行了排序。我们要根据S中的字符顺序对T进行排序。更具体地说，如果S中x在y之前出现，那么返回的字符串中x也应出现在y之前。

返回任意一种符合条件的字符串T。


示例:
输入:
S = cba
T = abcd
输出: cbad
解释: 
S中出现了字符 a, b, c, 所以 a, b, c 的顺序应该是 c, b, a. 
由于 d 没有在S中出现, 它可以放在T的任意位置. dcba, cdba, cbda 都是合法的输出。


注意:


	S的最大长度为26，其中没有重复的字符。
	T的最大长度为200。
	S和T只包含小写字符。

多米诺和托米诺平铺 - 领扣 (LeetCode)
有两种形状的瓷砖：一种是2x1 的多米诺形，另一种是形如L 的托米诺形。两种形状都可以旋转。


XX  <- 多米诺

XX  <- L 托米诺
X


给定N 的值，有多少种方法可以平铺2 x N 的面板？返回值 mod 10^9 + 7。

（平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。）


示例:
输入: 3
输出: 5
解释: 
下面列出了五种不同的方法，不同字母代表不同瓷砖：
XYZ XXZ XYY XXY XYY
XYZ YYZ XZZ XYY XXY

提示：


	N 的范围是[1, 1000]



逃脱阻碍者 - 领扣 (LeetCode)
你在进行一个简化版的吃豆人游戏。你从(0, 0)点开始出发，你的目的地是(target[0], target[1])。地图上有一些阻碍者，第 i 个阻碍者从(ghosts[i][0], ghosts[i][1])出发。

每一回合，你和阻碍者们*可以*同时向东，西，南，北四个方向移动，每次可以移动到距离原位置1个单位的新位置。

如果你可以在任何阻碍者抓住你之前到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者同时到达了一个位置（包括目的地）都不算是逃脱成功。

当且仅当你有可能成功逃脱时，输出 True。

示例 1:
输入： 
ghosts = [[1, 0], [0, 3]]
target = [0, 1]
输出：true
解释：
你可以直接一步到达目的地(0,1)，在(1, 0)或者(0, 3)位置的阻碍者都不可能抓住你。 


示例 2:
输入： 
ghosts = [[1, 0]]
target = [2, 0]
输出：false
解释：
你需要走到位于(2, 0)的目的地，但是在(1, 0)的阻碍者位于你和目的地之间。 


示例 3:
输入： 
ghosts = [[2, 0]]
target = [1, 0]
输出：false
解释：
阻碍者可以和你同时达到目的地。 


说明：


	所有的点的坐标值的绝对值 <=10000。
	阻碍者的数量不会超过100。

旋转数字 - 领扣 (LeetCode)
我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。

如果一个数的每位数字被旋转以后仍然还是一个数字，则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。

现在我们有一个正整数N, 计算从1 到N 中有多少个数X 是好数？


示例:
输入: 10
输出: 4
解释: 
在[1, 10]中有四个好数： 2, 5, 6, 9。
注意 1 和 10 不是好数, 因为他们在旋转之后不变。


注意:


	N的取值范围是[1, 10000]。

K 站中转内最便宜的航班 - 领扣 (LeetCode)
有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。

现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。

示例 1:
输入: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
输出: 200
解释: 
城市航班图如下


从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。

示例 2:
输入: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 0
输出: 500
解释: 
城市航班图如下


从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。

提示：


	n 范围是 [1, 100]，城市标签从 0 到 n - 1.
	航班数量范围是 [0, n * (n - 1) / 2].
	每个航班的格式 (src, dst, price).
	每个航班的价格范围是 [1, 10000].
	k 范围是 [0, n - 1].
	航班没有重复，且不存在环路

一个已排序好的表A，其包含 1 和其他一些素数. 当列表中的每一个 p<q 时，我们可以构造一个分数 p/q 。

那么第k个最小的分数是多少呢? 以整数数组的形式返回你的答案, 这里answer[0] = p且answer[1] = q.


示例:
输入: A = [1, 2, 3, 5], K = 3
输出: [2, 5]
解释:
已构造好的分数,排序后如下所示:
1/5, 1/3, 2/5, 1/2, 3/5, 2/3.
很明显第三个最小的分数是 2/5.

输入: A = [1, 7], K = 1
输出: [1, 7]


注意:


	A 的取值范围在 2 &mdash; 2000.
	每个A[i] 的值在 1 &mdash;30000.
	K 取值范围为 1 &mdash;A.length * (A.length - 1) / 2

第 K 个最小的素数分数 - 领扣 (LeetCode)
给定一个无向图graph，当这个图为二分图时返回true。

如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。

graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边：graph[i]中不存在i，并且graph[i]中没有重复的值。



示例 1:
输入: [[1,3], [0,2], [1,3], [0,2]]
输出: true
解释: 
无向图如下:
0----1
|    |
|    |
3----2
我们可以将节点分成两组: {0, 2} 和 {1, 3}。




示例 2:
输入: [[1,2,3], [0,2], [0,1,3], [0,2]]
输出: false
解释: 
无向图如下:
0----1
| \  |
|  \ |
3----2
我们不能将节点分割成两个独立的子集。


注意:


	graph 的长度范围为 [1, 100]。
	graph[i] 中的元素的范围为 [0, graph.length - 1]。
	graph[i] 不会包含 i 或者有重复的值。
	图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。

判断二分图 - 领扣 (LeetCode)
字母大小写全排列 - 领扣 (LeetCode)
给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。


示例:
输入: S = a1b2
输出: [a1b2, a1B2, A1b2, A1B2]

输入: S = 3z4
输出: [3z4, 3Z4]

输入: S = 12345
输出: [12345]


注意：


	S的长度不超过12。
	S仅由数字和字母组成。

给定一个二叉搜索树的根结点root, 返回树中任意两节点的差的最小值。

示例：


输入: root = [4,2,6,1,3,null,null]
输出: 1
解释:
注意，root是树结点对象(TreeNode object)，而不是数组。

给定的树 [4,2,6,1,3,null,null] 可表示为下图:

          4
        /   \
      2      6
     / \    
    1   3  

最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值。

注意：


	二叉树的大小范围在 2 到100。
	二叉树总是有效的，每个节点的值都是整数，且不重复。

二叉搜索树结点最小距离 - 领扣 (LeetCode)
一个 Nx N的 board仅由0和1组成。每次移动，你能任意交换两列或是两行的位置。

输出将这个矩阵变为 &ldquo;棋盘&rdquo; 所需的最小移动次数。&ldquo;棋盘&rdquo; 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。如果不存在可行的变换，输出 -1。

示例:
输入: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]
输出: 2
解释:
一种可行的变换方式如下，从左到右：

0110     1010     1010
0110 --&gt; 1010 --&gt; 0101
1001     0101     1010
1001     0101     0101

第一次移动交换了第一列和第二列。
第二次移动交换了第二行和第三行。


输入: board = [[0, 1], [1, 0]]
输出: 0
解释:
注意左上角的格值为0时也是合法的棋盘，如：

01
10

也是合法的棋盘.

输入: board = [[1, 0], [1, 0]]
输出: -1
解释:
任意的变换都不能使这个输入变为合法的棋盘。




提示：


	board是方阵，且行列数的范围是[2, 30]。
	board[i][j]将只包含0或1。

变为棋盘 - 领扣 (LeetCode)
森林中的兔子 - 领扣 (LeetCode)
森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在answers数组里。

返回森林中兔子的最少数量。


示例:
输入: answers = [1, 1, 2]
输出: 5
解释:
两只回答了 1 的兔子可能有相同的颜色，设为红色。
之后回答了 2 的兔子不会是红色，否则他们的回答会相互矛盾。
设回答了 2 的兔子为蓝色。
此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。
因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。

输入: answers = [10, 10, 10]
输出: 11

输入: answers = []
输出: 0


说明:


	answers的长度最大为1000。
	answers[i]是在[0, 999]范围内的整数。

到达终点 - 领扣 (LeetCode)
从点(x, y)可以转换到(x, x+y) 或者(x+y, y)。

给定一个起点(sx, sy)和一个终点(tx, ty)，如果通过一系列的转换可以从起点到达终点，则返回 True，否则返回False。


示例:
输入: sx = 1, sy = 1, tx = 3, ty = 5
输出: True
解释:
可以通过以下一系列转换从起点转换到终点：
(1, 1) -&gt; (1, 2)
(1, 2) -&gt; (3, 2)
(3, 2) -&gt; (3, 5)

输入: sx = 1, sy = 1, tx = 2, ty = 2
输出: False

输入: sx = 1, sy = 1, tx = 1, ty = 1
输出: True



注意:


	sx, sy, tx, ty是范围在[1, 10^9]的整数。

在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。

给定行数N和序数 K，返回第 N 行中第 K个字符。（K从1开始）


例子:

输入: N = 1, K = 1
输出: 0

输入: N = 2, K = 1
输出: 0

输入: N = 2, K = 2
输出: 1

输入: N = 4, K = 5
输出: 1

解释:
第一行: 0
第二行: 01
第三行: 0110
第四行: 01101001



注意：


	N的范围[1, 30].
	K的范围[1, 2^(N-1)].

第K个语法符号 - 领扣 (LeetCode)
在一个 N x N 的坐标方格grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。

现在开始下雨了。当时间为t时，此时雨水导致水池中任意位置的水位为t。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。

你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台(N-1, N-1)？

示例 1:


输入: [[0,2],[1,3]]
输出: 3
解释:
时间为0时，你位于坐标方格的位置为 (0, 0)。
此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。

等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置


示例2:


输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
输入: 16
解释:
 0  1  2  3  4
24 23 22 21  5
12 13 14 15 16
11 17 18 19 20
10  9  8  7  6

最终的路线用加粗进行了标记。
我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的


提示:


	2 <= N <= 50.
	grid[i][j] 位于区间 [0, ..., N*N - 1] 内。

水位上升的泳池中游泳 - 领扣 (LeetCode)
在LR字符串中交换相邻字符 - 领扣 (LeetCode)
在一个由 &#39;L&#39; , &#39;R&#39; 和 &#39;X&#39; 三个字符组成的字符串（例如RXXLRXRXL）中进行移动操作。一次移动操作指用一个LX替换一个XL，或者用一个XR替换一个RX。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。

示例 :


输入: start = RXXLRXRXL, end = XRLXXRRLX
输出: True
解释:
我们可以通过以下几步将start转换成end:
RXXLRXRXL -&gt;
XRXLRXRXL -&gt;
XRLXRXRXL -&gt;
XRLXXRRXL -&gt;
XRLXXRRLX


注意:


	1 <= len(start) = len(end) <= 10000。
	start和end中的字符串仅限于&#39;L&#39;, &#39;R&#39;和&#39;X&#39;。

二分查找 - 领扣 (LeetCode)
给定一个n个元素有序的（升序）整型数组nums 和一个目标值target ，写一个函数搜索nums中的 target，如果目标值存在返回下标，否则返回 -1。


示例 1:

输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4


示例2:

输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1




提示：


	你可以假设 nums中的所有元素是不重复的。
	n将在[1, 10000]之间。
	nums的每个元素都将在[-9999, 9999]之间。

数组A是[0, 1, ..., N - 1]的一种排列，N 是数组A的长度。全局倒置指的是 i,j满足0 <= i < j < N 并且A[i] &gt; A[j]，局部倒置指的是 i 满足0 <= i < N并且A[i] &gt; A[i+1]。

当数组A中全局倒置的数量等于局部倒置的数量时，返回 true 。



示例 1:


输入: A = [1,0,2]
输出: true
解释: 有 1 个全局倒置，和 1 个局部倒置。


示例 2:


输入: A = [1,2,0]
输出: false
解释: 有 2 个全局倒置，和 1 个局部倒置。


注意:


	A 是[0, 1, ..., A.length - 1]的一种排列
	A 的长度在[1, 5000]之间
	这个问题的时间限制已经减少了。

全局倒置与局部倒置 - 领扣 (LeetCode)
数据流中的第K大元素 - 领扣 (LeetCode)
设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。

你的KthLargest类需要一个同时接收整数k 和整数数组nums的构造器，它包含数据流中的初始元素。每次调用KthLargest.add，返回当前数据流中第K大的元素。

示例:


int k = 3;
int[] arr = [4,5,8,2];
KthLargest kthLargest = new KthLargest(3, arr);
kthLargest.add(3); // returns 4
kthLargest.add(5); // returns 5
kthLargest.add(10); // returns 5
kthLargest.add(9); // returns 8
kthLargest.add(4); // returns 8


说明: 
你可以假设nums的长度&ge;k-1且k &ge;1。
滑动谜题 - 领扣 (LeetCode)
在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用0来表示.

一次移动定义为选择0与一个相邻的数字（上下左右）进行交换.

最终当板board的结果是[[1,2,3],[4,5,0]]谜板被解开。

给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。

示例：


输入：board = [[1,2,3],[4,0,5]]
输出：1
解释：交换 0 和 5 ，1 步完成



输入：board = [[1,2,3],[5,4,0]]
输出：-1
解释：没有办法完成谜板



输入：board = [[4,1,2],[5,0,3]]
输出：5
解释：
最少完成谜板的最少移动次数是 5 ，
一种移动路径:
尚未移动: [[4,1,2],[5,0,3]]
移动 1 次: [[4,1,2],[0,5,3]]
移动 2 次: [[0,1,2],[4,5,3]]
移动 3 次: [[1,0,2],[4,5,3]]
移动 4 次: [[1,2,0],[4,5,3]]
移动 5 次: [[1,2,3],[4,5,0]]



输入：board = [[3,2,4],[1,5,0]]
输出：14


提示：


	board是一个如上所述的 2 x 3 的数组.
	board[i][j]是一个[0, 1, 2, 3, 4, 5]的排列.

二叉搜索树中的插入操作 - 领扣 (LeetCode)
给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。

例如,


给定二叉搜索树:

        4
       / \
      2   7
     / \
    1   3

和 插入的值: 5


你可以返回这个二叉搜索树:


         4
       /   \
      2     7
     / \   /
    1   3 5


或者这个树也是有效的:


         5
       /   \
      2     7
     / \   
    1   3
         \
          4

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

例如，


给定二叉搜索树:

        4
       / \
      2   7
     / \
    1   3

和值: 2


你应该返回如下子树:


      2     
     / \   
    1   3


在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。
二叉搜索树中的搜索 - 领扣 (LeetCode)
给定字符串J代表石头中宝石的类型，和字符串S代表你拥有的石头。S中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。

J中的字母不重复，J和S中的所有字符都是字母。字母区分大小写，因此a和A是不同类型的石头。

示例 1:

输入: J = aA, S = aAAbbbb
输出: 3


示例 2:

输入: J = z, S = ZZ
输出: 0


注意:


	S和J最多含有50个字母。
	J中的字符不重复。

宝石与石头 - 领扣 (LeetCode)
给定一个表达式expression如expression = e + 8 - a + 5和一个求值映射，如{e: 1}（给定的形式为evalvars = [e] 和evalints = [1]），返回表示简化表达式的标记列表，例如 [-1*a,14]


	表达式交替使用块和符号，每个块和符号之间有一个空格。
	块要么是括号中的表达式，要么是变量，要么是非负整数。
	块是括号中的表达式，变量或非负整数。
	变量是一个由小写字母组成的字符串（不包括数字）。请注意，变量可以是多个字母，并注意变量从不具有像2x或-x这样的前导系数或一元运算符。


表达式按通常顺序进行求值：先是括号，然后求乘法，再计算加法和减法。例如，expression = 1 + 2 * 3的答案是 [7]。

输出格式如下：


	对于系数非零的每个自变量项，我们按字典排序的顺序将自变量写在一个项中。例如，我们永远不会写像 &ldquo;b*a*c&rdquo; 这样的项，只写 &ldquo;a*b*c&rdquo;。
	项的次数等于被乘的自变量的数目，并计算重复项。(例如，a*a*b*c 的次数为 4。)。我们先写出答案的最大次数项，用字典顺序打破关系，此时忽略词的前导系数。
	项的前导系数直接放在左边，用星号将它与变量分隔开(如果存在的话)。前导系数 1 仍然要打印出来。
	格式良好的一个示例答案是[-2*a*a*a, 3*a*a*b, 3*b*b, 4*a, 5*c, -6]。
	系数为 0 的项（包括常数项）不包括在内。例如，&ldquo;0&rdquo; 的表达式输出为 []。




示例：

输入：expression = e + 8 - a + 5, evalvars = [e], evalints = [1]
输出：[-1*a,14]

输入：expression = e - 8 + temperature - pressure,
evalvars = [e, temperature], evalints = [1, 12]
输出：[-1*pressure,5]

输入：expression = (e + 8) * (e - 8), evalvars = [], evalints = []
输出：[1*e*e,-64]

输入：expression = 7 - 7, evalvars = [], evalints = []
输出：[]

输入：expression = a * b * c + b * a * c * 4, evalvars = [], evalints = []
输出：[5*a*b*c]

输入：expression = ((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a)),
evalvars = [], evalints = []
输出：[-1*a*a*b*b,2*a*a*b*c,-1*a*a*c*c,1*a*b*b*b,-1*a*b*b*c,-1*a*b*c*c,1*a*c*c*c,-1*b*b*b*c,2*b*b*c*c,-1*b*c*c*c,2*a*a*b,-2*a*a*c,-2*a*b*b,2*a*c*c,1*b*b*b,-1*b*b*c,1*b*c*c,-1*c*c*c,-1*a*a,1*a*b,1*a*c,-1*b*c]




提示：


	expression 的长度在[1, 250]范围内。
	evalvars, evalints 在范围[0, 100]内，且长度相同。

基本计算器 IV - 领扣 (LeetCode)
数组arr是[0, 1, ..., arr.length - 1]的一种排列，我们将这个数组分割成几个&ldquo;块&rdquo;，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。

我们最多能将数组分成多少块？

示例 1:

输入: arr = [4,3,2,1,0]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。


示例 2:

输入: arr = [1,0,2,3,4]
输出: 4
解释:
我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。


注意:


	arr 的长度在 [1, 10] 之间。
	arr[i]是 [0, 1, ..., arr.length - 1]的一种排列。

最多能完成排序的块 - 领扣 (LeetCode)
最多能完成排序的块 II - 领扣 (LeetCode)
这个问题和&ldquo;最多能完成排序的块&rdquo;相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。

arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个&ldquo;块&rdquo;，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。

我们最多能将数组分成多少块？

示例1:


输入: arr = [5,4,3,2,1]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 


示例 2:


输入: arr = [2,1,3,4,4]
输出: 4
解释:
我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。
然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 


注意:


	arr的长度在[1, 2000]之间。
	arr[i]的大小在[0, 10**8]之间。

给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。

若可行，输出任意可行的结果。若不可行，返回空字符串。

示例1:


输入: S = aab
输出: aba


示例 2:


输入: S = aaab
输出: 


注意:


	S 只包含小写字母并且长度在[1, 500]区间内。

重构字符串 - 领扣 (LeetCode)
托普利茨矩阵 - 领扣 (LeetCode)
如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。

给定一个M x N的矩阵，当且仅当它是托普利茨矩阵时返回True。

示例1:

输入: 
matrix = [
 [1,2,3,4],
 [5,1,2,3],
 [9,5,1,2]
]
输出: True
解释:
在上述矩阵中, 其对角线为:
[9], [5, 5], [1, 1, 1], [2, 2, 2], [3, 3], [4]。
各条对角线上的所有元素均相同, 因此答案是True。


示例 2:

输入:
matrix = [
 [1,2],
 [2,2]
]
输出: False
解释: 
对角线[1, 2]上的元素不同。


说明:


	matrix是一个包含整数的二维数组。
	matrix的行数和列数均在[1, 20]范围内。
	matrix[i][j]包含的整数在[0, 99]范围内。


进阶:


	如果矩阵存储在磁盘上，并且磁盘内存是有限的，因此一次最多只能将一行矩阵加载到内存中，该怎么办？
	如果矩阵太大以至于只能一次将部分行加载到内存中，该怎么办？

给定一个 N 叉树，返回其节点值的后序遍历。



例如，给定一个3叉树:















返回其后序遍历: [5,6,3,2,4,1].







说明:递归法很简单，你可以使用迭代法完成此题吗?N叉树的后序遍历 - 领扣 (LeetCode)
给定一个 N 叉树，返回其节点值的前序遍历。



例如，给定一个3叉树:















返回其前序遍历: [1,3,5,6,2,4]。







说明:递归法很简单，你可以使用迭代法完成此题吗?N叉树的前序遍历 - 领扣 (LeetCode)
给定一个 N 叉树，找到其最大深度。



最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。



例如，给定一个3叉树:















我们应返回其最大深度，3。



说明:





	树的深度不会超过1000。

	树的节点总不会超过5000。

N叉树的最大深度 - 领扣 (LeetCode)
四叉树是一种树数据，其中每个结点恰好有四个子结点：topLeft、topRight、bottomLeft和bottomRight。四叉树通常被用来划分一个二维空间，递归地将其细分为四个象限或区域。

我们希望在四叉树中存储 True/False 信息。四叉树用来表示 N * N 的布尔网格。对于每个结点, 它将被等分成四个孩子结点直到这个区域内的值都是相同的。每个节点都有另外两个布尔属性：isLeaf和isLeaf。当这个节点是一个叶子结点时isLeaf为真。val变量储存叶子结点所代表的区域的值。

例如，下面是两个四叉树 A 和 B：

A:
+-------+-------+   T: true
|       |       |   F: false
|   T   |   T   |
|       |       |
+-------+-------+
|       |       |
|   F   |   F   |
|       |       |
+-------+-------+
topLeft: T
topRight: T
bottomLeft: F
bottomRight: F

B:               
+-------+---+---+
|       | F | F |
|   T   +---+---+
|       | T | T |
+-------+---+---+
|       |       |
|   T   |   F   |
|       |       |
+-------+-------+
topLeft: T
topRight:
     topLeft: F
     topRight: F
     bottomLeft: T
     bottomRight: T
bottomLeft: T
bottomRight: F




你的任务是实现一个函数，该函数根据两个四叉树返回表示这两个四叉树的逻辑或(或并)的四叉树。

A:                 B:                 C (A or B):
+-------+-------+  +-------+---+---+  +-------+-------+
|       |       |  |       | F | F |  |       |       |
|   T   |   T   |  |   T   +---+---+  |   T   |   T   |
|       |       |  |       | T | T |  |       |       |
+-------+-------+  +-------+---+---+  +-------+-------+
|       |       |  |       |       |  |       |       |
|   F   |   F   |  |   T   |   F   |  |   T   |   F   |
|       |       |  |       |       |  |       |       |
+-------+-------+  +-------+-------+  +-------+-------+




提示：


	A和B都表示大小为N * N的网格。
	N将确保是 2 的整次幂。
	如果你想了解更多关于四叉树的知识，你可以参考这个wiki页面。
	逻辑或的定义如下：如果A 为 True ，或者B 为 True ，或者A 和 B 都为 True，则 A 或 B 为 True。

四叉树交集 - 领扣 (LeetCode)
建立四叉树 - 领扣 (LeetCode)
我们想要使用一棵四叉树来储存一个N x N 的布尔值网络。网络中每一格的值只会是真或假。树的根结点代表整个网络。对于每个结点, 它将被分等成四个孩子结点直到这个区域内的值都是相同的.

每个结点还有另外两个布尔变量:isLeaf 和val。isLeaf 当这个节点是一个叶子结点时为真。val变量储存叶子结点所代表的区域的值。

你的任务是使用一个四叉树表示给定的网络。下面的例子将有助于你理解这个问题：

给定下面这个8 x 8网络，我们将这样建立一个对应的四叉树：



由上文的定义，它能被这样分割：





对应的四叉树应该像下面这样，每个结点由一对(isLeaf, val)所代表.

对于非叶子结点，val可以是任意的，所以使用*代替。



提示：


	N将小于1000且确保是 2 的整次幂。
	如果你想了解更多关于四叉树的知识，你可以参考这个wiki页面。

情侣牵手 - 领扣 (LeetCode)
N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。

人和座位用0到2N-1的整数表示，情侣们按顺序编号，第一对是(0, 1)，第二对是(2, 3)，以此类推，最后一对是(2N-2, 2N-1)。

这些情侣的初始座位row[i]是由最初始坐在第 i 个座位上的人决定的。

示例 1:


输入: row = [0, 2, 1, 3]
输出: 1
解释: 我们只需要交换row[1]和row[2]的位置即可。


示例 2:


输入: row = [3, 2, 0, 1]
输出: 0
解释: 无需交换座位，所有的情侣都已经可以手牵手了。


说明:


	len(row) 是偶数且数值在[4, 60]范围内。
	可以保证row 是序列0...len(row)-1的一个全排列。

最大加号标志 - 领扣 (LeetCode)
在一个大小在 (0, 0) 到 (N-1, N-1) 的2D网格grid中，除了在mines中给出的单元为0，其他每个单元都是1。网格中包含1的最大的轴对齐加号标志是多少阶？返回加号标志的阶数。如果未找到加号标志，则返回 0。

一个k 阶由1组成的&ldquo;轴对称&rdquo;加号标志具有中心网格grid[x][y] = 1，以及4个从中心向上、向下、向左、向右延伸，长度为k-1，由1组成的臂。下面给出k 阶&ldquo;轴对称&rdquo;加号标志的示例。注意，只有加号标志的所有网格要求为 1，别的网格可能为 0 也可能为 1。



k 阶轴对称加号标志示例:


阶 1:
000
010
000

阶 2:
00000
00100
01110
00100
00000

阶 3:
0000000
0001000
0001000
0111110
0001000
0001000
0000000




示例 1：


输入: N = 5, mines = [[4, 2]]
输出: 2
解释:

11111
11111
11111
11111
11011

在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。




示例 2：


输入: N = 2, mines = []
输出: 1
解释:

11
11

没有 2 阶加号标志，有 1 阶加号标志。




示例 3：


输入: N = 1, mines = [[0, 0]]
输出: 0
解释:

0

没有加号标志，返回 0 。




提示：


	整数N 的范围：[1, 500].
	mines 的最大长度为5000.
	mines[i] 是长度为2的由2个[0, N-1]中的数组成.
	(另外,使用 C, C++, 或者C# 编程将以稍小的时间限制进行​​判断.)



划分字母区间 - 领扣 (LeetCode)
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。

示例 1:

输入: S = ababcbacadefegdehijhklij
输出: [9,7,8]
解释:
划分结果为 ababcbaca, defegde, hijhklij。
每个字母最多出现在一个片段中。
像 ababcbacadefegde, hijhklij 的划分是错误的，因为划分的片段数较少。


注意:


	S的长度在[1, 500]之间。
	S只包含小写字母&#39;a&#39;到&#39;z&#39;。

给定两个整数L和R，找到闭区间[L, R]范围内，计算置位位数为质数的整数个数。

（注意，计算置位代表二进制表示中1的个数。例如21的二进制表示10101有 3 个计算置位。还有，1 不是质数。）

示例 1:


输入: L = 6, R = 10
输出: 4
解释:
6 -&gt; 110 (2 个计算置位，2 是质数)
7 -&gt; 111 (3 个计算置位，3 是质数)
9 -&gt; 1001 (2 个计算置位，2 是质数)
10-&gt; 1010 (2 个计算置位，2 是质数)


示例 2:


输入: L = 10, R = 15
输出: 5
解释:
10 -&gt; 1010 (2 个计算置位, 2 是质数)
11 -&gt; 1011 (3 个计算置位, 3 是质数)
12 -&gt; 1100 (2 个计算置位, 2 是质数)
13 -&gt; 1101 (3 个计算置位, 3 是质数)
14 -&gt; 1110 (3 个计算置位, 3 是质数)
15 -&gt; 1111 (4 个计算置位, 4 不是质数)


注意:


	L, R是L <= R且在[1, 10^6]中的整数。
	R - L的最大值为 10000。

二进制表示中质数个计算置位 - 领扣 (LeetCode)
您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。

扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。



示例:

输入:
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL

输出:
1-2-3-7-8-11-12-9-10-4-5-6-NULL




以上示例的说明:

给出以下多级双向链表:





我们应该返回如下所示的扁平双向链表:


扁平化多级双向链表 - 领扣 (LeetCode)
给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。



例如，给定一个3叉树:















返回其层序遍历:



[

     [1],

     [3,2,4],

     [5,6]

]









说明:





	树的深度不会超过1000。

	树的节点总数不会超过5000。

N叉树的层序遍历 - 领扣 (LeetCode)
特殊的二进制序列是具有以下两个性质的二进制序列：


	0 的数量与 1 的数量相等。
	二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。


给定一个特殊的二进制序列S，以字符串形式表示。定义一个操作 为首先选择S的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)

在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？

示例 1:


输入: S = 11011000
输出: 11100100
解释:
将子串 10 （在S[1]出现） 和 1100 （在S[3]出现）进行交换。
这是在进行若干次操作后按字典序排列最大的结果。


说明:


	S的长度不超过50。
	S保证为一个满足上述定义的特殊 的二进制序列。

特殊的二进制序列 - 领扣 (LeetCode)
 设置交集大小至少为2 - 领扣 (LeetCode)
一个整数区间[a, b](a < b) 代表着从a到b的所有连续整数，包括a和b。

给你一组整数区间intervals，请找到一个最小的集合 S，使得 S 里的元素与区间intervals中的每一个整数区间都至少有2个元素相交。

输出这个最小集合S的大小。

示例 1:


输入: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]]
输出: 3
解释:
考虑集合 S = {2, 3, 4}. S与intervals中的四个区间都有至少2个相交的元素。
且这是S最小的情况，故我们输出3。


示例 2:


输入: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]]
输出: 5
解释:
最小的集合S = {1, 2, 3, 4, 5}.


注意:


	intervals的长度范围为[1, 3000]。
	intervals[i]长度为2，分别代表左、右边界。
	intervals[i][j] 的值是[0, 10^8]范围内的整数。

金字塔转换矩阵 - 领扣 (LeetCode)
现在，我们用一些方块来堆砌一个金字塔。 每个方块用仅包含一个字母的字符串表示，例如 &ldquo;Z&rdquo;。

使用三元组表示金字塔的堆砌规则如下：

(A, B, C) 表示，&ldquo;C&rdquo;为顶层方块，方块&ldquo;A&rdquo;、&ldquo;B&rdquo;分别作为方块&ldquo;C&rdquo;下一层的的左、右子块。当且仅当(A, B, C)是被允许的三元组，我们才可以将其堆砌上。

初始时，给定金字塔的基层bottom，用一个字符串表示。一个允许的三元组列表allowed，每个三元组用一个长度为 3 的字符串表示。

如果可以由基层一直堆到塔尖返回true，否则返回false。

示例 1:


输入: bottom = XYZ, allowed = [XYD, YZE, DEA, FFF]
输出: true
解析:
可以堆砌成这样的金字塔:
    A
   / \
  D   E
 / \ / \
X   Y   Z

因为符合(&#39;X&#39;, &#39;Y&#39;, &#39;D&#39;), (&#39;Y&#39;, &#39;Z&#39;, &#39;E&#39;) 和 (&#39;D&#39;, &#39;E&#39;, &#39;A&#39;) 三种规则。


示例 2:


输入: bottom = XXYX, allowed = [XXX, XXY, XYX, XYY, YXZ]
输出: false
解析:
无法一直堆到塔尖。
注意, 允许存在三元组(A, B, C)和 (A, B, D) ，其中 C != D.


注意：


	bottom 的长度范围在[2, 8]。
	allowed 的长度范围在[0, 200]。
	方块的标记字母范围为{&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;}。

到达终点数字 - 领扣 (LeetCode)
在一根无限长的数轴上，你站在0的位置。终点在target的位置。

每次你可以选择向左或向右移动。第 n 次移动（从 1 开始），可以走 n 步。

返回到达终点需要的最小移动次数。

示例 1:


输入: target = 3
输出: 2
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 3 。


示例 2:


输入: target = 2
输出: 3
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 -1 。
第三次移动，从 -1 到 2 。


注意:


	target是在[-10^9, 10^9]范围中的非零整数。

有一个需要密码才能打开的保险箱。密码是n 位数, 密码的每一位是k位序列0, 1, ..., k-1中的一个 。

你可以随意输入密码，保险箱会自动记住最后n位输入，如果匹配，则能够打开保险箱。

举个例子，假设密码是345，你可以输入012345来打开它，只是你输入了 6个字符.

请返回一个能打开保险箱的最短字符串。



示例1:

输入: n = 1, k = 2
输出: 01
说明: 10也可以打开保险箱。




示例2:

输入: n = 2, k = 2
输出: 00110
说明: 01100, 10011, 11001 也能打开保险箱。




提示：


	n 的范围是[1, 4]。
	k 的范围是[1, 10]。
	k^n 最大可能为4096。



破解保险箱 - 领扣 (LeetCode)
你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39; 。每个拨轮可以自由旋转：例如把 &#39;9&#39; 变为 &#39;0&#39;，&#39;0&#39; 变为 &#39;9&#39; 。每次旋转都只能旋转一个拨轮的一位数字。

锁的初始数字为 &#39;0000&#39; ，一个代表四个拨轮的数字的字符串。

列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。

字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。



示例 1:


输入：deadends = [0201,0101,0102,1212,2002], target = 0202
输出：6
解释：
可能的移动序列为 0000 -&gt; 1000 -&gt; 1100 -&gt; 1200 -&gt; 1201 -&gt; 1202 -&gt; 0202。
注意 0000 -&gt; 0001 -&gt; 0002 -&gt; 0102 -&gt; 0202 这样的序列是不能解锁的，
因为当拨动到 0102 时这个锁就会被锁定。


示例 2:


输入: deadends = [8888], target = 0009
输出：1
解释：
把最后一位反向旋转一次即可 0000 -&gt; 0009。


示例 3:


输入: deadends = [8887,8889,8878,8898,8788,8988,7888,9888], target = 8888
输出：-1
解释：
无法旋转到目标数字且不被锁定。


示例 4:


输入: deadends = [0000], target = 8888
输出：-1




提示：


	死亡列表 deadends 的长度范围为 [1, 500]。
	目标数字 target 不会在 deadends 之中。
	每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 &#39;0000&#39; 到 &#39;9999&#39; 中产生。

打开转盘锁 - 领扣 (LeetCode)
隔离病毒 - 领扣 (LeetCode)
病毒扩散得很快，现在你的任务是尽可能地通过安装防火墙来隔离病毒。

假设世界由二维矩阵组成，0 表示该区域未感染病毒，而 1 表示该区域已感染病毒。可以在任意 2 个四方向相邻单元之间的共享边界上安装一个防火墙（并且只有一个防火墙）。

每天晚上，病毒会从被感染区域向相邻未感染区域扩散，除非被防火墙隔离。现由于资源有限，每天你只能安装一系列防火墙来隔离其中一个被病毒感染的区域（一个区域或连续的一片区域），且该感染区域对未感染区域的威胁最大且保证唯一。

你需要努力使得最后有部分区域不被病毒感染，如果可以成功，那么返回需要使用的防火墙个数; 如果无法实现，则返回在世界被病毒全部感染时已安装的防火墙个数。



示例 1：

输入: grid = 
[[0,1,0,0,0,0,0,1],
 [0,1,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,0]]
输出: 10
说明:
一共有两块被病毒感染的区域: 从左往右第一块需要 5 个防火墙，同时若该区域不隔离，晚上将感染 5 个未感染区域（即被威胁的未感染区域个数为 5）;
第二块需要 4 个防火墙，同理被威胁的未感染区域个数是 4。因此，第一天先隔离左边的感染区域，经过一晚后，病毒传播后世界如下:
[[0,1,0,0,0,0,1,1],
 [0,1,0,0,0,0,1,1],
 [0,0,0,0,0,0,1,1],
 [0,0,0,0,0,0,0,1]]
第二题，只剩下一块未隔离的被感染的连续区域，此时需要安装 5 个防火墙，且安装完毕后病毒隔离任务完成。


示例 2：

输入: grid = 
[[1,1,1],
 [1,0,1],
 [1,1,1]]
输出: 4
说明: 
此时只需要安装 4 面防火墙，就有一小区域可以幸存，不被病毒感染。
注意不需要在世界边界建立防火墙。



示例3:

输入: grid = 
[[1,1,1,0,0,0,0,0,0],
 [1,0,1,0,1,1,1,1,1],
 [1,1,1,0,0,0,0,0,0]]
输出: 13
说明: 
在隔离右边感染区域后，隔离左边病毒区域只需要 2 个防火墙了。




说明:


	1&le;i&le;50，1&le;j&le;50.
	grid[i][j]只包含0或1。
	题目保证每次选取感染区域进行隔离时，一定存在唯一一个对未感染区域的威胁最大的区域。



最短完整词 - 领扣 (LeetCode)
如果单词列表（words）中的一个单词包含牌照（licensePlate）中所有的字母，那么我们称之为完整词。在所有完整词中，最短的单词我们称之为最短完整词。

单词在匹配牌照中的字母时不区分大小写，比如牌照中的P依然可以匹配单词中的p字母。

我们保证一定存在一个最短完整词。当有多个单词都符合最短完整词的匹配条件时取单词列表中最靠前的一个。

牌照中可能包含多个相同的字符，比如说：对于牌照 PP，单词pair无法匹配，但是supper可以匹配。



示例 1：


输入：licensePlate = 1s3 PSt, words = [step, steps, stripe, stepple]
输出：steps
说明：最短完整词应该包括 s、p、s 以及 t。对于 step 它只包含一个 s 所以它不符合条件。同时在匹配过程中我们忽略牌照中的大小写。



示例 2：


输入：licensePlate = 1s3 456, words = [looks, pest, stew, show]
输出：pest
说明：有三个单词都符合完整词的定义，但是我们返回最先出现的单词。




注意:


	牌照（licensePlate）的长度在区域[1, 7]中。
	牌照（licensePlate）将会包含数字、空格、或者字母（大写和小写）。
	单词列表（words）长度在区间[10, 1000]中。
	每一个单词words[i]都是小写，并且长度在区间[1, 15]中。



在一个给定的数组nums中，总是存在一个最大元素 。

查找数组中的最大元素是否至少是数组中每个其他数字的两倍。

如果是，则返回最大元素的索引，否则返回-1。

示例 1:


输入: nums = [3, 6, 1, 0]
输出: 1
解释: 6是最大的整数, 对于数组中的其他整数,
6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.




示例 2:


输入: nums = [1, 2, 3, 4]
输出: -1
解释: 4没有超过3的两倍大, 所以我们返回 -1.




提示:


	nums的长度范围在[1, 50].
	每个nums[i]的整数范围在[0, 99].

至少是其他数字两倍的最大数 - 领扣 (LeetCode)
数组的每个索引做为一个阶梯，第i个阶梯对应着一个非负数的体力花费值cost[i](索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

示例1:


输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。


示例 2:


输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。


注意：


	cost的长度将会在[2, 1000]。
	每一个cost[i] 将会是一个Integer类型，范围为[0, 999]。

使用最小花费爬楼梯 - 领扣 (LeetCode)
给定多个words，words[i]的权重为i。

设计一个类WordFilter实现函数WordFilter.f(String prefix, String suffix)。这个函数将返回具有前缀prefix和后缀suffix的词的最大权重。如果没有这样的词，返回 -1。

例子:


输入:
WordFilter([apple])
WordFilter.f(a, e) // 返回 0
WordFilter.f(b, ) // 返回 -1


注意:


	words的长度在[1, 15000]之间。
	对于每个测试用例，最多会有words.length次对WordFilter.f的调用。
	words[i]的长度在[1, 10]之间。
	prefix, suffix的长度在[0, 10]之前。
	words[i]和prefix, suffix只包含小写字母。

前缀和后缀搜索 - 领扣 (LeetCode)
给定一个只包含小写字母的有序数组letters和一个目标字母target，寻找有序数组里面比目标字母大的最小字母。

数组里字母的顺序是循环的。举个例子，如果目标字母target = &#39;z&#39; 并且有序数组为letters = [&#39;a&#39;, &#39;b&#39;]，则答案返回&#39;a&#39;。

示例:


输入:
letters = [c, f, j]
target = a
输出: c

输入:
letters = [c, f, j]
target = c
输出: f

输入:
letters = [c, f, j]
target = d
输出: f

输入:
letters = [c, f, j]
target = g
输出: j

输入:
letters = [c, f, j]
target = j
输出: c

输入:
letters = [c, f, j]
target = k
输出: c


注:


	letters长度范围在[2, 10000]区间内。
	letters 仅由小写字母组成，最少包含两个不同的字母。
	目标字母target 是一个小写字母。

寻找比目标字母大的最小字母 - 领扣 (LeetCode)
网络延迟时间 - 领扣 (LeetCode)
有N个网络节点，标记为1到N。

给定一个列表times，表示信号经过有向边的传递时间。times[i] = (u, v, w)，其中u是源节点，v是目标节点， w是一个信号从源节点传递到目标节点的时间。

现在，我们向当前的节点K发送了一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回-1。

注意:


	N的范围在[1, 100]之间。
	K的范围在[1, N]之间。
	times的长度在[1, 6000]之间。
	所有的边times[i] = (u, v, w)都有1 <= u, v <= N且1 <= w <= 100。

实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。



示例 1：


输入: Hello
输出: hello

示例 2：


输入: here
输出: here

示例3：


输入: LOVELY
输出: lovely

转换成小写字母 - 领扣 (LeetCode)
摘樱桃 - 领扣 (LeetCode)
一个N x N的网格(grid)代表了一块樱桃地，每个格子由以下三种数字的一种来表示：


	0 表示这个格子是空的，所以你可以穿过它。
	1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
	-1 表示这个格子里有荆棘，挡着你的路。


你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：


	从位置(0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；
	当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；
	当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；
	如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。


示例 1:


输入: grid =
[[0, 1, -1],
 [1, 0, -1],
 [1, 1,  1]]
输出: 5
解释： 
玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。
在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。
接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。
在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。


说明:


	grid 是一个N * N 的二维数组，N的取值范围是1 <= N <= 50。
	每一个grid[i][j] 都是集合{-1, 0, 1}其中的一个数。
	可以保证起点grid[0][0]和终点grid[N-1][N-1]的值都不会是 -1。

删除与获得点数 - 领扣 (LeetCode)
给定一个整数数组nums，你可以对它进行一些操作。

每次操作中，选择任意一个nums[i]，删除它并获得nums[i]的点数。之后，你必须删除每个等于nums[i] - 1或nums[i] + 1的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

示例 1:


输入: nums = [3, 4, 2]
输出: 6
解释: 
删除 4 来获得 4 个点数，因此 3 也被删除。
之后，删除 2 来获得 2 个点数。总共获得 6 个点数。


示例2:


输入: nums = [2, 2, 3, 3, 3, 4]
输出: 9
解释: 
删除 3 来获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。


注意:


	nums的长度最大为20000。
	每个整数nums[i]的大小都在[1, 10000]范围内。

每日温度 - 领扣 (LeetCode)
根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高的天数。如果之后都不会升高，请输入0 来代替。

例如，给定一个列表temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是[1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是[1, 30000]。每个气温的值的都是[30, 100]范围内的整数。
单调递增的数字 - 领扣 (LeetCode)
给定一个非负整数N，找出小于或等于N的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

（当且仅当每个相邻位数上的数字x和y满足x <= y时，我们称这个整数是单调递增的。）

示例 1:

输入: N = 10
输出: 9


示例 2:

输入: N = 1234
输出: 1234


示例 3:

输入: N = 332
输出: 299


说明: N是在[0, 10^9]范围内的一个整数。
Lisp 语法解析 - 领扣 (LeetCode)
给定一个类似 Lisp 语句的表达式 expression，求出其计算结果。

表达式语法如下所示:


	表达式可以为整数，let 语法，add 语法，mult 语法。表达式的结果总是一个整数。
	(整数可以是正整数、负整数、0)
	let 语法表示为(let v1 e1 v2 e2 ... vn en expr),其中let语法总是以字符串let来表示，接下来会跟随一个或多个交替变量或表达式，也就是说，第一个变量v1被分配为表达式e1的值，第二个变量v2被分配为表达式e2的值，以此类推；最终 let 语法的值为expr表达式的值。
	add语法表示为(add e1 e2)，其中add语法总是以字符串add来表示，该语法总是有两个表达式e1、e2, 该语法的最终结果是e1 表达式的值与e2表达式的值之和。
	mult语法表示为(mult e1 e2)，其中mult语法总是以字符串mult表示， 该语法总是有两个表达式 e1、e2，该语法的最终结果是e1 表达式的值与e2表达式的值之积。
	在该题目中，变量的命名以小写字符开始，之后跟随0个或多个小写字符或数字。为了方便，add，let，mult会被定义为关键字，不会在表达式的变量命名中出现。
	最后，要说一下范围的概念。在做计算时，需要注意优先级，在最内层(根据括号)的表达式的值应该先计算,然后依次计算外层的表达式。我们将保证每一个测试的表达式都是合法的。有关范围的更多详细信息，请参阅示例。




示例:


输入: (add 1 2)
输出: 3

输入: (mult 3 (add 2 3))
输出: 15

输入: (let x 2 (mult x 5))
输出: 10

输入: (let x 2 (mult x (let x 3 y 4 (add x y))))
输出: 14
解释: 
表达式 (add x y), 在获取 x 值时, 我们应当由最内层依次向外计算, 首先遇到了 x=3, 所以此处的 x 值是 3.


输入: (let x 3 x 2 x)
输出: 2
解释: let 语句中的赋值运算按顺序处理即可

输入: (let x 1 y 2 x (add x y) (add x y))
输出: 5
解释: 
第一个 (add x y) 计算结果是 3，并且将此值赋给了 x 。
第二个 (add x y) 计算结果就是 3+2 = 5 。

输入: (let x 2 (add (let x 3 (let x 4 x)) x))
输出: 6
解释: 
(let x 4 x) 中的 x 的作用范围仅在()之内。所以最终做加法操作时，x 的值是 2 。

输入: (let a1 3 b2 (add a1 1) b2) 
输出: 4
解释: 
变量命名时可以在第一个小写字母后跟随数字.





注意:


	我们给定的expression表达式都是格式化后的：表达式前后没有多余的空格，表达式的不同部分(关键字、变量、表达式)之间仅使用一个空格分割，并且在相邻括号之间也没有空格。我们给定的表达式均为合法的且最终结果为整数。
	我们给定的表达式长度最多为 2000(表达式也不会为空，因为那不是一个合法的表达式)。
	最终的结果和中间的计算结果都将是一个 32 位整数。



行星碰撞 - 领扣 (LeetCode)
给定一个整数数组 asteroids，表示在同一行的行星。

对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。

找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。

示例 1:


输入: 
asteroids = [5, 10, -5]
输出: [5, 10]
解释: 
10 和 -5 碰撞后只剩下 10。 5 和 10 永远不会发生碰撞。


示例 2:


输入: 
asteroids = [8, -8]
输出: []
解释: 
8 和 -8 碰撞后，两者都发生爆炸。


示例 3:


输入: 
asteroids = [10, 2, -5]
输出: [10]
解释: 
2 和 -5 发生碰撞后剩下 -5。10 和 -5 发生碰撞后剩下 10。


示例 4:


输入: 
asteroids = [-2, -1, 1, 2]
输出: [-2, -1, 1, 2]
解释: 
-2 和 -1 向左移动，而 1 和 2 向右移动。
由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。


说明:


	数组asteroids 的长度不超过10000。
	每一颗行星的大小都是非零整数，范围是[-1000, 1000]。

图像渲染 - 领扣 (LeetCode)
有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。

给你一个坐标(sr, sc)表示图像渲染开始的像素值（行 ，列）和一个新的颜色值newColor，让你重新上色这幅图像。

为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，&hellip;&hellip;，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。

最后返回经过上色渲染后的图像。

示例 1:


输入: 
image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1, sc = 1, newColor = 2
输出: [[2,2,2],[2,2,0],[2,0,1]]
解析: 
在图像的正中间，(坐标(sr,sc)=(1,1)),
在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，
因为它不是在上下左右四个方向上与初始点相连的像素点。


注意:


	image 和image[0]的长度在范围[1, 50] 内。
	给出的初始点将满足0 <= sr < image.length 和0 <= sc < image[0].length。
	image[i][j] 和newColor表示的颜色值在范围[0, 65535]内。

实现一个 MyCalendar 类来存放你的日程安排，你可以一直添加新的日程安排。

MyCalendar 有一个 book(int start, int end)方法。它意味着在start到end时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数x 的范围为， start <= x < end。

当 K 个日程安排有一些时间上的交叉时（例如K个日程安排都在同一时间内），就会产生 K 次预订。

每次调用 MyCalendar.book方法时，返回一个整数 K ，表示最大的 K 次预订。

请按照以下步骤调用MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)

示例 1:


MyCalendarThree();
MyCalendarThree.book(10, 20); // returns 1
MyCalendarThree.book(50, 60); // returns 1
MyCalendarThree.book(10, 40); // returns 2
MyCalendarThree.book(5, 15); // returns 3
MyCalendarThree.book(5, 10); // returns 3
MyCalendarThree.book(25, 55); // returns 3
解释: 
前两个日程安排可以预订并且不相交，所以最大的K次预订是1。
第三个日程安排[10,40]与第一个日程安排相交，最高的K次预订为2。
其余的日程安排的最高K次预订仅为3。
请注意，最后一次日程安排可能会导致局部最高K次预订为2，但答案仍然是3，原因是从开始到最后，时间[10,20]，[10,40]和[5,15]仍然会导致3次预订。


说明:


	每个测试用例，调用MyCalendar.book函数最多不超过400次。
	调用函数MyCalendar.book(start, end)时，start 和end 的取值范围为[0, 10^9]。

我的日程安排表 III - 领扣 (LeetCode)
我的日程安排表 II - 领扣 (LeetCode)
实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。

MyCalendar 有一个 book(int start, int end)方法。它意味着在start到end时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数x 的范围为， start <= x < end。

当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。

每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。

请按照以下步骤调用MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)

示例 1:

MyCalendar();
MyCalendar.book(10, 20); // returns true
MyCalendar.book(50, 60); // returns true
MyCalendar.book(10, 40); // returns true
MyCalendar.book(5, 15); // returns false
MyCalendar.book(5, 10); // returns true
MyCalendar.book(25, 55); // returns true
解释: 
前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。
第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。
第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间10。
第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；
时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。


说明:


	每个测试用例，调用MyCalendar.book函数最多不超过100次。
	调用函数MyCalendar.book(start, end)时，start 和end 的取值范围为[0, 10^9]。

统计不同回文子字符串 - 领扣 (LeetCode)
给定一个字符串 S，找出 S 中不同的非空回文子字符串个数，并返回该数字与 10^9 + 7 的模。

通过从 S 中删除 0 个或多个字符来获得子字符串。

如果一个字符串字符序列与它的反转字符串字符序列一致，那么它是回文字符串。

如果对于某个i， A_i != B_i，那么A_1, A_2, ... 和B_1, B_2, ... 这两个字符串是不同的。

示例1:

输入: 
S = &#39;bccb&#39;
输出: 6
解释: 
6个不同的非空回文子字符串分别为： &#39;b&#39;, &#39;c&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;bcb&#39;, &#39;bccb&#39;。
注意： &#39;bcb&#39; 虽然出现两次但仅计数一次。




样例2:

输入: 
S = &#39;abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba&#39;
输出: 104860361
解释: 
共有 3104860382 个不同的非空回文子字符串，对 10^9 + 7 取模为 104860361。




提示：


	字符串S的长度将在[1, 1000]范围内。
	每个字符S[i]将会是集合{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;}中的某一个。



我的日程安排表 I - 领扣 (LeetCode)
实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。

MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数x 的范围为， start <= x < end。

当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。

每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false并且不要将该日程安排添加到日历中。

请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)

示例 1:

MyCalendar();
MyCalendar.book(10, 20); // returns true
MyCalendar.book(15, 25); // returns false
MyCalendar.book(20, 30); // returns true
解释: 
第一个日程安排可以添加到日历中.  第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了。
第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 。


说明:


	每个测试用例，调用MyCalendar.book函数最多不超过100次。
	调用函数MyCalendar.book(start, end)时，start 和end 的取值范围为[0, 10^9]。

自除数是指可以被它包含的每一位数除尽的数。

例如，128 是一个自除数，因为128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。

还有，自除数不允许包含 0 。

给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。

示例 1：


输入： 
上边界left = 1, 下边界right = 22
输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]


注意：


	每个输入参数的边界满足1 <= left <= right <= 10000。

自除数 - 领扣 (LeetCode)
原子的数量 - 领扣 (LeetCode)
给定一个化学式formula（作为字符串），返回每种原子的数量。

原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。

如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。

两个化学式连在一起是新的化学式。例如H2O2He3Mg4 也是化学式。

一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。

给定一个化学式，输出所有原子的数量。格式为：第一个（按字典序）原子的名子，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。

示例 1:


输入: 
formula = H2O
输出: H2O
解释: 
原子的数量是 {&#39;H&#39;: 2, &#39;O&#39;: 1}。


示例 2:


输入: 
formula = Mg(OH)2
输出: H2MgO2
解释: 
原子的数量是 {&#39;H&#39;: 2, &#39;Mg&#39;: 1, &#39;O&#39;: 2}。


示例 3:


输入: 
formula = K4(ON(SO3)2)2
输出: K4N2O14S4
解释: 
原子的数量是 {&#39;K&#39;: 4, &#39;N&#39;: 2, &#39;O&#39;: 14, &#39;S&#39;: 4}。


注意:


	所有原子的第一个字母为大写，剩余字母都是小写。
	formula的长度在[1, 1000]之间。
	formula只包含字母、数字和圆括号，并且题目中给定的是合法的化学式。

分隔链表 - 领扣 (LeetCode)
给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。

每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。

这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。

返回一个符合上述规则的链表的列表。

举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]

示例 1：


输入: 
root = [1, 2, 3], k = 5
输出: [[1],[2],[3],[],[]]
解释:
输入输出各部分都应该是链表，而不是数组。
例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。
第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。
最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。


示例 2：


输入: 
root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
解释:
输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。




提示:


	root 的长度范围：[0, 1000].
	输入的每个节点的大小范围：[0, 999].
	k的取值范围：[1, 50].



寻找数组的中心索引 - 领扣 (LeetCode)
给定一个整数类型的数组nums，请编写一个能够返回数组&ldquo;中心索引&rdquo;的方法。

我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。

如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。

示例 1:


输入: 
nums = [1, 7, 3, 6, 5, 6]
输出: 3
解释: 
索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。
同时, 3 也是第一个符合要求的中心索引。


示例 2:


输入: 
nums = [1, 2, 3]
输出: -1
解释: 
数组中不存在满足此条件的中心索引。

说明:


	nums 的长度范围为[0, 10000]。
	任何一个nums[i] 将会是一个范围在[-1000, 1000]的整数。

删除注释 - 领扣 (LeetCode)
给一个 C++ 程序，删除程序中的注释。这个程序source是一个数组，其中source[i]表示第i行源码。这表示每行源码由\n分隔。

在 C++ 中有两种注释风格，行内注释和块注释。

字符串// 表示行注释，表示//和其右侧的其余字符应该被忽略。

字符串/* 表示一个块注释，它表示直到*/的下一个（非重叠）出现的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串/*/并没有结束块注释，因为注释的结尾与开头相重叠。

第一个有效注释优先于其他注释：如果字符串//出现在块注释中会被忽略。 同样，如果字符串/*出现在行或块注释中也会被忽略。

如果一行在删除注释之后变为空字符串，那么不要输出该行。即，答案列表中的每个字符串都是非空的。

样例中没有控制字符，单引号或双引号字符。比如，source = string s = /* Not a comment. */; 不会出现在测试样例里。（此外，没有其他内容（如定义或宏）会干扰注释。）

我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的/*总是开始新的注释。

最后，隐式换行符可以通过块注释删除。 有关详细信息，请参阅下面的示例。

从源代码中删除注释后，需要以相同的格式返回源代码。

示例1:


输入: 
source = [/*Test program */, int main(), { ,   // variable declaration , int a, b, c;, /* This is a test,    multiline  ,    comment for ,    testing */, a = b + c;, }]

示例代码可以编排成这样:
/*Test program */
int main()
{ 
  // variable declaration 
int a, b, c;
/* This is a test
   multiline  
   comment for 
   testing */
a = b + c;
}

输出: [int main(),{ ,  ,int a, b, c;,a = b + c;,}]

编排后:
int main()
{ 
  
int a, b, c;
a = b + c;
}

解释: 
第 1 行和第 6-9 行的字符串 /* 表示块注释。第 4 行的字符串 // 表示行注释。


示例 2:


输入: 
source = [a/*comment, line, more_comment*/b]
输出: [ab]
解释: 原始的 source 字符串是 a/*comment\nline\nmore_comment*/b, 其中我们用粗体显示了换行符。删除注释后，隐含的换行符被删除，留下字符串 ab 用换行符分隔成数组时就是 [ab].


注意:


	source的长度范围为[1, 100].
	source[i]的长度范围为[0, 80].
	每个块注释都会被闭合。
	给定的源码中不会有单引号、双引号或其他控制字符。

给定一个列表 accounts，每个元素 accounts[i]是一个字符串列表，其中第一个元素 accounts[i][0]是名称 (name)，其余元素是 emails 表示该帐户的邮箱地址。

现在，我们想合并这些帐户。如果两个帐户都有一些共同的邮件地址，则两个帐户必定属于同一个人。请注意，即使两个帐户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的帐户，但其所有帐户都具有相同的名称。

合并帐户后，按以下格式返回帐户：每个帐户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。accounts 本身可以以任意顺序返回。

例子 1:


Input: 
accounts = [[John, johnsmith@mail.com, john00@mail.com], [John, johnnybravo@mail.com], [John, johnsmith@mail.com, john_newyork@mail.com], [Mary, mary@mail.com]]
Output: [[John, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;],  [John, johnnybravo@mail.com], [Mary, mary@mail.com]]
Explanation: 
  第一个和第三个 John 是同一个人，因为他们有共同的电子邮件 johnsmith@mail.com。 
  第二个 John 和 Mary 是不同的人，因为他们的电子邮件地址没有被其他帐户使用。
  我们可以以任何顺序返回这些列表，例如答案[[&#39;Mary&#39;，&#39;mary@mail.com&#39;]，[&#39;John&#39;，&#39;johnnybravo@mail.com&#39;]，
  [&#39;John&#39;，&#39;john00@mail.com&#39;，&#39;john_newyork@mail.com&#39;，&#39;johnsmith@mail.com&#39;]]仍然会被接受。



注意：


	accounts的长度将在[1，1000]的范围内。
	accounts[i]的长度将在[1，10]的范围内。
	accounts[i][j]的长度将在[1，30]的范围内。

账户合并 - 领扣 (LeetCode)
给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。

若无答案，则返回空字符串。

示例 1:


输入: 
words = [w,wo,wor,worl, world]
输出: world
解释: 
单词world可由w, wo, wor, 和 worl添加一个字母组成。


示例 2:


输入: 
words = [a, banana, app, appl, ap, apply, apple]
输出: apple
解释: 
apply和apple都能由词典中的单词组成。但是apple得字典序小于apply。


注意:


	所有输入的字符串都只包含小写字母。
	words数组长度范围为[1,1000]。
	words[i]的长度范围为[1,30]。

词典中最长的单词 - 领扣 (LeetCode)
找出第 k 小的距离对 - 领扣 (LeetCode)
给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。

示例 1:


输入：
nums = [1,3,1]
k = 1
输出：0 
解释：
所有数对如下：
(1,3) -&gt; 2
(1,1) -&gt; 0
(3,1) -&gt; 2
因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。


提示:


	2 <= len(nums) <= 10000.
	0 <= nums[i] < 1000000.
	1 <= k <= len(nums) * (len(nums) - 1) / 2.

给两个整数数组A和B，返回两个数组中公共的、长度最长的子数组的长度。

示例 1:


输入:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出: 3
解释: 
长度最长的公共子数组是 [3, 2, 1]。


说明:


	1 <= len(A), len(B) <= 1000
	0 <= A[i], B[i] < 100

最长重复子数组 - 领扣 (LeetCode)
有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10或11)来表示。

现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。

示例1:


输入: 
bits = [1, 0, 0]
输出: True
解释: 
唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。


示例2:


输入: 
bits = [1, 1, 1, 0]
输出: False
解释: 
唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。


注意:


	1 <= len(bits) <= 1000.
	bits[i] 总是0 或1.

1比特与2比特字符 - 领扣 (LeetCode)
Range 模块是跟踪数字范围的模块。你的任务是以一种有效的方式设计和实现以下接口。


	addRange(int left, int right) 添加半开区间[left, right)，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间[left, right)中尚未跟踪的任何数字到该区间中。
	queryRange(int left, int right)只有在当前正在跟踪区间[left, right)中的每一个实数时，才返回 true。
	removeRange(int left, int right)停止跟踪区间[left, right)中当前正在跟踪的每个实数。




示例：

addRange(10, 20): null
removeRange(14, 16): null
queryRange(10, 14): true （区间 [10, 14) 中的每个数都正在被跟踪）
queryRange(13, 15): false （未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）
queryRange(16, 17): true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪）




提示：


	半开区间[left, right)表示所有满足left <= x < right的实数。
	对addRange, queryRange, removeRange的所有调用中0 < left < right < 10^9。
	在单个测试用例中，对addRange的调用总数不超过1000次。
	在单个测试用例中，对 queryRange 的调用总数不超过 5000 次。
	在单个测试用例中，对 removeRange 的调用总数不超过1000次。



Range 模块 - 领扣 (LeetCode)
给定一个整数数组prices，其中第i个元素代表了第i天的股票价格 ；非负整数fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

示例 1:

输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润:((8 - 1) - 2) + ((9 - 4) - 2) = 8.

注意:


	0 < prices.length <= 50000.
	0 < prices[i] < 50000.
	0 <= fee < 50000.

买卖股票的最佳时机含手续费 - 领扣 (LeetCode)
乘积小于K的子数组 - 领扣 (LeetCode)
给定一个正整数数组nums。

找出该数组内乘积小于k的连续的子数组的个数。

示例 1:


输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。


说明:


	0 < nums.length <= 50000
	0 < nums[i] < 1000
	0 <= k < 10^6

给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。

示例 1:


输入: s1 = sea, s2 = eat
输出: 231
解释: 在 sea 中删除 s 并将 s 的值(115)加入总和。
在 eat 中删除 t 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。


示例2:


输入: s1 = delete, s2 = leet
输出: 403
解释: 在 delete 中删除 dee 字符串变成 let，
将 100[d]+101[e]+101[e] 加入总和。在 leet 中删除 e 将 101[e] 加入总和。
结束时，两个字符串都等于 let，结果即为 100+101+101+101 = 403 。
如果改为将两个字符串转换为 lee 或 eet，我们会得到 433 或 417 的结果，比答案更大。


注意:


	0 < s1.length, s2.length <= 1000。
	所有字符串中的字符ASCII值在[97, 122]之间。

两个字符串的最小ASCII删除和 - 领扣 (LeetCode)
掉落的方块 - 领扣 (LeetCode)
在无限长的数轴（即 x 轴）上，我们根据给定的顺序放置对应的正方形方块。

第 i 个掉落的方块（positions[i] = (left, side_length)）是正方形，其中left 表示该方块最左边的点位置(positions[i][0])，side_length 表示该方块的边长(positions[i][1])。

每个方块的底部边缘平行于数轴（即 x 轴），并且从一个比目前所有的落地方块更高的高度掉落而下。在上一个方块结束掉落，并保持静止后，才开始掉落新方块。

方块的底边具有非常大的粘性，并将保持固定在它们所接触的任何长度表面上（无论是数轴还是其他方块）。邻接掉落的边不会过早地粘合在一起，因为只有底边才具有粘性。



返回一个堆叠高度列表ans 。每一个堆叠高度ans[i]表示在通过positions[0], positions[1], ..., positions[i]表示的方块掉落结束后，目前所有已经落稳的方块堆叠的最高高度。





示例 1:

输入: [[1, 2], [2, 3], [6, 1]]
输出: [2, 5, 5]
解释:

第一个方块 positions[0] = [1, 2] 掉落：
_aa
_aa
-------
方块最大高度为 2 。

第二个方块 positions[1] = [2, 3] 掉落：
__aaa
__aaa
__aaa
_aa__
_aa__
--------------
方块最大高度为5。
大的方块保持在较小的方块的顶部，不论它的重心在哪里，因为方块的底部边缘有非常大的粘性。

第三个方块 positions[1] = [6, 1] 掉落：
__aaa
__aaa
__aaa
_aa
_aa___a
-------------- 
方块最大高度为5。

因此，我们返回结果[2, 5, 5]。




示例 2:

输入: [[100, 100], [200, 100]]
输出: [100, 100]
解释: 相邻的方块不会过早地卡住，只有它们的底部边缘才能粘在表面上。




注意:


	1 <= positions.length <= 1000.
	1 <= positions[i][0] <= 10^8.
	1 <= positions[i][1] <= 10^6.



划分为k个相等的子集 - 领扣 (LeetCode)
给定一个整数数组nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。

示例 1：


输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
输出： True
说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。



注意:


	1 <= k <= len(nums) <= 16
	0 < nums[i] < 10000

数组的度 - 领扣 (LeetCode)
给定一个非空且只包含非负数的整数数组nums, 数组的度的定义是指数组里任一元素出现频数的最大值。

你的任务是找到与nums拥有相同大小的度的最短连续子数组，返回其长度。

示例 1:


输入: [1, 2, 2, 3, 1]
输出: 2
解释: 
输入数组的度是2，因为元素1和2的出现频数最大，均为2.
连续子数组里面拥有相同度的有如下所示:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组[2, 2]的长度为2，所以返回2.


示例 2:


输入: [1,2,2,3,1,4,2]
输出: 6


注意:


	nums.length在1到50,000区间范围内。
	nums[i]是一个在0到49,999范围内的整数。

给定一个字符串s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

示例 1 :


输入: 00110011
输出: 6
解释: 有6个子串具有相同数量的连续1和0：&ldquo;0011&rdquo;，&ldquo;01&rdquo;，&ldquo;1100&rdquo;，&ldquo;10&rdquo;，&ldquo;0011&rdquo; 和 &ldquo;01&rdquo;。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，&ldquo;00110011&rdquo;不是有效的子串，因为所有的0（和1）没有组合在一起。


示例 2 :


输入: 10101
输出: 4
解释: 有4个子串：&ldquo;10&rdquo;，&ldquo;01&rdquo;，&ldquo;10&rdquo;，&ldquo;01&rdquo;，它们具有相同数量的连续1和0。


注意：


	s.length在1到50,000之间。
	s只包含&ldquo;0&rdquo;或&ldquo;1&rdquo;字符。

计数二进制子串 - 领扣 (LeetCode)
岛屿的最大面积 - 领扣 (LeetCode)
给定一个包含了一些 0 和 1的非空二维数组grid, 一个岛屿是由四个方向 (水平或垂直) 的1(代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)

示例 1:


[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]


对于上面这个给定矩阵应返回6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的&lsquo;1&rsquo;。

示例 2:


[[0,0,0,0,0,0,0,0]]

对于上面这个给定的矩阵, 返回0。

注意:给定的矩阵grid的长度和宽度都不超过 50。
给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。

示例 1:


输入: 5
输出: True
解释:
5的二进制数是: 101


示例 2:


输入: 7
输出: False
解释:
7的二进制数是: 111


示例3:


输入: 11
输出: False
解释:
11的二进制数是: 1011


示例 4:


输入: 10
输出: True
解释:
10的二进制数是: 1010

交替位二进制数 - 领扣 (LeetCode)
前K个高频单词 - 领扣 (LeetCode)
给一非空的单词列表，返回前k个出现次数最多的单词。

返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。

示例 1：


输入: [i, love, leetcode, i, love, coding], k = 2
输出: [i, love]
解析: i 和 love 为出现次数最多的两个单词，均为2次。
    注意，按字母顺序 i 在 love 之前。




示例 2：


输入: [the, day, is, sunny, the, the, the, sunny, is, is], k = 4
输出: [the, is, sunny, day]
解析: the, is, sunny 和 day 是出现次数最多的四个单词，
    出现次数依次为 4, 3, 2 和 1 次。




注意：


	假定 k 总为有效值， 1 &le; k &le; 集合元素数。
	输入的单词均由小写字母组成。




扩展练习：


	尝试以O(n log k) 时间复杂度和O(n) 空间复杂度解决。

贴纸拼词 - 领扣 (LeetCode)
我们给出了 N 种不同类型的贴纸。每个贴纸上都有一个小写的英文单词。

你希望从自己的贴纸集合中裁剪单个字母并重新排列它们，从而拼写出给定的目标字符串 target。

如果你愿意的话，你可以不止一次地使用每一张贴纸，而且每一张贴纸的数量都是无限的。

拼出目标target 所需的最小贴纸数量是多少？如果任务不可能，则返回 -1。



示例 1：

输入：

[with, example, science], thehat


输出：

3


解释：

我们可以使用 2 个 with 贴纸，和 1 个 example 贴纸。
把贴纸上的字母剪下来并重新排列后，就可以形成目标 &ldquo;thehat&ldquo; 了。
此外，这是形成目标字符串所需的最小贴纸数量。


示例 2：

输入：

[notice, possible], basicbasic


输出：

-1


解释：

我们不能通过剪切给定贴纸的字母来形成目标&ldquo;basicbasic&rdquo;。




提示：


	stickers 长度范围是[1, 50]。
	stickers 由小写英文单词组成（不带撇号）。
	target 的长度在[1, 15]范围内，由小写字母组成。
	在所有的测试案例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选取的，目标是两个随机单词的串联。
	时间限制可能比平时更具挑战性。预计 50 个贴纸的测试案例平均可在35ms内解决。



给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度和 直系下属的id。

比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。

现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。

示例 1:


输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
输出: 11
解释:
员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。


注意:


	一个员工最多有一个直系领导，但是可以有多个直系下属
	员工数量不超过2000。

员工的重要性 - 领扣 (LeetCode)
给定数组nums由正整数组成，找到三个互不重叠的子数组的最大和。

每个子数组的长度为k，我们要使这3*k个项的和最大化。

返回每个区间起始索引的列表（索引从 0 开始）。如果有多个结果，返回字典序最小的一个。

示例:


输入: [1,2,1,2,6,7,5,1], 2
输出: [0, 3, 5]
解释: 子数组 [1, 2], [2, 6], [7, 5] 对应的起始索引为 [0, 3, 5]。
我们也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。


注意:


	nums.length的范围在[1, 20000]之间。
	nums[i]的范围在[1, 65535]之间。
	k的范围在[1, floor(nums.length / 3)]之间。

三个无重叠子数组的最大和 - 领扣 (LeetCode)
“马”在棋盘上的概率 - 领扣 (LeetCode)
已知一个NxN的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为(0, 0)，最右下角的记为(N-1, N-1)。

现有一个 &ldquo;马&rdquo;（也译作 &ldquo;骑士&rdquo;）位于(r, c)，并打算进行K 次移动。

如下图所示，国际象棋的 &ldquo;马&rdquo; 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。







现在 &ldquo;马&rdquo; 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了K次或跳到了棋盘外面。

求移动结束后，&ldquo;马&rdquo; 仍留在棋盘上的概率。



示例：

输入: 3, 2, 0, 0
输出: 0.0625
解释: 
输入的数据依次为 N, K, r, c
第 1 步时，有且只有 2 种走法令 &ldquo;马&rdquo; 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 &ldquo;马&rdquo; 仍然留在棋盘上。
所以 &ldquo;马&rdquo; 在结束后仍在棋盘上的概率为 0.0625。




注意：


	N 的取值范围为 [1, 25]
	K的取值范围为 [0, 100]
	开始时，&ldquo;马&rdquo; 总是位于棋盘上

最长同值路径 - 领扣 (LeetCode)
给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

注意：两个节点之间的路径长度由它们之间的边数表示。

示例 1:

输入:


              5
             / \
            4   5
           / \   \
          1   1   5


输出:


2


示例 2:

输入:


              1
             / \
            4   5
           / \   \
          4   4   5


输出:


2


注意: 给定的二叉树不超过10000个结点。树的高度不超过1000。
重复叠加字符串匹配 - 领扣 (LeetCode)
给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数，使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。

举个例子，A = abcd，B = cdabcdab。

答案为 3，因为 A 重复叠加三遍后为&ldquo;abcdabcdabcd&rdquo;，此时 B 是其子串；A 重复叠加两遍后为abcdabcd，B 并不是其子串。

注意:

A与B字符串的长度在1和10000区间范围内。
在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。

输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u and v和顶点的边，其中父节点u是子节点v的一个父节点。

返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。

示例1:


输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的有向图如下:
  1
 / \
v   v
2--&gt;3


示例 2:


输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]
输出: [4,1]
解释: 给定的有向图如下:
5 <- 1 -&gt; 2
     ^    |
     |    v
     4 <- 3


注意:


	二维数组大小的在3到1000范围内。
	二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。

冗余连接 II - 领扣 (LeetCode)
在本问题中, 树指的是一个连通且无环的无向图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v]，满足u < v，表示连接顶点u和v的无向图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边[u, v] 应满足相同的格式u < v。

示例 1：

输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3


示例 2：

输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3


注意:


	输入的二维数组大小在 3 到 1000。
	二维数组中的整数在1到N之间，其中N是输入数组的大小。


更新(2017-09-26):
我们已经重新检查了问题描述及测试用例，明确图是无向图。对于有向图详见冗余连接II。对于造成任何不便，我们深感歉意。
冗余连接 - 领扣 (LeetCode)
你现在是棒球比赛记录员。
给定一个字符串列表，每个字符串可以是以下四种类型之一：
1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。
2. +（一轮的得分）：表示本轮获得的得分是前两轮有效回合得分的总和。
3. D（一轮的得分）：表示本轮获得的得分是前一轮有效回合得分的两倍。
4. C（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效回合的分数是无效的，应该被移除。

每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。
你需要返回你在所有回合中得分的总和。

示例 1:

输入: [5,2,C,D,+]
输出: 30
解释: 
第1轮：你可以得到5分。总和是：5。
第2轮：你可以得到2分。总和是：7。
操作1：第2轮的数据无效。总和是：5。
第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。
第4轮：你可以得到5 + 10 = 15分。总数是：30。


示例 2:

输入: [5,-2,4,C,D,9,+,+]
输出: 27
解释: 
第1轮：你可以得到5分。总和是：5。
第2轮：你可以得到-2分。总数是：3。
第3轮：你可以得到4分。总和是：7。
操作1：第3轮的数据无效。总数是：3。
第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。
第5轮：你可以得到9分。总数是：8。
第6轮：你可以得到-4 + 9 = 5分。总数是13。
第7轮：你可以得到9 + 5 = 14分。总数是27。


注意：


	输入列表的大小将介于1和1000之间。
	列表中的每个整数都将介于-30000和30000之间。

棒球比赛 - 领扣 (LeetCode)
给定一个非空字符串s，最多删除一个字符。判断是否能成为回文字符串。

示例 1:


输入: aba
输出: True


示例 2:


输入: abca
输出: True
解释: 你可以删除c字符。


注意:


	字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。

验证回文字符串 Ⅱ - 领扣 (LeetCode)
你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过*，/，+，-，(，)的运算得到 24。

示例 1:


输入: [4, 1, 8, 7]
输出: True
解释: (8-4) * (7-1) = 24


示例 2:


输入: [1, 2, 1, 2]
输出: False


注意:


	除法运算符/表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。
	每个运算符对两个数进行运算。特别是我们不能用-作为一元运算符。例如，[1, 1, 1, 1]作为输入时，表达式-1 - 1 - 1 - 1是不允许的。
	你不能将数字连接在一起。例如，输入为[1, 2, 1, 2]时，不能写成 12 + 12 。

24点游戏 - 领扣 (LeetCode)
有效的括号字符串 - 领扣 (LeetCode)
给定一个只包含三种字符的字符串：（，）和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：


	任何左括号 (必须有相应的右括号 )。
	任何右括号 )必须有相应的左括号 (。
	左括号 ( 必须在对应的右括号之前 )。
	*可以被视为单个右括号 )，或单个左括号 (，或一个空字符串。
	一个空字符串也被视为有效字符串。


示例 1:


输入: ()
输出: True


示例 2:


输入: (*)
输出: True


示例 3:


输入: (*))
输出: True


注意:


	字符串大小将在 [1，100] 范围内。

实现一个 MapSum 类里的两个方法，insert和sum。

对于方法insert，你将得到一对（字符串，整数）的键值对。字符串表示键，整数表示值。如果键已经存在，那么原来的键值对将被替代成新的键值对。

对于方法 sum，你将得到一个表示前缀的字符串，你需要返回所有以该前缀开头的键的值的总和。

示例 1:

输入: insert(apple, 3), 输出: Null
输入: sum(ap), 输出: 3
输入: insert(app, 2), 输出: Null
输入: sum(ap), 输出: 5

键值映射 - 领扣 (LeetCode)
实现一个带有buildDict, 以及search方法的魔法字典。

对于buildDict方法，你将被给定一串不重复的单词来构建一个字典。

对于search方法，你将被给定一个单词，并且判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。

示例 1:


Input: buildDict([hello, leetcode]), Output: Null
Input: search(hello), Output: False
Input: search(hhllo), Output: True
Input: search(hell), Output: False
Input: search(leetcoded), Output: False


注意:


	你可以假设所有输入都是小写字母a-z。
	为了便于竞赛，测试所用的数据量很小。你可以在竞赛结束后，考虑更高效的算法。
	请记住重置MagicDictionary类中声明的类变量，因为静态/类变量会在多个测试用例中保留。 请参阅这里了解更多详情。

实现一个魔法字典 - 领扣 (LeetCode)
你被请来给一个要举办高尔夫比赛的树林砍树. 树林由一个非负的二维数组表示， 在这个数组中：


	0 表示障碍，无法触碰到.
	1表示可以行走的地面.
	比1大的数表示一颗允许走过的树的高度.


你被要求按照树的高度从低向高砍掉所有的树，每砍过一颗树，树的高度变为1。

你将从（0，0）点开始工作，你应该返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。

可以保证的是，没有两棵树的高度是相同的，并且至少有一颗树需要你砍。

示例1:


输入: 
[
 [1,2,3],
 [0,0,4],
 [7,6,5]
]
输出: 6




示例2:


输入: 
[
 [1,2,3],
 [0,0,0],
 [7,6,5]
]
输出: -1




示例3:


输入: 
[
 [2,3,4],
 [0,0,5],
 [8,7,6]
]
输出: 6

解释: (0,0) 位置的树，你可以直接砍去，不用算步数




提示: 矩阵大小不会超过 50x50 。
为高尔夫比赛砍树 - 领扣 (LeetCode)
最长连续递增序列 - 领扣 (LeetCode)
给定一个未经排序的整数数组，找到最长且连续的的递增序列。

示例 1:


输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 


示例 2:


输入: [2,2,2,2,2]
输出: 1
解释: 最长连续递增序列是 [2], 长度为1。


注意：数组长度不会超过10000。
给定一个未排序的整数数组，找到最长递增子序列的个数。

示例 1:


输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。


示例 2:


输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。


注意:给定的数组长度不超过 2000 并且结果一定是32位有符号整数。
最长递增子序列的个数 - 领扣 (LeetCode)
现有一个房间，墙上挂有n只已经打开的灯泡和 4 个按钮。在进行了m次未知操作后，你需要返回这n只灯泡可能有多少种不同的状态。

假设这 n 只灯泡被编号为 [1, 2, 3 ..., n]，这 4 个按钮的功能如下：


	将所有灯泡的状态反转（即开变为关，关变为开）
	将编号为偶数的灯泡的状态反转
	将编号为奇数的灯泡的状态反转
	将编号为 3k+1 的灯泡的状态反转（k = 0, 1, 2, ...)


示例 1:

输入: n = 1, m = 1.
输出: 2
说明: 状态为: [开], [关]


示例 2:

输入: n = 2, m = 1.
输出: 3
说明: 状态为: [开, 关], [关, 开], [关, 关]


示例 3:

输入: n = 3, m = 1.
输出: 4
说明: 状态为: [关, 开, 关], [开, 关, 开], [关, 关, 关], [关, 开, 开].


注意：n和m 都属于 [0, 1000].
灯泡开关 Ⅱ - 领扣 (LeetCode)
给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为2或0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。

给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。

示例 1:


输入: 
    2
   / \
  2   5
     / \
    5   7

输出: 5
说明: 最小的值是 2 ，第二小的值是 5 。


示例 2:


输入: 
    2
   / \
  2   2

输出: -1
说明: 最小的值是 2, 但是不存在第二小的值。

二叉树中第二小的节点 - 领扣 (LeetCode)
最大交换 - 领扣 (LeetCode)
给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。

示例 1 :


输入: 2736
输出: 7236
解释: 交换数字2和数字7。


示例 2 :


输入: 9973
输出: 9973
解释: 不需要交换。


注意:


	给定数字的范围是[0, 108]

给定一个二叉搜索树，同时给定最小边界L和最大边界R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

示例 1:


输入: 
    1
   / \
  0   2

  L = 1
  R = 2

输出: 
    1
      \
       2


示例 2:


输入: 
    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

输出: 
      3
     / 
   2   
  /
 1

修剪二叉搜索树 - 领扣 (LeetCode)
乘法表中第k小的数 - 领扣 (LeetCode)
几乎每一个人都用乘法表。但是你能在乘法表中快速找到第k小的数字吗？

给定高度m、宽度n 的一张m * n的乘法表，以及正整数k，你需要返回表中第k小的数字。

例1：


输入: m = 3, n = 3, k = 5
输出: 3
解释: 
乘法表:
1	2	3
2	4	6
3	6	9

第5小的数字是 3 (1, 2, 2, 3, 3).


例 2：


输入: m = 2, n = 3, k = 6
输出: 6
解释: 
乘法表:
1	2	3
2	4	6

第6小的数字是 6 (1, 2, 2, 3, 4, 6).


注意：


	m 和n的范围在 [1, 30000] 之间。
	k 的范围在 [1, m * n] 之间。

给定两个整数n和k，你需要实现一个数组，这个数组包含从1到n的 n个不同整数，同时满足以下条件：

① 如果这个数组是 [a1, a2, a3, ... , an] ，那么数组[|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有k 个不同整数；.

② 如果存在多种答案，你只需实现并返回其中任意一种.

示例 1:


输入: n = 3, k = 1
输出: [1, 2, 3]
解释: [1, 2, 3] 包含 3 个范围在 1-3 的不同整数， 并且 [1, 1] 中有且仅有 1 个不同整数 : 1




示例 2:


输入: n = 3, k = 2
输出: [1, 3, 2]
解释: [1, 3, 2] 包含 3 个范围在 1-3 的不同整数， 并且 [2, 1] 中有且仅有 2 个不同整数: 1 和 2




提示:


	n和k满足条件1 <= k < n <= 104.



优美的排列 II - 领扣 (LeetCode)
给定一个长度为n的整数数组，你的任务是判断在最多改变1 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的：对于数组中所有的i (1 <= i < n)，满足array[i] <= array[i + 1]。

示例 1:


输入: [4,2,3]
输出: True
解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。


示例 2:


输入: [4,2,1]
输出: False
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。


说明:n 的范围为 [1, 10,000]。
非递减数列 - 领扣 (LeetCode)
奇怪的打印机 - 领扣 (LeetCode)
有台奇怪的打印机有以下两个特殊要求：


	打印机每次只能打印同一个字符序列。
	每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。


给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。

示例 1:


输入: aaabbb
输出: 2
解释: 首先打印 aaa 然后打印 bbb。


示例 2:


输入: aba
输出: 2
解释: 首先打印 aaa 然后在第二个位置打印 b 覆盖掉原来的字符 &#39;a&#39;。

提示: 输入字符串的长度不会超过 100。
给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。

每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。

示例 1:


输入: 

           1
         /   \
        3     2
       / \     \  
      5   3     9 

输出: 4
解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。


示例 2:


输入: 

          1
         /  
        3    
       / \       
      5   3     

输出: 2
解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。


示例3:


输入: 

          1
         / \
        3   2 
       /        
      5      

输出: 2
解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。


示例 4:


输入: 

          1
         / \
        3   2
       /     \  
      5       9 
     /         \
    6           7
输出: 8
解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。


注意: 答案在32位有符号整数的表示范围内。
二叉树最大宽度 - 领扣 (LeetCode)
图片平滑器 - 领扣 (LeetCode)
包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度(向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。

示例 1:


输入:
[[1,1,1],
 [1,0,1],
 [1,1,1]]
输出:
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0


注意:


	给定矩阵中的整数范围为 [0, 255]。
	矩阵的长和宽的范围均为[1, 150]。

分割数组为连续子序列 - 领扣 (LeetCode)
输入一个按升序排序的整数数组（可能包含重复数字），你需要将它们分割成几个子序列，其中每个子序列至少包含三个连续整数。返回你是否能做出这样的分割？



示例 1：


输入: [1,2,3,3,4,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3
3, 4, 5




示例 2：


输入: [1,2,3,3,4,4,5,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3, 4, 5
3, 4, 5




示例 3：


输入: [1,2,3,4,4,5]
输出: False




提示：


	输入的数组长度范围为 [1, 10000]



给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。

示例1:


输入: [1,2,3,4,5], k=4, x=3
输出: [1,2,3,4]




示例 2:


输入: [1,2,3,4,5], k=4, x=-1
输出: [1,2,3,4]




说明:


	k 的值为正数，且总是小于给定排序数组的长度。
	数组不为空，且长度不超过 104
	数组里的每个元素与x 的绝对值不超过 104




更新(2017/9/19):
这个参数 arr 已经被改变为一个整数数组（而不是整数列表）。请重新加载代码定义以获取最新更改。
找到 K 个最接近的元素 - 领扣 (LeetCode)
机器人能否返回原点 - 领扣 (LeetCode)
在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在(0, 0) 处结束。

移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。

注意：机器人&ldquo;面朝&rdquo;的方向无关紧要。 &ldquo;R&rdquo; 将始终使机器人向右移动一次，&ldquo;L&rdquo; 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。



示例 1:

输入: UD
输出: true
解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。

示例 2:

输入: LL
输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 &ldquo;移动&rdquo; 的距离。我们返回 false，因为它在移动结束时没有返回原点。
在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：


	行数m应当等于给定二叉树的高度。
	列数n应当总是奇数。
	根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。
	每个未使用的空间应包含一个空的字符串。
	使用相同的规则输出子树。


示例 1:


输入:
     1
    /
   2
输出:
[[, 1, ],
 [2, , ]]


示例 2:


输入:
     1
    / \
   2   3
    \
     4
输出:
[[, , , 1, , , ],
 [, 2, , , , 3, ],
 [, , 4, , , , ]]


示例 3:


输入:
      1
     / \
    2   5
   / 
  3 
 / 
4 
输出:
[[,  ,  , ,  , , , 1, ,  ,  ,  ,  , , ]
 [,  ,  , 2, , , , ,  ,  ,  ,  5, , , ]
 [,  3, , ,  , , , ,  ,  ,  ,  ,  , , ]
 [4, ,  , ,  , , , ,  ,  ,  ,  ,  , , ]]


注意: 二叉树的高度在范围 [1, 10] 中。
输出二叉树 - 领扣 (LeetCode)
给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：


	二叉树的根是数组中的最大元素。
	左子树是通过数组中最大值左边部分构造出的最大二叉树。
	右子树是通过数组中最大值右边部分构造出的最大二叉树。


通过给定的数组构建最大二叉树，并且输出这个树的根节点。

Example 1:


输入: [3,2,1,6,0,5]
输入: 返回下面这棵树的根节点：

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1


注意:


	给定的数组的大小在 [1, 1000] 之间。

最大二叉树 - 领扣 (LeetCode)
给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。

案例 1:


输入: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

输出: True




案例 2:


输入: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 28

输出: False



两数之和 IV - 输入 BST - 领扣 (LeetCode)
给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。

两棵树重复是指它们具有相同的结构以及相同的结点值。

示例 1：

        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4


下面是两个重复的子树：

      2
     /
    4


和

    4


因此，你需要以列表的形式返回上述重复子树的根结点。
寻找重复的子树 - 领扣 (LeetCode)
最初在一个记事本上只有一个字符 &#39;A&#39;。你每次可以对这个记事本进行两种操作：


	Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
	Paste (粘贴) : 你可以粘贴你上一次复制的字符。


给定一个数字n。你需要使用最少的操作次数，在记事本中打印出恰好n个 &#39;A&#39;。输出能够打印出n个 &#39;A&#39; 的最少操作次数。

示例 1:


输入: 3
输出: 3
解释:
最初, 我们只有一个字符 &#39;A&#39;。
第 1 步, 我们使用 Copy All 操作。
第 2 步, 我们使用 Paste 操作来获得 &#39;AA&#39;。
第 3 步, 我们使用 Paste 操作来获得 &#39;AAA&#39;。


说明:


	n的取值范围是 [1, 1000] 。

只有两个键的键盘 - 领扣 (LeetCode)
Dota2 的世界里有两个阵营：Radiant(天辉)和Dire(夜魇)

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：


	
	禁止一名参议员的权利：

	参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。
	
	
	
	宣布胜利：如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。
	


给定一个字符串代表每个参议员的阵营。字母&ldquo;R&rdquo;和&ldquo;D&rdquo;分别代表了Radiant(天辉)和Dire(夜魇)。然后，如果有 n 个参议员，给定字符串的大小将是n。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是Radiant或Dire。

示例 1:


输入: RD
输出: Radiant
解释:  第一个参议员来自  Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人




示例 2:


输入: RDD
输出: Dire
解释: 
第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利
第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止
第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利
因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利




注意:


	给定字符串的长度在 [1, 10,000] 之间.



Dota2 参议院 - 领扣 (LeetCode)
单词替换 - 领扣 (LeetCode)
在英语中，我们有一个叫做词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词&mdash;&mdash;我们称这个词为继承词(successor)。例如，词根an，跟随着单词other(其他)，可以形成新的单词another(另一个)。

现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。

你需要输出替换之后的句子。

示例 1:


输入: dict(词典) = [cat, bat, rat]
sentence(句子) = the cattle was rattled by the battery
输出: the cat was rat by the bat


注:


	输入只包含小写字母。
	1 <= 字典单词数 <=1000
	1 <= 句中词语数<= 1000
	1 <= 词根长度 <= 100
	1 <= 句中词语长度<= 1000

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。

示例 1:


输入: abc
输出: 3
解释: 三个回文子串: a, b, c.


示例 2:


输入: aaa
输出: 6
说明: 6个回文子串: a, a, a, aa, aa, aaa.


注意:


	输入的字符串长度不会超过1000。

回文子串 - 领扣 (LeetCode)
最长数对链 - 领扣 (LeetCode)
给出n个数对。在每一个数对中，第一个数字总是比第二个数字小。

现在，我们定义一种跟随关系，当且仅当b < c时，数对(c, d)才可以跟在(a, b)后面。我们用这种形式来构造一个数对链。

给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。

示例 :


输入: [[1,2], [2,3], [3,4]]
输出: 2
解释: 最长的数对链是 [1,2] -&gt; [3,4]


注意：


	给出数对的个数在[1, 1000] 范围内。

错误的集合 - 领扣 (LeetCode)
集合 S 包含从1到n的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。

给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

示例 1:


输入: nums = [1,2,2,4]
输出: [2,3]


注意:


	给定数组的长度范围是[2, 10000]。
	给定的数组是无序的。

给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。

示例 1:

输入: [1,12,-5,-6,50,3], k = 4
输出: 12.75
解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75




注意:


	1 <= k <= n <= 30,000。
	所给数据范围 [-10,000，10,000]。

子数组最大平均数 I - 领扣 (LeetCode)
求解一个给定的方程，将x以字符串x=#value的形式返回。该方程仅包含&#39;+&#39;，&#39; - &#39;操作，变量x和其对应系数。

如果方程没有解，请返回&ldquo;No solution&rdquo;。

如果方程有无限解，则返回&ldquo;Infinite solutions&rdquo;。

如果方程中只有一个解，要保证返回值x是一个整数。

示例 1：


输入: x+5-3+x=6+x-2
输出: x=2


示例 2:


输入: x=x
输出: Infinite solutions


示例 3:


输入: 2x=x
输出: x=0


示例 4:


输入: 2x+3x-6x=x+2
输出: x=-1


示例 5:


输入: x=x+2
输出: No solution

求解方程 - 领扣 (LeetCode)
解码方法 2 - 领扣 (LeetCode)
一条包含字母A-Z 的消息通过以下的方式进行了编码：

&#39;A&#39; -&gt; 1
&#39;B&#39; -&gt; 2
...
&#39;Z&#39; -&gt; 26


除了上述的条件以外，现在加密字符串可以包含字符 &#39;*&#39;了，字符&#39;*&#39;可以被当做1到9当中的任意一个数字。

给定一条包含数字和字符&#39;*&#39;的加密信息，请确定解码方法的总数。

同时，由于结果值可能会相当的大，所以你应当对109+ 7取模。（翻译者标注：此处取模主要是为了防止溢出）

示例 1 :

输入: *
输出: 9
解释: 加密的信息可以被解密为: A, B, C, D, E, F, G, H, I.


示例 2 :

输入: 1*
输出: 9 + 9 = 18（翻译者标注：这里1*可以分解为1,* 或者当做1*来处理，所以结果是9+9=18）


说明 :


	输入的字符串长度范围是 [1, 105]。
	输入的字符串只会包含字符 &#39;*&#39; 和 数字&#39;0&#39; - &#39;9&#39;。

大礼包 - 领扣 (LeetCode)
在LeetCode商店中， 有许多在售的物品。

然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。

现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。

每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。

任意大礼包可无限次购买。

示例 1:


输入: [2,5], [[3,0,5],[1,2,10]], [3,2]
输出: 14
解释: 
有A和B两种物品，价格分别为&yen;2和&yen;5。
大礼包1，你可以以&yen;5的价格购买3A和0B。
大礼包2， 你可以以&yen;10的价格购买1A和2B。
你需要购买3个A和2个B， 所以你付了&yen;10购买了1A和2B（大礼包2），以及&yen;4购买2A。

示例 2:


输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]
输出: 11
解释: 
A，B，C的价格分别为&yen;2，&yen;3，&yen;4.
你可以用&yen;4购买1A和2B，也可以用&yen;9购买2A，2B和1C。
你需要买1A，2B和1C，所以你付了&yen;4买了1A和1B（大礼包1），以及&yen;3购买1B， &yen;4购买1C。
你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。


说明:


	最多6种物品， 100种大礼包。
	每种物品，你最多只需要购买6个。
	你不可以购买超出待购清单的物品，即使更便宜。

二叉树的层平均值 - 领扣 (LeetCode)
给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.

示例 1:

输入:
    3
   / \
  9  20
    /  \
   15   7
输出: [3, 14.5, 11]
解释:
第0层的平均值是 3,  第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11].


注意：


	节点值的范围在32位有符号整数范围内。

函数的独占时间 - 领扣 (LeetCode)
给出一个非抢占单线程CPU的 n 个函数运行日志，找到函数的独占时间。

每个函数都有一个唯一的 Id，从 0 到 n-1，函数可能会递归调用或者被其他函数调用。

日志是具有以下格式的字符串：function_id：start_or_end：timestamp。例如：0:start:0表示函数 0 从 0 时刻开始运行。0:end:0表示函数 0 在 0 时刻结束。

函数的独占时间定义是在该方法中花费的时间，调用其他函数花费的时间不算该函数的独占时间。你需要根据函数的 Id 有序地返回每个函数的独占时间。

示例 1:

输入:
n = 2
logs = 
[0:start:0,
 1:start:2,
 1:end:5,
 0:end:6]
输出:[3, 4]
说明：
函数 0 在时刻 0 开始，在执行了  2个时间单位结束于时刻 1。
现在函数 0 调用函数 1，函数 1 在时刻 2 开始，执行 4 个时间单位后结束于时刻 5。
函数 0 再次在时刻 6 开始执行，并在时刻 6 结束运行，从而执行了 1 个时间单位。
所以函数 0 总共的执行了 2 +1 =3 个时间单位，函数 1 总共执行了 4 个时间单位。


说明：


	输入的日志会根据时间戳排序，而不是根据日志Id排序。
	你的输出会根据函数Id排序，也就意味着你的输出数组中序号为 0 的元素相当于函数 0 的执行时间。
	两个函数不会在同时开始或结束。
	函数允许被递归调用，直到运行结束。
	1 <= n <= 100

平方数之和 - 领扣 (LeetCode)
给定一个非负整数c，你要判断是否存在两个整数 a 和 b，使得a2 + b2 = c。

示例1:


输入: 5
输出: True
解释: 1 * 1 + 2 * 2 = 5




示例2:


输入: 3
输出: False

你有k个升序排列的整数数组。找到一个最小区间，使得k个列表中的每个列表至少有一个数包含在其中。

我们定义如果b-a < d-c或者在b-a == d-c时a < c，则区间 [a,b] 比 [c,d] 小。

示例 1:


输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
输出: [20,24]
解释: 
列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。
列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。
列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。


注意:


	给定的列表可能包含重复元素，所以在这里升序表示 &gt;= 。
	1 <= k <= 3500
	-105 <= 元素的值<= 105
	对于使用Java的用户，请注意传入类型已修改为List<List<Integer&gt;&gt;。重置代码模板后可以看到这项改动。

最小区间 - 领扣 (LeetCode)
课程表 III - 领扣 (LeetCode)
这里有 n 门不同的在线课程，他们按从 1 到 n编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d天。一门课要持续学习 t 天直到第 d 天时要完成，你将会从第 1 天开始。

给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。



示例：


输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出: 3
解释: 
这里一共有 4 门课程, 但是你最多可以修 3 门:
首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。
第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。
第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。
第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。



提示:


	整数 1 <= d, t, n <= 10,000 。
	你不能同时修两门课程。



K个逆序对数组 - 领扣 (LeetCode)
给出两个整数n和k，找出所有包含从1到n的数字，且恰好拥有k个逆序对的不同的数组的个数。

逆序对的定义如下：对于数组的第i个和第j个元素，如果满i<j且a[i]&gt;a[j]，则其为一个逆序对；否则不是。

由于答案可能很大，只需要返回 答案 mod 109+ 7 的值。

示例 1:


输入: n = 3, k = 0
输出: 1
解释: 
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。


示例 2:


输入: n = 3, k = 1
输出: 2
解释: 
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。


说明:


	n的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。

给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

示例 1:


输入: [1,2,3]
输出: 6


示例 2:


输入: [1,2,3,4]
输出: 24


注意:


	给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。
	输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。

三个数的最大乘积 - 领扣 (LeetCode)
给定一个salary表，如下所示，有m=男性 和 f=女性的值 。交换所有的 f 和 m 值(例如，将所有 f 值更改为 m，反之亦然)。要求使用一个更新查询，并且没有中间临时表。

例如:

| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |


运行你所编写的查询语句之后，将会得到以下表:

| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |

交换工资 - 领扣 (LeetCode)
小美是一所中学的信息科技老师，她有一张 seat座位表，平时用来储存学生名字和与他们相对应的座位 id。

其中纵列的id是连续递增的

小美想改变相邻俩学生的座位。

你能不能帮她写一个 SQL query来输出小美想要的结果呢？



示例：


+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Abbot   |
|    2    | Doris   |
|    3    | Emerson |
|    4    | Green   |
|    5    | Jeames  |
+---------+---------+


假如数据输入的是上表，则输出结果如下：


+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Doris   |
|    2    | Abbot   |
|    3    | Green   |
|    4    | Emerson |
|    5    | Jeames  |
+---------+---------+

注意：

如果学生人数是奇数，则不需要改变最后一个同学的座位。
换座位 - 领扣 (LeetCode)
给定一个二叉树，根节点为第1层，深度为 1。在其第d层追加一行值为v的节点。

添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为v的左子树和右子树。

将N 原先的左子树，连接为新节点v 的左子树；将N 原先的右子树，连接为新节点v 的右子树。

如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。

示例 1:


输入: 
二叉树如下所示:
       4
     /   \
    2     6
   / \   / 
  3   1 5   

v = 1

d = 2

输出: 
       4
      / \
     1   1
    /     \
   2       6
  / \     / 
 3   1   5   



示例 2:


输入: 
二叉树如下所示:
      4
     /   
    2    
   / \   
  3   1    

v = 1

d = 3

输出: 
      4
     /   
    2
   / \    
  1   1
 /     \  
3       1


注意:


	输入的深度值 d 的范围是：[1，二叉树最大深度 + 1]。
	输入的二叉树至少有一个节点。

在二叉树中增加一行 - 领扣 (LeetCode)
给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。

然而，两个相同种类的任务之间必须有长度为n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的最短时间。

示例 1：


输入: tasks = [A,A,A,B,B,B], n = 2
输出: 8
执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.


注：


	任务的总个数为[1, 10000]。
	n 的取值范围为 [0, 100]。

任务调度器 - 领扣 (LeetCode)
某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。

作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非boring(不无聊)的并且 id 为奇数的影片，结果请按等级 rating 排列。



例如，下表 cinema:


+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+


对于上面的例子，则正确的输出是为：


+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+



有趣的电影 - 领扣 (LeetCode)
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为NULL 的节点将直接作为新二叉树的节点。

示例1:


输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7


注意:合并必须从两个树的根节点开始。
合并二叉树 - 领扣 (LeetCode)
有效三角形的个数 - 领扣 (LeetCode)
给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

示例 1:


输入: [2,2,3,4]
输出: 3
解释:
有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3


注意:


	数组长度不超过1000。
	数组里整数的范围为 [0, 1000]。

给定一个目录信息列表，包括目录路径，以及该目录中的所有包含内容的文件，您需要找到文件系统中的所有重复文件组的路径。一组重复的文件至少包括二个具有完全相同内容的文件。

输入列表中的单个目录信息字符串的格式如下：

root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)

这意味着n档案（f1.txt,f2.txt...fn.txt有内容f1_content,f2_content...fn_content（分别）在目录root/d1/d2/.../dm 中注意，n&gt;=1 和 m&gt;=0。如果 m=0，则表示该目录只是根目录。

该输出是重复文件路径组的列表。对于每个组，它包含具有相同内容的文件的所有文件路径。文件路径是具有下列格式的字符串：

directory_path/file_name.txt

示例 1：


输入：
[root/a 1.txt(abcd) 2.txt(efgh), root/c 3.txt(abcd), root/c/d 4.txt(efgh), root 4.txt(efgh)]
输出：  
[[root/a/2.txt,root/c/d/4.txt,root/4.txt],[root/a/1.txt,root/c/3.txt]]




注：


	最终输出不需要顺序。
	您可以假设目录名、文件名和文件内容只有字母和数字，并且文件内容的长度在 [1，50] 的范围内。
	给定的文件数量在 [1，20000] 个范围内。
	您可以假设在同一目录中没有任何文件或目录共享相同的名称。
	您可以假设每个给定的目录信息代表一个唯一的目录。目录路径和文件信息用一个空格分隔。




超越竞赛的后续行动：


	假设您有一个真正的文件系统，您将如何搜索文件？广度搜索还是宽度搜索？
	如果文件内容非常大（GB级别），您将如何修改您的解决方案？
	如果每次只能读取 1 kb 的文件，您将如何修改解决方案？
	修改后的解决方案的时间复杂度是多少？其中最耗时的部分和消耗内存的部分是什么？如何优化？
	如何确保您发现的重复文件不是误报？

在系统中查找重复文件 - 领扣 (LeetCode)
根据二叉树创建字符串 - 领扣 (LeetCode)
你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。

空节点则用一对空括号 () 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。

示例 1:


输入: 二叉树: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

输出: 1(2(4))(3)

解释: 原本将是&ldquo;1(2(4)())(3())&rdquo;，
在你省略所有不必要的空括号对之后，
它将是&ldquo;1(2(4))(3)&rdquo;。


示例 2:


输入: 二叉树: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

输出: 1(2()(4))(3)

解释: 和第一个示例相似，
除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。

种花问题 - 领扣 (LeetCode)
假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数n。能否在不打破种植规则的情况下种入n朵花？能则返回True，不能则返回False。

示例 1:


输入: flowerbed = [1,0,0,0,1], n = 1
输出: True


示例 2:


输入: flowerbed = [1,0,0,0,1], n = 2
输出: False


注意:


	数组内已种好的花不会违反种植规则。
	输入的数组长度范围为 [1, 20000]。
	n 是非负整数，且不会超过输入数组的大小。

X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (date)、人流量 (people)。

请编写一个查询语句，找出高峰期时段，要求连续三天及以上，并且每天人流量均不少于100。

例如，表 stadium：

+------+------------+-----------+
| id   | date       | people    |
+------+------------+-----------+
| 1    | 2017-01-01 | 10        |
| 2    | 2017-01-02 | 109       |
| 3    | 2017-01-03 | 150       |
| 4    | 2017-01-04 | 99        |
| 5    | 2017-01-05 | 145       |
| 6    | 2017-01-06 | 1455      |
| 7    | 2017-01-07 | 199       |
| 8    | 2017-01-08 | 188       |
+------+------------+-----------+


对于上面的示例数据，输出为：

+------+------------+-----------+
| id   | date       | people    |
+------+------------+-----------+
| 5    | 2017-01-05 | 145       |
| 6    | 2017-01-06 | 1455      |
| 7    | 2017-01-07 | 199       |
| 8    | 2017-01-08 | 188       |
+------+------------+-----------+


Note:
每天只有一行记录，日期随着 id 的增加而增加。
体育馆的人流量 - 领扣 (LeetCode)
给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含连续的1的个数。

示例 1:

输入: 5
输出: 5
解释: 
下面是带有相应二进制表示的非负整数<= 5：
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。

说明: 1 <= n <= 109
不含连续1的非负整数 - 领扣 (LeetCode)
两个列表的最小索引总和 - 领扣 (LeetCode)
假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。

你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。

示例 1:

输入:
[Shogun, Tapioca Express, Burger King, KFC]
[Piatti, The Grill at Torrey Pines, Hungry Hunter Steakhouse, Shogun]
输出: [Shogun]
解释: 他们唯一共同喜爱的餐厅是&ldquo;Shogun&rdquo;。


示例 2:

输入:
[Shogun, Tapioca Express, Burger King, KFC]
[KFC, Shogun, Burger King]
输出: [Shogun]
解释: 他们共同喜爱且具有最小索引和的餐厅是&ldquo;Shogun&rdquo;，它有最小的索引和1(0+1)。


提示:


	两个列表的长度范围都在[1, 1000]内。
	两个列表中的字符串的长度将在[1，30]的范围内。
	下标从0开始，到列表的长度减1。
	两个列表都没有重复的元素。

给定一个初始元素全部为0，大小为 m*n 的矩阵M以及在M上的一系列更新操作。

操作用二维数组表示，其中的每个操作用一个含有两个正整数a 和 b 的数组表示，含义是将所有符合0 <= i < a 以及 0 <= j < b 的元素M[i][j]的值都增加 1。

在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。

示例 1:


输入: 
m = 3, n = 3
operations = [[2,2],[3,3]]
输出: 4
解释: 
初始状态, M = 
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]

执行完操作 [2,2] 后, M = 
[[1, 1, 0],
 [1, 1, 0],
 [0, 0, 0]]

执行完操作 [3,3] 后, M = 
[[2, 2, 1],
 [2, 2, 1],
 [1, 1, 1]]

M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。


注意:


	m 和 n 的范围是[1,40000]。
	a 的范围是 [1,m]，b 的范围是 [1,n]。
	操作数目不超过 10000。

范围求和 II - 领扣 (LeetCode)
超过5名学生的课 - 领扣 (LeetCode)
有一个courses 表 ，有: student(学生) 和 class (课程)。

请列出所有超过或等于5名学生的课。

例如,表:


+---------+------------+
| student | class      |
+---------+------------+
| A       | Math       |
| B       | English    |
| C       | Math       |
| D       | Biology    |
| E       | Math       |
| F       | Computer   |
| G       | Math       |
| H       | Math       |
| I       | Math       |
+---------+------------+


应该输出:


+---------+
| class   |
+---------+
| Math    |
+---------+


Note:
学生在每个课中不应被重复计算。
大的国家 - 领扣 (LeetCode)
这里有张World 表

+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+


如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。

编写一个SQL查询，输出表中所有大国家的名称、人口和面积。

例如，根据上表，我们应该输出:

+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+

和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。

现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。

示例 1:


输入: [1,3,2,2,5,2,3,7]
输出: 5
原因: 最长的和谐数组是：[3,2,2,2,3].


说明: 输入的数组长度最大不超过20,000.
最长和谐子序列 - 领扣 (LeetCode)
有效的正方形 - 领扣 (LeetCode)
给定二维空间中四点的坐标，返回四点是否可以构造一个正方形。

一个点的坐标（x，y）由一个有两个整数的整数数组表示。

示例:


输入: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]
输出: True




注意:


	所有输入整数都在 [-10000，10000] 范围内。
	一个有效的正方形有四个等长的正长和四个等角（90度角）。
	输入点没有顺序。

给定一个表示分数加减运算表达式的字符串，你需要返回一个字符串形式的计算结果。这个结果应该是不可约分的分数，即最简分数。如果最终结果是一个整数，例如2，你需要将它转换成分数形式，其分母为1。所以在上述例子中, 2应该被转换为2/1。

示例1:


输入:-1/2+1/2
输出: 0/1


示例 2:


输入:-1/2+1/2+1/3
输出: 1/3


示例 3:


输入:1/3-1/2
输出: -1/6


示例 4:


输入:5/3+1/3
输出: 2/1


说明:


	输入和输出字符串只包含&#39;0&#39; 到&#39;9&#39;的数字，以及&#39;/&#39;, &#39;+&#39; 和&#39;-&#39;。
	输入和输出分数格式均为&plusmn;分子/分母。如果输入的第一个分数或者输出的分数是正数，则&#39;+&#39;会被省略掉。
	输入只包含合法的最简分数，每个分数的分子与分母的范围是[1,10]。如果分母是1，意味着这个分数实际上是一个整数。
	输入的分数个数范围是 [1,10]。
	最终结果的分子与分母保证是 32 位整数范围内的有效整数。

分数加减运算 - 领扣 (LeetCode)
标签验证器 - 领扣 (LeetCode)
给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：


	代码必须被合法的闭合标签包围。否则，代码是无效的。
	闭合标签（不一定合法）要严格符合格式：<TAG_NAME&gt;TAG_CONTENT</TAG_NAME&gt;。其中，<TAG_NAME&gt;是起始标签，</TAG_NAME&gt;是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是合法的。
	合法的TAG_NAME仅含有大写字母，长度在范围 [1,9] 之间。否则，该TAG_NAME是不合法的。
	合法的TAG_CONTENT可以包含其他合法的闭合标签，cdata（请参考规则7）和任意字符（注意参考规则1）除了不匹配的<、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，TAG_CONTENT是不合法的。
	一个起始标签，如果没有具有相同TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。
	一个<，如果你找不到一个后续的&gt;与之匹配，是不合法的。并且当你找到一个<或</时，所有直到下一个&gt;的前的字符，都应当被解析为TAG_NAME（不一定合法）。
	cdata 有如下格式：<![CDATA[CDATA_CONTENT]]&gt;。CDATA_CONTENT的范围被定义成<![CDATA[和后续的第一个]]&gt;之间的字符。
	CDATA_CONTENT可以包含任意字符。cdata 的功能是阻止验证器解析CDATA_CONTENT，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为常规字符。


合法代码的例子:


输入: <DIV&gt;This is the first line <![CDATA[<div&gt;]]&gt;</DIV&gt;

输出: True

解释: 

代码被包含在了闭合的标签内： <DIV&gt; 和 </DIV&gt; 。

TAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 

即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。

所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。


输入: <DIV&gt;&gt;&gt;  ![cdata[]] <![CDATA[<div&gt;]&gt;]]&gt;]]&gt;&gt;]</DIV&gt;

输出: True

解释:

我们首先将代码分割为： start_tag|tag_content|end_tag 。

start_tag -&gt; <DIV&gt;

end_tag -&gt; </DIV&gt;

tag_content 也可被分割为： text1|cdata|text2 。

text1 -&gt; &gt;&gt;  ![cdata[]] 

cdata -&gt; <![CDATA[<div&gt;]&gt;]]&gt; ，其中 CDATA_CONTENT 为 <div&gt;]&gt;

text2 -&gt; ]]&gt;&gt;]


start_tag 不是 <DIV&gt;&gt;&gt; 的原因参照规则 6 。
cdata 不是 <![CDATA[<div&gt;]&gt;]]&gt;]]&gt; 的原因参照规则 7 。


不合法代码的例子:


输入: <A&gt;  <B&gt; </A&gt;   </B&gt;
输出: False
解释: 不合法。如果 <A&gt; 是闭合的，那么 <B&gt; 一定是不匹配的，反之亦然。

输入: <DIV&gt;  div tag is not closed  <DIV&gt;
输出: False

输入: <DIV&gt;  unmatched <  </DIV&gt;
输出: False

输入: <DIV&gt; closed tags with invalid tag name  <b&gt;123</b&gt; </DIV&gt;
输出: False

输入: <DIV&gt; unmatched tags with invalid tag name  </1234567890&gt; and <CDATA[[]]&gt;  </DIV&gt;
输出: False

输入: <DIV&gt;  unmatched start tag <B&gt;  and unmatched end tag </C&gt;  </DIV&gt;
输出: False


注意:


	为简明起见，你可以假设输入的代码（包括提到的任意字符）只包含数字, 字母, &#39;<&#39;,&#39;&gt;&#39;,&#39;/&#39;,&#39;!&#39;,&#39;[&#39;,&#39;]&#39;和&#39; &#39;。

安装栅栏 - 领扣 (LeetCode)
在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。







示例 1:



输入: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]

输出: [[1,1],[2,0],[4,2],[3,3],[2,4]]

解释:







示例 2:



输入: [[1,2],[2,2],[4,2]]

输出: [[1,2],[2,2],[4,2]]

解释:



即使树都在一条直线上，你也需要先用绳子包围它们。









注意:





	所有的树应当被围在一起。你不能剪断绳子来包围树或者把树分成一组以上。

	输入的整数在 0 到 100 之间。

	花园至少有一棵树。

	所有树的坐标都是不同的。

	输入的点没有顺序。输出顺序也没有要求。

两个字符串的删除操作 - 领扣 (LeetCode)
给定两个单词word1和word2，找到使得word1和word2相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

示例 1:


输入: sea, eat
输出: 2
解释: 第一步将sea变为ea，第二步将eat变为ea


说明:


	给定单词的长度不超过500。
	给定单词中的字符只含有小写字母。

给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

你找到的子数组应是最短的，请输出它的长度。

示例 1:


输入: [2, 6, 4, 8, 10, 9, 15]
输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。


说明 :


	输入的数组长度范围在[1, 10,000]。
	输入的数组可能包含重复元素，所以升序的意思是<=。

最短无序连续子数组 - 领扣 (LeetCode)
出界的路径数 - 领扣 (LeetCode)
给定一个 m &times; n 的网格和一个球。球的起始坐标为(i,j)，你可以将球移到相邻的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你最多可以移动N次。找出可以将球移出边界的路径数量。答案可能非常大，返回 结果 mod 109+ 7 的值。







示例 1：



输入: m = 2, n = 2, N = 2, i = 0, j = 0

输出: 6

解释:







示例 2：



输入: m = 1, n = 3, N = 3, i = 0, j = 1

输出: 12

解释:











说明:





	球一旦出界，就不能再被移动回网格内。

	网格的长度和高度在 [1,50] 的范围内。

	N 在 [0,50] 的范围内。

给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。

示例 1:


输入: candies = [1,1,2,2,3,3]
输出: 3
解析: 一共有三种种类的糖果，每一种都有两个。
     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。


示例 2 :


输入: candies = [1,1,2,3]
输出: 2
解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。


注意:


	数组的长度为[2, 10,000]，并且确定为偶数。
	数组中数字的大小在范围[-100,000, 100,000]内。
	
	
	

分糖果 - 领扣 (LeetCode)
另一个树的子树 - 领扣 (LeetCode)
给定两个非空二叉树 s 和 t，检验s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

示例 1:
给定的树 s:


     3
    / \
   4   5
  / \
 1   2


给定的树 t：


   4 
  / \
 1   2


返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。

示例 2:
给定的树 s：


     3
    / \
   4   5
  / \
 1   2
    /
   0


给定的树 t：


   4
  / \
 1   2


返回 false。
给定两个字符串s1和s2，写一个函数来判断 s2 是否包含 s1的排列。

换句话说，第一个字符串的排列之一是第二个字符串的子串。

示例1:


输入: s1 = ab s2 = eidbaooo
输出: True
解释: s2 包含 s1 的排列之一 (ba).




示例2:


输入: s1= ab s2 = eidboaoo
输出: False




注意：


	输入的字符串只包含小写字母
	两个字符串的长度都在 [1, 10,000] 之间

字符串的排列 - 领扣 (LeetCode)
在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。

给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。

如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

示例 1:


输入: 
nums = 
[[1,2],
 [3,4]]
r = 1, c = 4
输出: 
[[1,2,3,4]]
解释:
行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。


示例 2:


输入: 
nums = 
[[1,2],
 [3,4]]
r = 2, c = 4
输出: 
[[1,2],
 [3,4]]
解释:
没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。


注意：


	给定矩阵的宽和高范围在 [1, 100]。
	给定的 r 和 c 都是正数。

重塑矩阵 - 领扣 (LeetCode)
索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到并返回最大的集合S，S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }且遵守以下的规则。

假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]... 以此类推，不断添加直到S出现重复的元素。

示例1:


输入: A = [5,4,0,3,1,6,2]
输出: 4
解释: 
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

其中一种最长的 S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}


注意:


	N是[1, 20,000]之间的整数。
	A中不含有重复的元素。
	A中的元素大小在[0, N-1]之间。

数组嵌套 - 领扣 (LeetCode)
给定一个整数 n ，你需要找到与它最近的回文数（不包括自身）。

&ldquo;最近的&rdquo;定义为两个整数差的绝对值最小。

示例 1:


输入: 123
输出: 121


注意:


	n 是由字符串表示的正整数，其长度不超过18。
	如果有多个结果，返回最小的那个。

寻找最近的回文数 - 领扣 (LeetCode)
二叉树的坡度 - 领扣 (LeetCode)
给定一个二叉树，计算整个树的坡度。

一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。

整个树的坡度就是其所有节点的坡度之和。

示例:


输入: 
         1
       /   \
      2     3
输出: 1
解释: 
结点的坡度 2 : 0
结点的坡度 3 : 0
结点的坡度 1 : |2-3| = 1
树的坡度 : 0 + 0 + 1 = 1


注意:


	任何子树的结点的和不会超过32位整数的范围。
	坡度的值不会超过32位整数的范围。

数组拆分 I - 领扣 (LeetCode)
给定长度为2n的数组, 你的任务是将这些数分成n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从1 到n 的 min(ai, bi) 总和最大。

示例 1:


输入: [1,4,3,2]

输出: 4
解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).


提示:


	n是正整数,范围在 [1, 10000].
	数组中的元素范围在 [-10000, 10000].

给定一个整数数组和一个整数k，你需要找到该数组中和为k的连续的子数组的个数。

示例 1 :


输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。


说明 :


	数组的长度为 [1, 20,000]。
	数组中元素的范围是 [-1000, 1000] ，且整数k的范围是[-1e7, 1e7]。

和为K的子数组 - 领扣 (LeetCode)
给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

示例1:


输入: Let&#39;s take LeetCode contest
输出: s&#39;teL ekat edoCteeL tsetnoc


注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。
反转字符串中的单词 III - 领扣 (LeetCode)
给定一个32位正整数n，你需要找到最小的32位整数，其与n中存在的位数完全相同，并且其值大于n。如果不存在这样的32位整数，则返回-1。

示例 1:


输入: 12
输出: 21


示例 2:


输入: 21
输出: -1

下一个更大元素 III - 领扣 (LeetCode)
你的面前有一堵方形的、由多行砖块组成的砖墙。这些砖块高度相同但是宽度不同。你现在要画一条自顶向下的、穿过最少砖块的垂线。



砖墙由行的列表表示。 每一行都是一个代表从左至右每块砖的宽度的整数列表。



如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你需要找出怎样画才能使这条线穿过的砖块数量最少，并且返回穿过的砖块数量。



你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。







示例：



输入: [[1,2,2,1],

      [3,1,2],

      [1,3,2],

      [2,4],

      [3,1,2],

      [1,3,1,1]]



输出: 2



解释: 











提示：





	每一行砖块的宽度之和应该相等，并且不能超过 INT_MAX。

	每一行砖块的数量在[1,10,000] 范围内，墙的高度在[1,10,000] 范围内，总的砖块数量不超过 20,000。

砖墙 - 领扣 (LeetCode)
最优除法 - 领扣 (LeetCode)
给定一组正整数，相邻的整数之间将会进行浮点除法操作。例如，[2,3,4] -&gt; 2 / 3 / 4 。

但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到最大的结果，并且返回相应的字符串格式的表达式。你的表达式不应该含有冗余的括号。

示例：


输入: [1000,100,10,2]
输出: 1000/(100/10/2)
解释:
1000/(100/10/2) = 1000/((100/10)/2) = 200
但是，以下加粗的括号 1000/((100/10)/2) 是冗余的，
因为他们并不影响操作的优先级，所以你需要返回 1000/(100/10/2)。

其他用例:
1000/(100/10)/2 = 50
1000/(100/(10/2)) = 50
1000/100/10/2 = 0.5
1000/100/(10/2) = 2


说明:


	输入数组的长度在 [1, 10] 之间。
	数组中每个元素的大小都在 [2, 1000] 之间。
	每个测试用例只有一个最优除法解。

学生出勤记录 II - 领扣 (LeetCode)
给定一个正整数n，返回长度为 n 的所有可被视为可奖励的出勤记录的数量。 答案可能非常大，你只需返回结果mod 109 + 7的值。

学生出勤记录是只包含以下三个字符的字符串：


	&#39;A&#39; : Absent，缺勤
	&#39;L&#39; : Late，迟到
	&#39;P&#39; : Present，到场


如果记录不包含多于一个&#39;A&#39;（缺勤）或超过两个连续的&#39;L&#39;（迟到），则该记录被视为可奖励的。

示例 1:


输入: n = 2
输出: 8 
解释：
有8个长度为2的记录将被视为可奖励：
PP , AP, PA, LP, PL, AL, LA, LL
只有AA不会被视为可奖励，因为缺勤次数超过一次。

注意：n 的值不会超过100000。
给定一个字符串来代表一个学生的出勤纪录，这个纪录仅包含以下三个字符：


	&#39;A&#39; : Absent，缺勤
	&#39;L&#39; : Late，迟到
	&#39;P&#39; : Present，到场


如果一个学生的出勤纪录中不超过一个&#39;A&#39;(缺勤)并且不超过两个连续的&#39;L&#39;(迟到),那么这个学生会被奖赏。

你需要根据这个学生的出勤纪录判断他是否会被奖赏。

示例 1:


输入: PPALLP
输出: True


示例 2:


输入: PPALLL
输出: False

学生出勤纪录 I - 领扣 (LeetCode)
朋友圈 - 领扣 (LeetCode)
班上有N名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B的朋友，B 是 C的朋友，那么我们可以认为 A 也是 C的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个N * N的矩阵M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

示例 1:


输入: 
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出: 2 
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回2。


示例 2:


输入: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。


注意：


	N 在[1,200]的范围内。
	对于所有学生，有M[i][i] = 1。
	如果有M[i][j] = 1，则有M[j][i] = 1。

移除盒子 - 领扣 (LeetCode)
给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。
你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k&gt;= 1），这样一轮之后你将得到 k*k 个积分。
当你将所有盒子都去掉之后，求你能获得的最大积分和。

示例 1：
输入:


[1, 3, 2, 2, 2, 3, 4, 3, 1]


输出:


23


解释:


[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----&gt; [1, 3, 3, 4, 3, 1] (3*3=9 分) 
----&gt; [1, 3, 3, 3, 1] (1*1=1 分) 
----&gt; [1, 1] (3*3=9 分) 
----&gt; [] (2*2=4 分)




提示：盒子的总数 n 不会超过 100。
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。

示例 :
给定二叉树


          1
         / \
        2   3
       / \     
      4   5    


返回3, 它的长度是路径 [4,2,1,3] 或者[5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。
二叉树的直径 - 领扣 (LeetCode)
给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。

两个相邻元素间的距离为 1 。

示例 1: 
输入:


0 0 0
0 1 0
0 0 0


输出:


0 0 0
0 1 0
0 0 0


示例 2: 
输入:


0 0 0
0 1 0
1 1 1


输出:


0 0 0
0 1 0
1 2 1


注意:


	给定矩阵的元素个数不超过 10000。
	给定矩阵中至少有一个元素是 0。
	矩阵中的元素只在四个方向上相邻: 上、下、左、右。

01 矩阵 - 领扣 (LeetCode)
反转字符串 II - 领扣 (LeetCode)
给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。

示例:


输入: s = abcdefg, k = 2
输出: bacdfeg


要求:


	该字符串只包含小写的英文字母。
	给定字符串的长度和 k 在[1, 10000]范围内。

有序数组中的单一元素 - 领扣 (LeetCode)
给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。

示例 1:


输入: [1,1,2,3,3,4,4,8,8]
输出: 2


示例 2:


输入: [3,3,7,7,10,11,11]
输出: 10


注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。
给定一个 24 小时制（小时:分钟）的时间列表，找出列表中任意两个时间的最小时间差并已分钟数表示。


示例 1：


输入: [23:59,00:00]
输出: 1



备注:


	列表中时间数在 2~20000 之间。
	每个时间取值在 00:00~23:59 之间。

最小时间差 - 领扣 (LeetCode)
把二叉搜索树转换为累加树 - 领扣 (LeetCode)
给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

例如：


输入: 二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13

给定两个表示复数的字符串。

返回表示它们乘积的字符串。注意，根据定义 i2 = -1 。

示例 1:


输入: 1+1i, 1+1i
输出: 0+2i
解释: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。


示例 2:


输入: 1+-1i, 1+-1i
输出: 0+-2i
解释: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 


注意:


	输入字符串不包含额外的空格。
	输入字符串将以a+bi 的形式给出，其中整数 a 和 b 的范围均在 [-100, 100] 之间。输出也应当符合这种形式。

复数乘法 - 领扣 (LeetCode)
TinyURL是一种URL简化服务， 比如：当你输入一个URLhttps://leetcode.com/problems/design-tinyurl时，它将返回一个简化的URLhttp://tinyurl.com/4e9iAk.

要求：设计一个 TinyURL 的加密encode和解密decode的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。
TinyURL 的加密与解密 - 领扣 (LeetCode)
数组中的K-diff数对 - 领扣 (LeetCode)
给定一个整数数组和一个整数k, 你需要在数组里找到不同的k-diff 数对。这里将k-diff数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是k.

示例 1:


输入: [3, 1, 4, 1, 5], k = 2
输出: 2
解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。
尽管数组中有两个1，但我们只应返回不同的数对的数量。


示例2:


输入:[1, 2, 3, 4, 5], k = 1
输出: 4
解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。


示例 3:


输入: [1, 3, 1, 5, 4], k = 0
输出: 1
解释: 数组中只有一个 0-diff 数对，(1, 1)。


注意:


	数对 (i, j) 和数对(j, i) 被算作同一数对。
	数组的长度不超过10,000。
	所有输入的整数的范围在[-1e7, 1e7]。

给定一个所有节点为非负值的二叉搜索树，求树中任意两节点的差的绝对值的最小值。

示例 :


输入:

   1
    \
     3
    /
   2

输出:
1

解释:
最小绝对差为1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。


注意: 树中至少有2个节点。
二叉搜索树的最小绝对差 - 领扣 (LeetCode)
让我们一起来玩扫雷游戏！



给定一个代表游戏板的二维字符矩阵。&#39;M&#39;代表一个未挖出的地雷，&#39;E&#39;代表一个未挖出的空方块，&#39;B&#39;代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（&#39;1&#39; 到 &#39;8&#39;）表示有多少地雷与这块已挖出的方块相邻，&#39;X&#39;则表示一个已挖出的地雷。



现在给出在所有未挖出的方块中（&#39;M&#39;或者&#39;E&#39;）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：





	如果一个地雷（&#39;M&#39;）被挖出，游戏就结束了- 把它改为&#39;X&#39;。

	如果一个没有相邻地雷的空方块（&#39;E&#39;）被挖出，修改它为（&#39;B&#39;），并且所有和其相邻的方块都应该被递归地揭露。

	如果一个至少与一个地雷相邻的空方块（&#39;E&#39;）被挖出，修改它为数字（&#39;1&#39;到&#39;8&#39;），表示相邻地雷的数量。

	如果在此次点击中，若无更多方块可被揭露，则返回面板。









示例 1：



输入: 



[[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],

 [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],

 [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],

 [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]



Click : [3,0]



输出: 



[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],

 [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],

 [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],

 [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]



解释:







示例 2：



输入: 



[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],

 [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],

 [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],

 [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]



Click : [1,2]



输出: 



[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],

 [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],

 [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],

 [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]



解释:











注意：





	输入矩阵的宽和高的范围为 [1,50]。

	点击的位置只能是未被挖出的方块 (&#39;M&#39; 或者 &#39;E&#39;)，这也意味着面板至少包含一个可点击的方块。

	输入面板不会是游戏结束的状态（即有地雷已被挖出）。

	简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。

扫雷游戏 - 领扣 (LeetCode)
假设有从 1 到 N 的N个整数，如果从这N个数字中成功构造出一个数组，使得数组的第 i位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：


	第i位的数字能被i整除
	i 能被第 i 位上的数字整除


现在给定一个整数 N，请问可以构造多少个优美的排列？

示例1:


输入: 2
输出: 2
解释: 

第 1 个优美的排列是 [1, 2]:
  第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除

第 2 个优美的排列是 [2, 1]:
  第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除


说明:


	N 是一个正整数，并且不会超过15。

优美的排列 - 领扣 (LeetCode)
给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组。

示例 1:


输入: [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。

示例 2:


输入: [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。

注意:给定的二进制数组的长度不会超过50000。
连续数组 - 领扣 (LeetCode)
给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。

示例 1:


输入:
s = abpcplea, d = [ale,apple,monkey,plea]

输出: 
apple


示例2:


输入:
s = abpcplea, d = [a,b,c]

输出: 
a


说明:


	所有输入的字符串只包含小写字母。
	字典的大小不会超过 1000。
	所有输入的字符串长度不会超过 1000。

通过删除字母匹配到字典里最长单词 - 领扣 (LeetCode)
连续的子数组和 - 领扣 (LeetCode)
给定一个包含非负数的数组和一个目标整数k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。

示例 1:

输入: [23,2,4,6,7], k = 6
输出: True
解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。


示例 2:

输入: [23,2,6,4,7], k = 6
输出: True
解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。


说明:


	数组的长度不会超过10,000。
	你可以认为所有数字总和在 32 位有符号整数范围内。

最长特殊序列 II - 领扣 (LeetCode)
给定字符串列表，你需要从它们中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。

子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。

输入将是一个字符串列表，输出是最长特殊序列的长度。如果最长特殊序列不存在，返回 -1 。



示例：

输入: aba, cdc, eae
输出: 3




提示：


	所有给定的字符串长度不会超过 10 。
	给定字符串列表的长度将在 [2, 50 ] 之间。



最长特殊序列 Ⅰ - 领扣 (LeetCode)
给定两个字符串，你需要从这两个字符串中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。

子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。

输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。

示例 :

输入: aba, cdc
输出: 3
解析: 最长特殊序列可为 aba (或 cdc)


说明:


	两个字符串长度均小于100。
	字符串中的字符仅含有&#39;a&#39;~&#39;z&#39;。

给定一个单词，你需要判断单词的大写使用是否正确。

我们定义，在以下情况时，单词的大写用法是正确的：


	全部字母都是大写，比如USA。
	单词中所有字母都不是大写，比如leetcode。
	如果单词不只含有一个字母，只有首字母大写，比如Google。


否则，我们定义这个单词没有正确使用大写字母。

示例 1:


输入: USA
输出: True


示例 2:


输入: FlaG
输出: False


注意: 输入是由大写和小写拉丁字母组成的非空单词。
检测大写字母 - 领扣 (LeetCode)
零钱兑换 II - 领扣 (LeetCode)
给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

注意:你可以假设


	0 <= amount (总金额) <= 5000
	1 <= coin (硬币面额)<= 5000
	硬币种类不超过500种
	结果符合32位符号整数


示例 1:

输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1


示例 2:

输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。


示例 3:

输入: amount = 10, coins = [10] 
输出: 1

超级洗衣机 - 领扣 (LeetCode)
假设有 n台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。

在每一步操作中，你可以选择任意 m（1 &le; m &le; n）台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。

给定一个非负整数数组代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的最少的操作步数。如果不能使每台洗衣机中衣物的数量相等，则返回 -1。



示例 1：

输入: [1,0,5]

输出: 3

解释: 
第一步:    1     0 <-- 5    =&gt;    1     1     4
第二步:    1 <-- 1 <-- 4    =&gt;    2     1     3    
第三步:    2     1 <-- 3    =&gt;    2     2     2   


示例 2：

输入: [0,3,0]

输出: 2

解释: 
第一步:    0 <-- 3     0    =&gt;    1     2     0    
第二步:    1     2 --&gt; 0    =&gt;    1     1     1     


示例 3:

输入: [0,2,0]

输出: -1

解释: 
不可能让所有三个洗衣机同时剩下相同数量的衣物。




提示：


	n 的范围是 [1, 10000]。
	在每台超级洗衣机中，衣物数量的范围是 [0, 1e5]。



给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。

示例 1:
输入:


bbbab


输出:


4


一个可能的最长回文子序列为 bbbb。

示例 2:
输入:


cbbd


输出:


2


一个可能的最长回文子序列为 bb。
最长回文子序列 - 领扣 (LeetCode)
您需要在二叉树的每一行中找到最大的值。

示例：


输入: 

          1
         / \
        3   2
       / \   \  
      5   3   9 

输出: [1, 3, 9]

在每个树行中找最大值 - 领扣 (LeetCode)
自由之路 - 领扣 (LeetCode)
视频游戏&ldquo;辐射4&rdquo;中，任务&ldquo;通向自由&rdquo;要求玩家到达名为&ldquo;Freedom Trail Ring&rdquo;的金属表盘，并使用表盘拼写特定关键词才能开门。



给定一个字符串ring，表示刻在外环上的编码；给定另一个字符串key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。



最初，ring的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使key的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完key中的所有字符。



旋转ring拼出 key 字符key[i]的阶段中：





	您可以将ring顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串ring的一个字符与 12:00 方向对齐，并且这个字符必须等于字符key[i] 。

	如果字符key[i]已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作1 步。按完之后，您可以开始拼写key的下一个字符（下一阶段）, 直至完成所有拼写。





示例：













输入: ring = godding, key = gd

输出: 4

解释:

 对于 key 的第一个字符 &#39;g&#39;，已经在正确的位置, 我们只需要1步来拼写这个字符。 

 对于 key 的第二个字符 &#39;d&#39;，我们需要逆时针旋转 ring godding 2步使它变成 ddinggo。

 当然, 我们还需要1步进行拼写。

 因此最终的输出是 4。





提示：





	ring 和key的字符串长度取值范围均为1 至100；

	两个字符串中都只有小写字符，并且均可能存在重复字符；

	字符串key一定可以由字符串 ring旋转拼出。

给定一个二叉树，在树的最后一行找到最左边的值。

示例 1:


输入:

    2
   / \
  1   3

输出:
1




示例 2: 


输入:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

输出:
7




注意: 您可以假设树（即给定的根节点）不为 NULL。
找树左下角的值 - 领扣 (LeetCode)
出现次数最多的子树元素和 - 领扣 (LeetCode)
给出二叉树的根，找出出现次数最多的子树元素和。一个结点的子树元素和定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。然后求出出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的元素（不限顺序）。



示例 1
输入:

  5
 /  \
2   -3


返回[2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。

示例2
输入:

  5
 /  \
2   -5


返回[2]，只有 2 出现两次，-5 只出现 1 次。



提示：假设任意子树元素和均可以用 32 位有符号整数表示。
完美数 - 领扣 (LeetCode)
对于一个正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为&ldquo;完美数&rdquo;。

给定一个正整数n，如果他是完美数，返回True，否则返回False



示例：


输入: 28
输出: True
解释: 28 = 1 + 2 + 4 + 7 + 14




注意:

输入的数字n 不会超过 100,000,000. (1e8)
给出N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 &ldquo;金牌&rdquo;，&ldquo;银牌&rdquo; 和&ldquo; 铜牌&rdquo;（Gold Medal, Silver Medal, Bronze Medal）。

(注：分数越高的选手，排名越靠前。)

示例 1:


输入: [5, 4, 3, 2, 1]
输出: [Gold Medal, Silver Medal, Bronze Medal, 4, 5]
解释: 前三名运动员的成绩为前三高的，因此将会分别被授予 &ldquo;金牌&rdquo;，&ldquo;银牌&rdquo;和&ldquo;铜牌&rdquo; (Gold Medal, Silver Medal and Bronze Medal).
余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。

提示:


	N 是一个正整数并且不会超过10000。
	所有运动员的成绩都不相同。

相对名次 - 领扣 (LeetCode)
给定一个整数，将其转化为7进制，并以字符串形式输出。

示例 1:


输入: 100
输出: 202


示例 2:


输入: -7
输出: -10


注意: 输入范围是[-1e7, 1e7] 。
七进制数 - 领扣 (LeetCode)
给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

示例 1:


输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。


注意: 输入数组的长度不会超过 10000。
下一个更大元素 II - 领扣 (LeetCode)
IPO - 领扣 (LeetCode)
假设 LeetCode 即将开始其 IPO。为了以更高的价格将股票卖给风险投资公司，LeetCode希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 LeetCode 设计完成最多 k 个不同项目后得到最大总资本的方式。

给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。

总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。

示例 1:


输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].

输出: 4

解释:
由于你的初始资本为 0，你尽可以从 0 号项目开始。
在完成后，你将获得 1 的利润，你的总资本将变为 1。
此时你可以选择开始 1 号或 2 号项目。
由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。




注意:


	假设所有输入数字都是非负整数。
	表示利润和资本的数组的长度不超过 50000。
	答案保证在 32 位有符号整数范围内。



二叉搜索树中的众数 - 领扣 (LeetCode)
给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：


	结点左子树中所含结点的值小于等于当前结点的值
	结点右子树中所含结点的值大于等于当前结点的值
	左子树和右子树都是二叉搜索树


例如：
给定 BST [1,null,2,2],

   1
    \
     2
    /
   2


返回[2].

提示：如果众数超过1个，不需考虑输出顺序

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）
给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。















示例：



输入: [Hello, Alaska, Dad, Peace]

输出: [Alaska, Dad]









注意：





	你可以重复使用键盘上同一字符。

	你可以假设输入的字符串将只包含字母。

键盘行 - 领扣 (LeetCode)
给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。



示例:

输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

解释:





说明:


	给定矩阵中的元素总数不会超过 100000 。

对角线遍历 - 领扣 (LeetCode)
给定两个没有重复元素的数组nums1 和nums2，其中nums1是nums2的子集。找到nums1中每个元素在nums2中的下一个比其大的值。

nums1中数字x的下一个更大元素是指x在nums2中对应位置的右边的第一个比x大的元素。如果不存在，对应位置输出-1。

示例 1:


输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。

示例 2:


输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
   对于num1中的数字2，第二个数组中的下一个较大数字是3。
    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。


注意:


	nums1和nums2中所有元素是唯一的。
	nums1和nums2的数组大小都不超过1000。

下一个更大元素 I - 领扣 (LeetCode)
在《英雄联盟》的世界中，有一个叫 &ldquo;提莫&rdquo; 的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。

你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。

示例1:

输入: [1,4], 2
输出: 4
原因: 在第 1 秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒钟结束。
在第 4 秒开始时，提莫再次攻击艾希，使得艾希获得另外 2 秒的中毒时间。
所以最终输出 4 秒。


示例2:

输入: [1,2], 2
输出: 3
原因: 在第 1 秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒钟结束。
但是在第 2 秒开始时，提莫再次攻击了已经处于中毒状态的艾希。
由于中毒状态不可叠加，提莫在第 2 秒开始时的这次攻击会在第 3 秒钟结束。
所以最终输出 3。


注意：


	你可以假定时间序列数组的总长度不超过 10000。
	你可以假定提莫攻击时间序列中的数字和提莫攻击的中毒持续时间都是非负整数，并且不超过 10,000,000。

提莫攻击 - 领扣 (LeetCode)
目标和 - 领扣 (LeetCode)
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号+和-。对于数组中的任意一个整数，你都可以从+或-中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

示例 1:


输入: nums: [1, 1, 1, 1, 1], S: 3
输出: 5
解释: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。


注意:


	数组的长度不会超过20，并且数组中的值全为正数。
	初始的数组的和不会超过1000。
	保证返回的最终结果为32位整数。

给定一个数组nums，如果i < j且nums[i] &gt; 2*nums[j]我们就将(i, j)称作一个重要翻转对。

你需要返回给定数组中的重要翻转对的数量。

示例 1:


输入: [1,3,2,3,1]
输出: 2


示例 2:


输入: [2,4,3,5,1]
输出: 3


注意:


	给定数组的长度不会超过50000。
	输入数组中的所有数字都在32位整数的表示范围内。

翻转对 - 领扣 (LeetCode)
作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：


1. 你设计的矩形页面必须等于给定的目标面积。

2. 宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。

3. 长度 L 和宽度 W 之间的差距应当尽可能小。


你需要按顺序输出你设计的页面的长度 L 和宽度 W。

示例：


输入: 4
输出: [2, 2]
解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。
但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。


说明:


	给定的面积不大于 10,000,000 且为正整数。
	你设计的页面的长度和宽度必须都是正整数。

构造矩形 - 领扣 (LeetCode)
给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

示例:


输入: [4, 6, 7, 7]
输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]

说明:


	给定数组的长度不会超过15。
	数组中的整数范围是[-100,100]。
	给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。

递增子序列 - 领扣 (LeetCode)
回忆一下祖玛游戏。现在桌上有一串球，颜色有红色(R)，黄色(Y)，蓝色(B)，绿色(G)，还有白色(W)。 现在你手里也有几个球。

每一次，你可以从手里的球选一个，然后把这个球插入到一串球中的某个位置上（包括最左端，最右端）。接着，如果有出现三个或者三个以上颜色相同的球相连的话，就把它们移除掉。重复这一步骤直到桌上所有的球都被移除。

找到插入并可以移除掉桌上所有球所需的最少的球数。如果不能移除桌上所有的球，输出 -1 。


示例:
输入: WRRBBW, RB 
输出: -1 
解释: WRRBBW -&gt; WRR[R]BBW -&gt; WBBW -&gt; WBB[B]W -&gt; WW （翻译者标注：手上球已经用完，桌上还剩两个球无法消除，返回-1）

输入: WWRRBBWW, WRBRW 
输出: 2 
解释: WWRRBBWW -&gt; WWRR[R]BBWW -&gt; WWBBWW -&gt; WWBB[B]WW -&gt; WWWW -&gt; empty

输入:G, GGGGG 
输出: 2 
解释: G -&gt; G[G] -&gt; GG[G] -&gt; empty 

输入: RBYYBBRRB, YRBGB 
输出: 3 
解释: RBYYBBRRB -&gt; RBYY[Y]BBRRB -&gt; RBBBRRB -&gt; RRRB -&gt; B -&gt; B[B] -&gt; BB[B] -&gt; empty 


标注:


	你可以假设桌上一开始的球中，不会有三个及三个以上颜色相同且连着的球。
	桌上的球不会超过20个，输入的数据中代表这些球的字符串的名字是 board 。
	你手中的球不会超过5个，输入的数据中代表这些球的字符串的名字是 hand。
	输入的两个字符串均为非空字符串，且只包含字符 &#39;R&#39;,&#39;Y&#39;,&#39;B&#39;,&#39;G&#39;,&#39;W&#39;。

祖玛游戏 - 领扣 (LeetCode)
预测赢家 - 领扣 (LeetCode)
给定一个表示分数的非负整数数组。 玩家1从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿，&hellip;&hellip;。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。

给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。

示例 1:


输入: [1, 5, 2]
输出: False
解释: 一开始，玩家1可以从1和2中进行选择。
如果他选择2（或者1），那么玩家2可以从1（或者2）和5中进行选择。如果玩家2选择了5，那么玩家1则只剩下1（或者2）可选。
所以，玩家1的最终分数为 1 + 2 = 3，而玩家2为 5。
因此，玩家1永远不会成为赢家，返回 False。


示例 2:


输入: [1, 5, 233, 7]
输出: True
解释: 玩家1一开始选择1。然后玩家2必须从5和7中进行选择。无论玩家2选择了哪个，玩家1都可以选择233。
最终，玩家1（234分）比玩家2（12分）获得更多的分数，所以返回 True，表示玩家1可以成为赢家。


注意:


	1 <= 给定的数组长度<= 20.
	数组里所有分数都为非负数且不会大于10000000。
	如果最终两个玩家的分数相等，那么玩家1仍为赢家。

最大连续1的个数 - 领扣 (LeetCode)
给定一个二进制数组， 计算其中最大连续1的个数。

示例 1:


输入: [1,1,0,1,1,1]
输出: 3
解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.


注意：


	输入的数组只包含0 和1。
	输入数组的长度是正整数，且不超过 10,000。

最小好进制 - 领扣 (LeetCode)
对于给定的整数 n, 如果n的k（k&gt;=2）进制数的所有数位全为1，则称k（k&gt;=2）是 n 的一个好进制。

以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。



示例 1：


输入：13
输出：3
解释：13 的 3 进制是 111。


示例 2：


输入：4681
输出：8
解释：4681 的 8 进制是 11111。


示例 3：


输入：1000000000000000000
输出：999999999999999999
解释：1000000000000000000 的 999999999999999999 进制是 11。




提示：


	n的取值范围是[3, 10^18]。
	输入总是有效且没有前导 0。



给定一个密钥字符串S，只包含字母，数字以及 &#39;-&#39;（破折号）。N 个 &#39;-&#39; 将字符串分成了 N+1 组。给定一个数字 K，重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符，第一个分组至少要包含 1 个字符。两个分组之间用 &#39;-&#39;（破折号）隔开，并且将所有的小写字母转换为大写字母。

给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。

示例 1：


输入：S = 5F3Z-2e-9-w, K = 4

输出：5F3Z-2E9W

解释：字符串 S 被分成了两个部分，每部分 4 个字符；
    注意，两个额外的破折号需要删掉。


示例 2：


输入：S = 2-5g-3-J, K = 2

输出：2-5G-3J

解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。




提示:


	S 的长度不超过 12,000，K 为正整数
	S 只包含字母数字（a-z，A-Z，0-9）以及破折号&#39;-&#39;
	S 非空



密钥格式化 - 领扣 (LeetCode)
神奇的字符串S只包含 &#39;1&#39; 和 &#39;2&#39;，并遵守以下规则：

字符串 S 是神奇的，因为串联字符 &#39;1&#39; 和 &#39;2&#39; 的连续出现次数会生成字符串 S 本身。

字符串S的前几个元素如下：S = &ldquo;1221121221221121122 ......&rdquo;

如果我们将S 中连续的 1 和 2 进行分组，它将变成：

1 22 11 2 1 22 1 22 11 2 11 22 ......

并且每个组中 &#39;1&#39; 或 &#39;2&#39; 的出现次数分别是：

1 2 2 1 1 2 1 2 2 1 2 2 ......

你可以看到上面的出现次数就是 S 本身。

给定一个整数 N 作为输入，返回神奇字符串 S中前 N 个数字中的 &#39;1&#39; 的数目。

注意：N 不会超过 100,000。

示例：

输入：6
输出：3
解释：神奇字符串 S 的前 6 个元素是 &ldquo;12211&rdquo;，它包含三个 1，因此返回 3。



神奇字符串 - 领扣 (LeetCode)
滑动窗口中位数 - 领扣 (LeetCode)
中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。

例如：

[2,3,4]，中位数是3

[2,3]，中位数是 (2 + 3) / 2 = 2.5

给出一个数组 nums，有一个大小为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

例如：

给出nums = [1,3,-1,-3,5,3,6,7]，以及k = 3。


窗口位置                      中位数
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6


因此，返回该滑动窗口的中位数数组[1,-1,-1,3,5,6]。

提示：
假设k是合法的，即：k 始终小于输入的非空数组的元素个数.
最大回文数乘积 - 领扣 (LeetCode)
你需要找到由两个 n 位数的乘积组成的最大回文数。

由于结果会很大，你只需返回最大回文数 mod 1337得到的结果。

示例:

输入: 2

输出: 987

解释: 99 x 91 = 9009, 9009 % 1337 = 987

说明:

n 的取值范围为[1,8]。
汉明距离总和 - 领扣 (LeetCode)
两个整数的汉明距离 指的是这两个数字的二进制数对应位不同的数量。

计算一个数组中，任意两个数之间汉明距离的总和。

示例:


输入: 4, 14, 2

输出: 6

解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）
所以答案为：
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.


注意:


	数组中元素的范围为从0到10^9。
	数组的长度不超过10^4。

数字的补数 - 领扣 (LeetCode)
给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

注意:


	给定的整数保证在32位带符号整数的范围内。
	你可以假定二进制数不包含前导零位。


示例 1:


输入: 5
输出: 2
解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。


示例 2:


输入: 1
输出: 0
解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。

供暖器 - 领扣 (LeetCode)
冬季已经来临。你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。

现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。

所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。

说明:


	给出的房屋和供暖器的数目是非负数且不会超过 25000。
	给出的房屋和供暖器的位置均是非负数且不会超过10^9。
	只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。
	所有供暖器都遵循你的半径标准，加热的半径也一样。


示例 1:


输入: [1,2,3],[2]
输出: 1
解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。


示例 2:


输入: [1,2,3,4],[1,4]
输出: 1
解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。

一和零 - 领扣 (LeetCode)
在计算机界中，我们总是追求用有限的资源获取最大的收益。

现在，假设你分别支配着 m 个0和 n 个1。另外，还有一个仅包含0和1字符串的数组。

你的任务是使用给定的m 个0和 n 个1，找到能拼出存在于数组中的字符串的最大数量。每个0和1至多被使用一次。

注意:


	给定0和1的数量都不会超过100。
	给定字符串数组的长度不会超过600。


示例 1:


输入: Array = {10, 0001, 111001, 1, 0}, m = 5, n = 3
输出: 4

解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 10,0001,1,0 。


示例 2:


输入: Array = {10, 0, 1}, m = 1, n = 1
输出: 2

解释: 你可以拼出 10，但之后就没有剩余数字了。更好的选择是拼出 0 和 1 。

还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。

输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。

示例1:


输入: [1,1,2,2,2]
输出: true

解释: 能拼成一个边长为2的正方形，每边两根火柴。


示例2:


输入: [3,3,3,3,4]
输出: false

解释: 不能用所有火柴拼成一个正方形。


注意:


	给定的火柴长度和在0到10^9之间。
	火柴数组的长度不超过15。

火柴拼正方形 - 领扣 (LeetCode)
给定一个不含重复单词的列表，编写一个程序，返回给定单词列表中所有的连接词。

连接词的定义为：一个字符串完全是由至少两个给定数组中的单词组成的。

示例:


输入: [cat,cats,catsdogcats,dog,dogcatsdog,hippopotamuses,rat,ratcatdogcat]

输出: [catsdogcats,dogcatsdog,ratcatdogcat]

解释: catsdogcats由cats, dog 和 cats组成; 
     dogcatsdog由dog, cats和dog组成; 
     ratcatdogcat由rat, cat, dog和cat组成。


说明:


	给定数组的元素总数不超过 10000。
	给定数组中元素的长度总和不超过 600000。
	所有输入字符串只包含小写字母。
	不需要考虑答案输出的顺序。

连接词 - 领扣 (LeetCode)
验证IP地址 - 领扣 (LeetCode)
编写一个函数来验证输入的字符串是否是有效的 IPv4 或IPv6 地址。

IPv4地址由十进制数和点来表示，每个地址包含4个十进制数，其范围为0 -255，用(.)分割。比如，172.16.254.1；

同时，IPv4 地址内的数不会以 0 开头。比如，地址172.16.254.01 是不合法的。

IPv6地址由8组16进制的数字来表示，每组表示16 比特。这些组数字通过 (:)分割。比如,2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以，2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。

然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。比如，2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。

同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如，02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。

说明:你可以认为给定的字符串里没有空格或者其他特殊字符。

示例 1:


输入: 172.16.254.1

输出: IPv4

解释: 这是一个有效的 IPv4 地址, 所以返回 IPv4。


示例 2:


输入: 2001:0db8:85a3:0:0:8A2E:0370:7334

输出: IPv6

解释: 这是一个有效的 IPv6 地址, 所以返回 IPv6。


示例 3:


输入: 256.256.256.256

输出: Neither

解释: 这个地址既不是 IPv4 也不是 IPv6 地址。

环绕字符串中唯一的子字符串 - 领扣 (LeetCode)
把字符串 s 看作是&ldquo;abcdefghijklmnopqrstuvwxyz&rdquo;的无限环绕字符串，所以s 看起来是这样的：...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd.....

现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串s 中 p 的不同的非空子串的数目。

注意: p仅由小写的英文字母组成，p 的大小可能超过 10000。



示例1:


输入: a
输出: 1
解释: 字符串 S 中只有一个a子字符。




示例 2:


输入: cac
输出: 2
解释: 字符串 S 中的字符串&ldquo;cac&rdquo;只有两个子串&ldquo;a&rdquo;、&ldquo;c&rdquo;。.




示例 3:


输入: zab
输出: 6
解释: 在字符串 S 中有六个子串&ldquo;z&rdquo;、&ldquo;a&rdquo;、&ldquo;b&rdquo;、&ldquo;za&rdquo;、&ldquo;ab&rdquo;、&ldquo;zab&rdquo;。.



统计重复个数 - 领扣 (LeetCode)
定义由 n 个连接的字符串 s 组成字符串 S，即S = [s,n]。例如，[abc, 3]=&ldquo;abcabcabc&rdquo;。

另一方面，如果我们可以从 s2中删除某些字符使其变为 s1，我们称字符串 s1可以从字符串 s2获得。例如，&ldquo;abc&rdquo; 可以根据我们的定义从 &ldquo;abdbec&rdquo; 获得，但不能从 &ldquo;acbbe&rdquo; 获得。

现在给出两个非空字符串 S1和 S2（每个最多 100 个字符长）和两个整数 0 &le; N1&le; 106和 1 &le; N2&le; 106。现在考虑字符串 S1和 S2，其中S1=[s1,n1]和S2=[s2,n2]。找出可以使[S2,M]从S1获得的最大整数 M。

示例：

输入：
s1 =acb,n1 = 4
s2 =ab,n2 = 2

返回：
2

在 100 game 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。

如果我们将游戏规则改为 &ldquo;玩家不能重复使用整数&rdquo; 呢？

例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。

给定一个整数maxChoosableInteger（整数池中可选择的最大数）和另一个整数desiredTotal（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？

你可以假设maxChoosableInteger不会大于 20，desiredTotal不会大于 300。

示例：

输入：
maxChoosableInteger = 10
desiredTotal = 11

输出：
false

解释：
无论第一个玩家选择哪个整数，他都会失败。
第一个玩家可以选择从 1 到 10 的整数。
如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。
第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.
同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。

我能赢吗 - 领扣 (LeetCode)
岛屿的周长 - 领扣 (LeetCode)
给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地0 表示水域。

网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有&ldquo;湖&rdquo;（&ldquo;湖&rdquo; 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。



示例 :

输入:
[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]

输出: 16

解释: 它的周长是下面图片中的 16 个黄色的边：



给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。

例如:


输入:
[1,2,3]

输出:
2

说明：
只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： 

[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]

最少移动次数使数组元素相等 II - 领扣 (LeetCode)
汉明距离 - 领扣 (LeetCode)
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 &le; x, y < 231.

示例:


输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       &uarr;   &uarr;

上面的箭头指出了对应二进制位不同的位置。

设计并实现最不经常使用（LFU）缓存的数据结构。它应该支持以下操作：get和put。

get(key)- 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。
put(key, value)- 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，使最不经常使用的项目无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，最近最少使用的键将被去除。

进阶：
你是否可以在O(1)时间复杂度内执行两项操作？

示例：


LFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回 1
cache.put(3, 3);    // 去除 key 2
cache.get(2);       // 返回 -1 (未找到key 2)
cache.get(3);       // 返回 3
cache.put(4, 4);    // 去除 key 1
cache.get(1);       // 返回 -1 (未找到 key 1)
cache.get(3);       // 返回 3
cache.get(4);       // 返回 4
LFU缓存 - 领扣 (LeetCode)
重复的子字符串 - 领扣 (LeetCode)
给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

示例 1:


输入: abab

输出: True

解释: 可由子字符串 ab 重复两次构成。


示例 2:


输入: aba

输出: False


示例 3:


输入: abcabcabcabc

输出: True

解释: 可由子字符串 abc 重复四次构成。 (或者子字符串 abcabc 重复两次构成。)

可怜的小猪 - 领扣 (LeetCode)
有1000只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪喝了毒药，它会在15分钟内死去。

问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？

回答这个问题，并为下列的进阶问题编写一个通用算法。

进阶: 

假设有 n 只水桶，猪饮水中毒后会在 m 分钟内死亡，你需要多少猪（x）就能在 p 分钟内找出&ldquo;有毒&rdquo;水桶？n只水桶里有且仅有一只有毒的桶。
环形数组循环 - 领扣 (LeetCode)
给定一组含有正整数和负整数的数组。如果某个索引中的 n 是正数的，则向前移动 n 个索引。相反，如果是负数(-n)，则向后移动 n 个索引。

假设数组首尾相接。判断数组中是否有环。环中至少包含 2 个元素。环中的元素一律&ldquo;向前&rdquo;或者一律&ldquo;向后&rdquo;。

示例 1：给定数组[2, -1, 1, 2, 2], 有一个循环，从索引 0 -&gt; 2 -&gt; 3 -&gt; 0。

示例 2：给定数组[-1, 2], 没有循环。

注意：给定数组保证不包含元素0。

你能写出时间复杂度为 O(n) 且空间复杂度为O(1)的算法吗？
给定一个整数序列：a1, a2, ..., an，一个132模式的子序列ai, aj, ak被定义为：当 i < j < k 时，ai < ak < aj。设计一个算法，当给定有n 个数字的序列时，验证这个序列中是否含有132模式的子序列。

注意：n 的值小于15000。

示例1:


输入: [1, 2, 3, 4]

输出: False

解释: 序列中不存在132模式的子序列。


示例 2:


输入: [3, 1, 4, 2]

输出: True

解释: 序列中有 1 个132模式的子序列： [1, 4, 2].


示例 3:


输入: [-1, 3, 2, 0]

输出: True

解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].

132模式 - 领扣 (LeetCode)
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj。如果 sj &gt;= gi，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

注意：

你可以假设胃口值为正。
一个小朋友最多只能拥有一块饼干。

示例1:


输入: [1,2,3], [1,1]

输出: 1

解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。


示例2:


输入: [1,2], [1,2,3]

输出: 2

解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.

分发饼干 - 领扣 (LeetCode)
给定四个包含整数的数组列表A , B , C , D ,计算有多少个元组 (i, j, k, l)，使得A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度N，且 0 &le; N &le; 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过231 - 1 。

例如:


输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

输出:
2

解释:
两个元组如下:
1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

四数相加 II - 领扣 (LeetCode)
给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 n - 1 个元素增加 1。

示例:


输入:
[1,2,3]

输出:
3

解释:
只需要3次移动（注意每次移动会增加两个元素的值）：

[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]

最小移动次数使数组元素相等 - 领扣 (LeetCode)
在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。

一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart&le; x &le; xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

Example:


输入:
[[10,16], [2,8], [1,6], [7,12]]

输出:
2

解释:
对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。

用最少数量的箭引爆气球 - 领扣 (LeetCode)
给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

示例 1:


输入:
tree

输出:
eert

解释:
&#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。
因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，eetr也是一个有效的答案。


示例 2:


输入:
cccaaa

输出:
cccaaa

解释:
&#39;c&#39;和&#39;a&#39;都出现三次。此外，aaaccc也是有效的答案。
注意cacaca是不正确的，因为相同的字母必须放在一起。


示例 3:


输入:
Aabb

输出:
bbAa

解释:
此外，bbaA也是一个有效的答案，但Aabb是不正确的。
注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。

根据字符出现频率排序 - 领扣 (LeetCode)
删除二叉搜索树中的节点 - 领扣 (LeetCode)
给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的key对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：


	首先找到需要删除的节点；
	如果找到了，删除它。


说明： 要求算法时间复杂度为O(h)，h 为树的高度。

示例:


root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。

    5
   / \
  2   6
   \   \
    4   7

序列化和反序列化二叉搜索树 - 领扣 (LeetCode)
序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。

设计一个算法来序列化和反序列化二叉搜索树。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。

编码的字符串应尽可能紧凑。

注意：不要使用类成员/全局/静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。
找到所有数组中消失的数字 - 领扣 (LeetCode)
给定一个范围在 1 &le; a[i] &le; n (n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

示例:


输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]

回旋镖的数量 - 领扣 (LeetCode)
给定平面上n 对不同的点，&ldquo;回旋镖&rdquo; 是由点表示的元组(i, j, k)，其中i和j之间的距离和i和k之间的距离相等（需要考虑元组的顺序）。

找到所有回旋镖的数量。你可以假设n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。

示例:


输入:
[[0,0],[1,0],[2,0]]

输出:
2

解释:
两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]

等差数列划分 II - 子序列 - 领扣 (LeetCode)
如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。

例如，以下数列为等差数列:

1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9

以下数列不是等差数列。

1, 1, 2, 5, 7



数组 A 包含 N 个数，且索引从 0 开始。该数组子序列将划分为整数序列(P0, P1, ..., Pk)，P 与 Q 是整数且满足 0 &le; P0 < P1 < ... < Pk < N。



如果序列 A[P0]，A[P1]，...，A[Pk-1]，A[Pk] 是等差的，那么数组 A 的子序列 (P0，P1，&hellip;，PK) 称为等差序列。值得注意的是，这意味着 k &ge; 2。

函数要返回数组 A 中所有等差子序列的个数。

输入包含 N 个整数。每个整数都在 -231 和 231-1 之间，另外 0 &le; N &le; 1000。保证输出小于 231-1。



示例：



输入：[2, 4, 6, 8, 10]

输出：7

解释：
所有的等差子序列为：
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]



两数相加 II - 领扣 (LeetCode)
给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。



你可以假设除了数字 0 之外，这两个数字都不会以零开头。

进阶:

如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。

示例:


输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出: 7 -&gt; 8 -&gt; 0 -&gt; 7

压缩字符串 - 领扣 (LeetCode)
给定一组字符，使用原地算法将其压缩。

压缩后的长度必须始终小于或等于原数组长度。

数组的每个元素应该是长度为1的字符（不是 int 整数类型）。

在完成原地修改输入数组后，返回数组的新长度。



进阶：
你能否仅使用O(1) 空间解决问题？



示例 1：


输入：
[a,a,b,b,c,c,c]

输出：
返回6，输入数组的前6个字符应该是：[a,2,b,2,c,3]

说明：
aa被a2替代。bb被b2替代。ccc被c3替代。


示例 2：


输入：
[a]

输出：
返回1，输入数组的前1个字符应该是：[a]

说明：
没有任何字符串被替代。


示例 3：


输入：
[a,b,b,b,b,b,b,b,b,b,b,b,b]

输出：
返回4，输入数组的前4个字符应该是：[a,b,1,2]。

说明：
由于字符a不重复，所以不会被压缩。bbbbbbbbbbbb被&ldquo;b12&rdquo;替代。
注意每个数字在数组中都有它自己的位置。


注意：


	所有字符都有一个ASCII值在[35, 126]区间内。
	1 <= len(chars) <= 1000。

给定一个整数数组 a，其中1 &le; a[i] &le; n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？

示例：


输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]

数组中重复的数据 - 领扣 (LeetCode)
你总共有n枚硬币，你需要将它们摆成一个阶梯形状，第k行就必须正好有k枚硬币。

给定一个数字n，找出可形成完整阶梯行的总行数。

n是一个非负整数，并且在32位有符号整型的范围内。

示例 1:


n = 5

硬币可排列成以下几行:
&curren;
&curren; &curren;
&curren; &curren;

因为第三行不完整，所以返回2.


示例 2:


n = 8

硬币可排列成以下几行:
&curren;
&curren; &curren;
&curren; &curren; &curren;
&curren; &curren;

因为第四行不完整，所以返回3.

排列硬币 - 领扣 (LeetCode)
字典序的第K小数字 - 领扣 (LeetCode)
给定整数n和k，找到1到n中字典序第k小的数字。

注意：1 &le; k &le; n &le; 109。

示例 :


输入:
n: 13   k: 2

输出:
10

解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。

找到字符串中所有字母异位词 - 领扣 (LeetCode)
给定一个字符串s和一个非空字符串p，找到s中所有是p的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串s和 p的长度都不超过 20100。

说明：


	字母异位词指字母相同，但排列不同的字符串。
	不考虑答案输出的顺序。


示例1:


输入:
s: cbaebabacd p: abc

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 cba, 它是 abc 的字母异位词。
起始索引等于 6 的子串是 bac, 它是 abc 的字母异位词。


示例 2:


输入:
s: abab p: ab

输出:
[0, 1, 2]

解释:
起始索引等于 0 的子串是 ab, 它是 ab 的字母异位词。
起始索引等于 1 的子串是 ba, 它是 ab 的字母异位词。
起始索引等于 2 的子串是 ab, 它是 ab 的字母异位词。

给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

示例：

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -&gt; 3
2.  5 -&gt; 2 -&gt; 1
3.  -3 -&gt; 11

路径总和 III - 领扣 (LeetCode)
寻找右区间 - 领扣 (LeetCode)
给定一组区间，对于每一个区间 i，检查是否存在一个区间 j，它的起始点大于或等于区间i 的终点，这可以称为 j 在 i 的&ldquo;右侧&rdquo;。

对于任何区间，你需要存储的满足条件的区间j 的最小索引，这意味着区间 j 有最小的起始点可以使其成为&ldquo;右侧&rdquo;区间。如果区间j 不存在，则将区间 i 存储为 -1。最后，你需要输出一个值为存储的区间值的数组。

注意:


	你可以假设区间的终点总是大于它的起始点。
	你可以假定这些区间都不具有相同的起始点。


示例 1:


输入: [ [1,2] ]
输出: [-1]

解释:集合中只有一个区间，所以输出-1。


示例 2:


输入: [ [3,4], [2,3], [1,2] ]
输出: [-1, 0, 1]

解释:对于[3,4]，没有满足条件的&ldquo;右侧&rdquo;区间。
对于[2,3]，区间[3,4]具有最小的&ldquo;右&rdquo;起点;
对于[1,2]，区间[2,3]具有最小的&ldquo;右&rdquo;起点。


示例 3:


输入: [ [1,4], [2,3], [3,4] ]
输出: [-1, 2, -1]

解释:对于区间[1,4]和[3,4]，没有满足条件的&ldquo;右侧&rdquo;区间。
对于[2,3]，区间[3,4]有最小的&ldquo;右&rdquo;起点。

无重叠区间 - 领扣 (LeetCode)
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:


	可以认为区间的终点总是大于它的起点。
	区间 [1,2] 和 [2,3] 的边界相互&ldquo;接触&rdquo;，但没有相互重叠。


示例 1:


输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。


示例 2:


输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。


示例 3:


输入: [ [1,2], [2,3] ]

输出: 0

解释: 你不需要移除任何区间，因为它们已经是无重叠的了。

字符串中的单词数 - 领扣 (LeetCode)
统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

示例:

输入: Hello, my name is John
输出: 5

一条基因序列由一个带有8个字符的字符串表示，其中每个字符都属于 A, C, G, T中的任意一个。

假设我们要调查一个基因序列的变化。一次基因变化意味着这个基因序列中的一个字符发生了变化。

例如，基因序列由AACCGGTT变化至AACCGGTA即发生了一次基因变化。

与此同时，每一次基因变化的结果，都需要是一个合法的基因串，即该结果属于一个基因库。

现在给定3个参数 &mdash; start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。

注意:


	起始基因序列默认是合法的，但是它并不一定会出现在基因库中。
	所有的目标基因序列必须是合法的。
	假定起始基因序列与目标基因序列是不一样的。


示例 1:


start: AACCGGTT
end:   AACCGGTA
bank: [AACCGGTA]

返回值: 1


示例 2:


start: AACCGGTT
end:   AAACGGTA
bank: [AACCGGTA, AACCGCTA, AAACGGTA]

返回值: 2


示例 3:


start: AAAAACCC
end:   AACCCCCC
bank: [AAAACCCC, AAACCCCC, AACCCCCC]

返回值: 3

最小基因变化 - 领扣 (LeetCode)
全 O(1) 的数据结构 - 领扣 (LeetCode)
实现一个数据结构支持以下操作：


	Inc(key) - 插入一个新的值为 1 的 key。或者使一个存在的 key 增加一，保证 key 不为空字符串。
	Dec(key) - 如果这个 key 的值是 1，那么把他从数据结构中移除掉。否者使一个存在的 key 值减一。如果这个 key 不存在，这个函数不做任何事情。key 保证不为空字符串。
	GetMaxKey() - 返回 key 中值最大的任意一个。如果没有元素存在，返回一个空字符串。
	GetMinKey() - 返回 key 中值最小的任意一个。如果没有元素存在，返回一个空字符串。


挑战：以 O(1) 的时间复杂度实现所有操作。
替换后的最长重复字符 - 领扣 (LeetCode)
给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换k次。在执行上述操作后，找到包含重复字母的最长子串的长度。

注意:
字符串长度 和 k 不会超过104。

示例 1:

输入:
s = ABAB, k = 2

输出:
4

解释:
用两个&#39;A&#39;替换为两个&#39;B&#39;,反之亦然。


示例 2:

输入:
s = AABABBA, k = 1

输出:
4

解释:
将中间的一个&#39;A&#39;替换为&#39;B&#39;,字符串变为 AABBBBA。
子串 BBBB 有最长重复字母, 答案为 4。

从英文中重建数字 - 领扣 (LeetCode)
给定一个非空字符串，其中包含字母顺序打乱的英文单词表示的数字0-9。按升序输出原始的数字。

注意:


	输入只包含小写英文字母。
	输入保证合法并可以转换为原始的数字，这意味着像 abc 或 zerone 的输入是不允许的。
	输入字符串的长度小于 50,000。


示例 1:


输入: owoztneoer

输出: 012 (zeroonetwo)


示例 2:


输入: fviefuro

输出: 45 (fourfive)

数组中两个数的最大异或值 - 领扣 (LeetCode)
给定一个非空数组，数组中元素为 a0, a1, a2, &hellip; , an-1，其中 0 &le; ai < 231。

找到 ai 和aj最大的异或 (XOR) 运算结果，其中0 &le; i,j < n。

你能在O(n)的时间解决这个问题吗？

示例:


输入: [3, 10, 5, 25, 2, 8]

输出: 28

解释: 最大的结果是 5 ^ 25 = 28.

一个强密码应满足以下所有条件：


	由至少6个，至多20个字符组成。
	至少包含一个小写字母，一个大写字母，和一个数字。
	同一字符不能连续出现三次 (比如 ...aaa... 是不允许的, 但是...aa...a... 是可以的)。


编写函数strongPasswordChecker(s)，s 代表输入字符串，如果 s 已经符合强密码条件，则返回0；否则返回要将 s 修改为满足强密码条件的字符串所需要进行修改的最小步数。

插入、删除、替换任一字符都算作一次修改。
强密码检验器 - 领扣 (LeetCode)
给定一个二维的甲板， 请计算其中有多少艘战舰。战舰用&#39;X&#39;表示，空位用&#39;.&#39;表示。你需要遵守以下规则：


	给你一个有效的甲板，仅由战舰或者空位组成。
	战舰只能水平或者垂直放置。换句话说,战舰只能由1xN (1 行, N 列)组成，或者Nx1 (N 行, 1 列)组成，其中N可以是任意大小。
	两艘战舰之间至少有一个水平或垂直的空位分隔- 即没有相邻的战舰。


示例 :


X..X
...X
...X


在上面的甲板中有2艘战舰。

无效样例 :


...X
XXXX
...X


你不会收到这样的无效甲板- 因为战舰之间至少会有一个空位将它们分开。

进阶:

你可以用一次扫描算法，只使用O(1)额外空间，并且不修改甲板的值来解决这个问题吗？
甲板上的战舰 - 领扣 (LeetCode)
太平洋大西洋水流问题 - 领扣 (LeetCode)
给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。&ldquo;太平洋&rdquo;处于大陆的左边界和上边界，而&ldquo;大西洋&rdquo;处于大陆的右边界和下边界。

规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。

请找出那些水流既可以流动到&ldquo;太平洋&rdquo;，又能流动到&ldquo;大西洋&rdquo;的陆地单元的坐标。



提示：


	输出坐标的顺序不重要
	m 和 n 都小于150




示例：




给定下面的 5x5 矩阵:

  太平洋 ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋

返回:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).



给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:


	每个数组中的元素不会超过 100
	数组的大小不会超过 200


示例 1:

输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].




示例2:

输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集.



分割等和子集 - 领扣 (LeetCode)
字符串相加 - 领扣 (LeetCode)
给定两个字符串形式的非负整数num1 和num2，计算它们的和。

注意：


	num1 和num2的长度都小于 5100.
	num1 和num2 都只包含数字0-9.
	num1 和num2 都不包含任何前导零。
	你不能使用任何內建 BigInteger 库，也不能直接将输入的字符串转换为整数形式。

第三大的数 - 领扣 (LeetCode)
给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。

示例 1:


输入: [3, 2, 1]

输出: 1

解释: 第三大的数是 1.


示例 2:


输入: [1, 2]

输出: 2

解释: 第三大的数不存在, 所以返回最大的数 2 .


示例 3:


输入: [2, 2, 3, 1]

输出: 1

解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。
存在两个值为2的数，它们都排第二。

等差数列划分 - 领扣 (LeetCode)
如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。

例如，以下数列为等差数列:


1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9

以下数列不是等差数列。


1, 1, 2, 5, 7



数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。

如果满足以下条件，则称子数组(P, Q)为等差数组：

元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且P + 1 < Q 。

函数要返回数组 A 中所有为等差数组的子数组个数。



示例:


A = [1, 2, 3, 4]

返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。

Fizz Buzz - 领扣 (LeetCode)
写一个程序，输出从 1 到 n 数字的字符串表示。

1. 如果n是3的倍数，输出&ldquo;Fizz&rdquo;；

2. 如果n是5的倍数，输出&ldquo;Buzz&rdquo;；

3.如果n同时是3和5的倍数，输出 &ldquo;FizzBuzz&rdquo;。

示例：

n = 15,

返回:
[
    1,
    2,
    Fizz,
    4,
    Buzz,
    Fizz,
    7,
    8,
    Fizz,
    Buzz,
    11,
    Fizz,
    13,
    14,
    FizzBuzz
]

分割数组的最大值 - 领扣 (LeetCode)
给定一个非负整数数组和一个整数m，你需要将这个数组分成m个非空的连续子数组。设计一个算法使得这m个子数组各自和的最大值最小。

注意:
数组长度n满足以下条件:


	1 &le; n &le; 1000
	1 &le; m &le; min(50, n)


示例: 


输入:
nums = [7,2,5,10,8]
m = 2

输出:
18

解释:
一共有四种方法将nums分割为2个子数组。
其中最好的方式是将其分为[7,2,5] 和 [10,8]，
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。

最长回文串 - 领扣 (LeetCode)
给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如Aa不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 1010。

示例 1: 


输入:
abccccdd

输出:
7

解释:
我们可以构造的最长的回文串是dccaccd, 它的长度是 7。

给定一个 m x n的矩阵，其中的值均为正整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。







说明:



m和 n都是小于110的整数。每一个单位的高度都大于0 且小于 20000。







示例：



给出如下 3x6 的高度图:

[

  [1,4,3,1,3,2],

  [3,2,1,3,2,4],

  [2,3,3,2,3,1]

]



返回 4。









如上图所示，这是下雨前的高度图[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] 的状态。











下雨后，雨水将会被存储在这些方块中。总的接雨水量是4。接雨水 II - 领扣 (LeetCode)
假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

注意：
总人数少于1100人。

示例


输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]

根据身高重建队列 - 领扣 (LeetCode)
给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用补码运算方法。

注意:


	十六进制中所有字母(a-f)都必须是小写。
	十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符&#39;0&#39;来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。
	给定的数确保在32位有符号整数范围内。
	不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。


示例 1：


输入:
26

输出:
1a


示例 2：


输入:
-1

输出:
ffffffff

数字转换为十六进制数 - 领扣 (LeetCode)
左叶子之和 - 领扣 (LeetCode)
计算给定二叉树的所有左叶子之和。

示例：


    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24


青蛙过河 - 领扣 (LeetCode)
一只青蛙想要过河。 假定河流被等分为x个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。

给定石子的位置列表（用单元格序号升序表示），请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。开始时，青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。

如果青蛙上一步跳跃了k个单位，那么它接下来的跳跃距离只能选择为k - 1、k或k + 1个单位。另请注意，青蛙只能向前方（终点的方向）跳跃。

请注意：


	石子的数量 &ge; 2 且< 1100；
	每一个石子的位置序号都是一个非负整数，且其 < 231；
	第一个石子的位置永远是0。


示例1:


[0,1,3,5,6,8,12,17]

总共有8个石子。
第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,
第三个石子在序号为3的单元格的位置， 以此定义整个数组...
最后一个石子处于序号为17的单元格的位置。

返回 true。即青蛙可以成功过河，按照如下方案跳跃： 
跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 
跳2个单位到第4块石子, 然后跳3个单位到第6块石子, 
跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。


示例 2:


[0,1,2,3,4,8,9,11]

返回 false。青蛙没有办法过河。 
这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。

给定一个以字符串表示的非负整数num，移除这个数中的 k 位数字，使得剩下的数字最小。

注意:


	num 的长度小于 10002 且&ge; k。
	num 不会包含任何前导零。


示例 1 :


输入: num = 1432219, k = 3
输出: 1219
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。


示例 2 :


输入: num = 10200, k = 1
输出: 200
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。


示例 3 :


输入: num = 10, k = 2
输出: 0
解释: 从原数字移除所有的数字，剩余为空就是0。

移掉K位数字 - 领扣 (LeetCode)
二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。

每个 LED 代表一个 0 或 1，最低位在右侧。



例如，上面的二进制手表读取 &ldquo;3:25&rdquo;。

给定一个非负整数 n代表当前 LED 亮着的数量，返回所有可能的时间。

案例:


输入: n = 1
返回: [1:00, 2:00, 4:00, 8:00, 0:01, 0:02, 0:04, 0:08, 0:16, 0:32]



注意事项:


	输出的顺序没有要求。
	小时不会以零开头，比如 &ldquo;01:00&rdquo;是不允许的，应为 &ldquo;1:00&rdquo;。
	分钟必须由两位数组成，可能会以零开头，比如 &ldquo;10:2&rdquo;是无效的，应为 &ldquo;10:02&rdquo;。

二进制手表 - 领扣 (LeetCode)
在无限的整数序列1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...中找到第n个数字。

注意:
n是正数且在32为整形范围内(n < 231)。

示例 1:


输入:
3

输出:
3


示例 2:


输入:
11

输出:
0

说明:
第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是0，它是10的一部分。

第N个数字 - 领扣 (LeetCode)
除法求值 - 领扣 (LeetCode)
给出方程式A / B = k, 其中A 和B 均为代表字符串的变量，k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回-1.0。

示例 :
给定a / b = 2.0, b / c = 3.0
问题:  a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
返回[6.0, 0.5, -1.0, 1.0, -1.0 ]

输入为:  vector<pair<string, string&gt;&gt; equations, vector<double&gt;&amp; values, vector<pair<string, string&gt;&gt; queries(方程式，方程式结果，问题方程式)，其中equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。返回vector<double&gt;类型。

基于上述例子，输入如下：


equations(方程式) = [ [a, b], [b, c] ],
values(方程式结果) = [2.0, 3.0],
queries(问题方程式) = [ [a, c], [b, a], [a, e], [a, a], [x, x] ]. 


输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。
给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。

注意：
数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。

示例:


int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);

// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。
solution.pick(3);

// pick(1) 应该返回 0。因为只有nums[0]等于1。
solution.pick(1);

随机数索引 - 领扣 (LeetCode)
给定一个正整数n，你可以做如下操作：

1. 如果n是偶数，则用n / 2替换n。
2. 如果n是奇数，则可以用n + 1或n - 1替换n。
n变为 1 所需的最小替换次数是多少？

示例 1:


输入:
8

输出:
3

解释:
8 -&gt; 4 -&gt; 2 -&gt; 1


示例 2:


输入:
7

输出:
4

解释:
7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1
或
7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1

整数替换 - 领扣 (LeetCode)
给定一个长度为 n 的整数数组A。

假设Bk是数组A顺时针旋转 k 个位置后的数组，我们定义A的&ldquo;旋转函数&rdquo;F为：

F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]。

计算F(0), F(1), ..., F(n-1)中的最大值。

注意:
可以认为 n 的值小于 105。

示例:


A = [4, 3, 2, 6]

F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26

所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。

旋转函数 - 领扣 (LeetCode)
至少有K个重复字符的最长子串 - 领扣 (LeetCode)
找到给定字符串（由小写字符组成）中的最长子串 T ，要求T中的每一字符出现次数都不少于 k 。输出 T的长度。

示例 1:


输入:
s = aaabb, k = 3

输出:
3

最长子串为 aaa ，其中 &#39;a&#39; 重复了 3 次。


示例 2:


输入:
s = ababbc, k = 2

输出:
5

最长子串为 ababb ，其中 &#39;a&#39; 重复了 2 次， &#39;b&#39; 重复了 3 次。

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像3a或2[4]的输入。

示例:


s = 3[a]2[bc], 返回 aaabcbc.
s = 3[a2[c]], 返回 accaccacc.
s = 2[abc]3[cd]ef, 返回 abcabccdcdcdef.

字符串解码 - 领扣 (LeetCode)
UTF-8 编码验证 - 领扣 (LeetCode)
UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：


	对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。
	对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。


这是 UTF-8 编码的工作方式：


   Char. number range  |        UTF-8 octet sequence
      (hexadecimal)    |              (binary)
   --------------------+---------------------------------------------
   0000 0000-0000 007F | 0xxxxxxx
   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx


给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。

注意:
输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。

示例 1:


data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.

返回 true 。
这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。


示例 2:


data = [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.

返回 false 。
前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。
下一个字节是开头为 10 的延续字节，这是正确的。
但第二个延续字节不以 10 开头，所以是不符合规则的。

判断子序列 - 领扣 (LeetCode)
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，ace是abcde的一个子序列，而aec不是）。

示例1:
s = abc, t = ahbgdc

返回true.

示例2:
s = axc, t = ahbgdc

返回false.

后续挑战 :

如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

致谢:

特别感谢 @pbrother添加此问题并且创建所有测试用例。
完美矩形 - 领扣 (LeetCode)
我们有 N 个与坐标轴对齐的矩形, 其中 N &gt; 0, 判断它们是否能精确地覆盖一个矩形区域。

每个矩形用左下角的点和右上角的点的坐标来表示。例如，一个单位正方形可以表示为 [1,1,2,2]。( 左下角的点的坐标为 (1, 1) 以及右上角的点的坐标为 (2, 2) )。



示例 1:

rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [3,2,4,4],
  [1,3,2,4],
  [2,3,3,4]
]

返回 true。5个矩形一起可以精确地覆盖一个矩形区域。






示例2:

rectangles = [
  [1,1,2,3],
  [1,3,2,4],
  [3,1,4,2],
  [3,2,4,4]
]

返回 false。两个矩形之间有间隔，无法覆盖成一个矩形。






示例 3:

rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [3,2,4,4]
]

返回 false。图形顶端留有间隔，无法覆盖成一个矩形。






示例 4:

rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [2,2,4,4]
]

返回 false。因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。

消除游戏 - 领扣 (LeetCode)
给定一个从1 到 n 排序的整数列表。
首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。
第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。
我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
返回长度为 n 的列表中，最后剩下的数字。

示例：


输入:
n = 9,
1 2 3 4 5 6 7 8 9
2 4 6 8
2 6
6

输出:
6
给定两个字符串 s 和 t，它们只包含小写字母。

字符串t由字符串s随机重排，然后在随机位置添加一个字母。

请找出在 t 中被添加的字母。



示例:

输入：
s = abcd
t = abcde

输出：
e

解释：
&#39;e&#39; 是那个被添加的字母。

找不同 - 领扣 (LeetCode)
文件的最长绝对路径 - 领扣 (LeetCode)
假设我们以下述方式将我们的文件系统抽象成一个字符串:

字符串dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext 表示:


dir
    subdir1
    subdir2
        file.ext


目录dir 包含一个空的子目录subdir1 和一个包含一个文件file.ext的子目录subdir2 。

字符串dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext 表示:


dir
    subdir1
        file1.ext
        subsubdir1
    subdir2
        subsubdir2
            file2.ext


目录dir 包含两个子目录 subdir1 和subdir2。subdir1 包含一个文件file1.ext 和一个空的二级子目录 subsubdir1。subdir2 包含一个二级子目录subsubdir2 ，其中包含一个文件file2.ext。

我们致力于寻找我们文件系统中文件的最长 (按字符的数量统计) 绝对路径。例如，在上述的第二个例子中，最长路径为dir/subdir2/subsubdir2/file2.ext，其长度为32 (不包含双引号)。

给定一个以上述格式表示文件系统的字符串，返回文件系统中文件的最长绝对路径的长度。 如果系统中没有文件，返回0。

说明:


	文件名至少存在一个. 和一个扩展名。
	目录或者子目录的名字不能包含.。


要求时间复杂度为O(n)，其中n 是输入字符串的大小。

请注意，如果存在路径aaaaaaaaaaaaaaaaaaaaa/sth.png的话，那么a/aa/aaa/file1.txt就不是一个最长的路径。
字符串中的第一个唯一字符 - 领扣 (LeetCode)
给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

案例:


s = leetcode
返回 0.

s = loveleetcode,
返回 2.




注意事项：您可以假定该字符串只包含小写字母。
给定一个整数n, 返回从1到n的字典顺序。

例如，

给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。

请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据n小于等于5,000,000。
字典序排数 - 领扣 (LeetCode)
给定一个用字符串表示的整数的嵌套列表，实现一个解析它的语法分析器。

列表中的每个元素只可能是整数或整数嵌套列表

提示：你可以假定这些字符串都是格式良好的：


	字符串非空
	字符串不包含空格
	字符串只包含数字0-9, [, - ,, ]




示例 1：


给定 s = 324,

你应该返回一个 NestedInteger 对象，其中只包含整数值 324。




示例 2：


给定 s = [123,[456,[789]]],

返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：

1. 一个 integer 包含值 123
2. 一个包含两个元素的嵌套列表：
    i.  一个 integer 包含值 456
    ii. 一个包含一个元素的嵌套列表
         a. 一个 integer 包含值 789



迷你语法分析器 - 领扣 (LeetCode)
打乱数组 - 领扣 (LeetCode)
打乱一个没有重复元素的数组。

示例:


// 以数字集合 1, 2 和 3 初始化数组。
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。
solution.shuffle();

// 重设数组到它的初始状态[1,2,3]。
solution.reset();

// 随机返回数组[1,2,3]打乱后的结果。
solution.shuffle();

赎金信 - 领扣 (LeetCode)
给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)

注意：

你可以假设两个字符串均只含有小写字母。


canConstruct(a, b) -&gt; false
canConstruct(aa, ab) -&gt; false
canConstruct(aa, aab) -&gt; true

链表随机节点 - 领扣 (LeetCode)
给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点被选的概率一样。

进阶:
如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？

示例:


// 初始化一个单链表 [1,2,3].
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
Solution solution = new Solution(head);

// getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。
solution.getRandom();

设计一个支持在平均时间复杂度O(1)下，执行以下操作的数据结构。

注意: 允许出现重复元素。


	insert(val)：向集合中插入元素 val。
	remove(val)：当 val 存在时，从集合中移除一个 val。
	getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。


示例:

// 初始化一个空的集合。
RandomizedCollection collection = new RandomizedCollection();

// 向集合中插入 1 。返回 true 表示集合不包含 1 。
collection.insert(1);

// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。
collection.insert(1);

// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。
collection.insert(2);

// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。
collection.getRandom();

// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。
collection.remove(1);

// getRandom 应有相同概率返回 1 和 2 。
collection.getRandom();

O(1) 时间插入、删除和获取随机元素 - 允许重复 - 领扣 (LeetCode)
设计一个支持在平均时间复杂度 O(1)下，执行以下操作的数据结构。


	insert(val)：当元素 val 不存在时，向集合中插入该项。
	remove(val)：元素 val 存在时，从集合中移除该项。
	getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。


示例 :


// 初始化一个空的集合。
RandomizedSet randomSet = new RandomizedSet();

// 向集合中插入 1 。返回 true 表示 1 被成功地插入。
randomSet.insert(1);

// 返回 false ，表示集合中不存在 2 。
randomSet.remove(2);

// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。
randomSet.insert(2);

// getRandom 应随机返回 1 或 2 。
randomSet.getRandom();

// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。
randomSet.remove(1);

// 2 已在集合中，所以返回 false 。
randomSet.insert(2);

// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。
randomSet.getRandom();

常数时间插入、删除和获取随机元素 - 领扣 (LeetCode)
有序矩阵中第K小的元素 - 领扣 (LeetCode)
给定一个n x n矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。
请注意，它是排序后的第k小元素，而不是第k个元素。

示例:


matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。


说明: 
你可以假设 k 的值永远是有效的, 1 &le; k &le; n2。
组合总和 Ⅳ - 领扣 (LeetCode)
给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

示例:


nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。


进阶：
如果给定的数组中含有负数会怎么样？
问题会产生什么变化？
我们需要在题目中添加什么限制来允许负数的出现？

致谢：
特别感谢@pbrother添加此问题并创建所有测试用例。
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如，[1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3)是正负交替出现的。相反, [1,4,7,2,5]和[1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

示例 1:

输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。


示例 2:

输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。

示例 3:

输入: [1,2,3,4,5,6,7,8,9]
输出: 2

进阶:
你能否用O(n) 时间复杂度完成此题?
摆动序列 - 领扣 (LeetCode)
猜数字大小 II - 领扣 (LeetCode)
我们正在玩一个猜数游戏，游戏规则如下：

我从1到 n 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。

示例:

n = 10, 我选择了8.

第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。
第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。
第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。

游戏结束。8 就是我选的数字。

你最终要支付 5 + 7 + 9 = 21 块钱。


给定n &ge; 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。
猜数字大小 - 领扣 (LeetCode)
我们正在玩一个猜数字游戏。 游戏规则如下：
我从1到n选择一个数字。 你需要猜我选择了哪个数字。
每次你猜错了，我会告诉你这个数字是大了还是小了。
你调用一个预先定义好的接口guess(int num)，它会返回 3 个可能的结果（-1，1或 0）：

-1 : 我的数字比较小
 1 : 我的数字比较大
 0 : 恭喜！你猜对了！


示例 :

输入: n = 10, pick = 6
输出: 6
查找和最小的K对数字 - 领扣 (LeetCode)
给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。

定义一对值(u,v)，其中第一个元素来自nums1，第二个元素来自 nums2。

找到和最小的 k 对数字(u1,v1), (u2,v2) ... (uk,vk)。

示例 1:

输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]


示例 2:

输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
输出: [1,1],[1,1]
解释: 返回序列中的前 2 对数：
    [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]


示例 3:

输入: nums1 = [1,2], nums2 = [3], k = 3 
输出: [1,3],[2,3]
解释: 也可能序列中所有的数对都被返回:[1,3],[2,3]

你的任务是计算ab对1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。

示例 1:

输入: a = 2, b = [3]
输出: 8


示例2:

输入: a = 2, b = [1,0]
输出: 1024
超级次方 - 领扣 (LeetCode)
不使用运算符+ 和-​​​​​​​，计算两整数​​​​​​​a、b​​​​​​​之和。

示例 1:

输入: a = 1, b = 2
输出: 3


示例 2:

输入: a = -2, b = 3
输出: 1
两整数之和 - 领扣 (LeetCode)
给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。

如果有多个目标子集，返回其中任何一个均可。



示例 1:

输入: [1,2,3]
输出: [1,2] (当然, [1,3] 也正确)


示例 2:

输入: [1,2,4,8]
输出: [1,2,4,8]

最大整除子集 - 领扣 (LeetCode)
有效的完全平方数 - 领扣 (LeetCode)
给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。

说明：不要使用任何内置的库函数，如 sqrt。

示例 1：

输入：16
输出：True

示例 2：

输入：14
输出：False

水壶问题 - 领扣 (LeetCode)
有两个容量分别为x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好z升 的水？

如果可以，最后请用以上水壶中的一或两个来盛放取得的z升水。

你允许：


	装满任意一个水壶
	清空任意一个水壶
	从一个水壶向另外一个水壶倒水，直到装满或者倒空


示例 1: (From the famous Die Hard example)

输入: x = 3, y = 5, z = 4
输出: True


示例 2:

输入: x = 2, y = 6, z = 5
输出: False

矩形区域不超过 K 的最大数值和 - 领扣 (LeetCode)
给定一个非空二维矩阵matrix和一个整数 k，找到这个矩阵内部不大于 k 的最大矩形和。

示例:

输入: matrix = [[1,0,1],[0,-2,3]], k = 2
输出: 2 
解释:矩形区域[[0, 1], [-2, 3]]的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。


说明：


	矩阵内的矩形区域面积必须大于 0。
	如果行数远大于列数，你将如何解答呢？

计算各个位数不同的数字个数 - 领扣 (LeetCode)
给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 &le; x < 10n。

示例:

输入: 2
输出: 91 
解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。

设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：


	postTweet(userId, tweetId): 创建一条新的推文
	getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。
	follow(followerId, followeeId): 关注一个用户
	unfollow(followerId, followeeId): 取消关注一个用户


示例:


Twitter twitter = new Twitter();

// 用户1发送了一条新推文 (用户id = 1, 推文id = 5).
twitter.postTweet(1, 5);

// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.
twitter.getNewsFeed(1);

// 用户1关注了用户2.
twitter.follow(1, 2);

// 用户2发送了一个新推文 (推文id = 6).
twitter.postTweet(2, 6);

// 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -&gt; [6, 5].
// 推文id6应当在推文id5之前，因为它是在5之后发送的.
twitter.getNewsFeed(1);

// 用户1取消关注了用户2.
twitter.unfollow(1, 2);

// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.
// 因为用户1已经不再关注用户2.
twitter.getNewsFeed(1);

设计推特 - 领扣 (LeetCode)
给定一些标记了宽度和高度的信封，宽度和高度以整数对形式(w, h)出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组&ldquo;俄罗斯套娃&rdquo;信封（即可以把一个信封放到另一个信封里面）。

说明:
不允许旋转信封。

示例:

输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出: 3 
解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。

俄罗斯套娃信封问题 - 领扣 (LeetCode)
给定一个非负整数的数据流输入 a1，a2，&hellip;，an，&hellip;，将到目前为止看到的数字总结为不相交的间隔列表。

例如，假设数据流中的整数为 1，3，7，2，6，&hellip;，每次的总结为：


[1, 1]
[1, 1], [3, 3]
[1, 1], [3, 3], [7, 7]
[1, 3], [7, 7]
[1, 3], [6, 7]




进阶：
如果有很多合并，并且与数据流的大小相比，不相交间隔的数量很小，该怎么办?

提示：
特别感谢 @yunhong 提供了本问题和其测试用例。
将数据流变为多个不相交间隔 - 领扣 (LeetCode)
给定两个数组，编写一个函数来计算它们的交集。

示例 1:

输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2,2]


示例 2:

输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [4,9]

说明：


	输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
	我们可以不考虑输出结果的顺序。


进阶:


	如果给定的数组已经排好序呢？你将如何优化你的算法？
	如果nums1的大小比nums2小很多，哪种方法更优？
	如果nums2的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

两个数组的交集 II - 领扣 (LeetCode)
给定两个数组，编写一个函数来计算它们的交集。

示例 1:

输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]


示例 2:

输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]

说明:


	输出结果中的每个元素一定是唯一的。
	我们可以不考虑输出结果的顺序。

两个数组的交集 - 领扣 (LeetCode)
前K个高频元素 - 领扣 (LeetCode)
给定一个非空的整数数组，返回其中出现频率前k高的元素。

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]


示例 2:

输入: nums = [1], k = 1
输出: [1]

说明：


	你可以假设给定的k总是合理的，且 1 &le; k &le; 数组中不相同的元素的个数。
	你的算法的时间复杂度必须优于 O(n log n) ,n是数组的大小。

反转字符串中的元音字母 - 领扣 (LeetCode)
编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

示例 1:

输入: hello
输出: holle


示例 2:

输入: leetcode
输出: leotcede

说明:
元音字母不包含字母y。
编写一个函数，其作用是将输入的字符串反转过来。

示例1:

输入: hello
输出: olleh


示例 2:

输入: A man, a plan, a canal: Panama
输出: amanaP :lanac a ,nalp a ,nam A
反转字符串 - 领扣 (LeetCode)
给定一个正整数n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 &times; 1 = 1。

示例2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 &times;3 &times;4 = 36。

说明: 你可以假设n不小于 2 且不大于 58。
整数拆分 - 领扣 (LeetCode)
给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4的幂次方。

示例 1:

输入: 16
输出: true


示例 2:

输入: 5
输出: false

进阶：
你能不使用循环或者递归来完成本题吗？
4的幂 - 领扣 (LeetCode)
扁平化嵌套列表迭代器 - 领扣 (LeetCode)
给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。

列表中的项或者为一个整数，或者是另一个列表。

示例 1:

输入: [[1,1],2,[1,1]]
输出: [1,1,2,1,1]
解释: 通过重复调用next 直到hasNext 返回false，next返回的元素的顺序应该是: [1,1,2,1,1]。

示例 2:

输入: [1,[4,[6]]]
输出: [1,4,6]
解释: 通过重复调用next直到hasNext 返回false，next返回的元素的顺序应该是: [1,4,6]。

给定一个非负整数num。对于0 &le; i &le; num 范围中的每个数字i，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

输入: 2
输出: [0,1,1]

示例2:

输入: 5
输出: [0,1,1,2,1,2]

进阶:


	给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
	要求算法的空间复杂度为O(n)。
	你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的__builtin_popcount）来执行此操作。

比特位计数 - 领扣 (LeetCode)
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为&ldquo;根&rdquo;。 除了&ldquo;根&rdquo;之外，每栋房子有且只有一个&ldquo;父&ldquo;房子与之相连。一番侦察之后，聪明的小偷意识到&ldquo;这个地方的所有房屋的排列类似于一棵二叉树&rdquo;。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

示例 1:

输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释:小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

示例 2:

输入: [3,4,5,1,3,null,1]

    3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释:小偷一晚能够盗取的最高金额= 4 + 5 = 9.

打家劫舍 III - 领扣 (LeetCode)
给定一组唯一的单词， 找出所有不同的索引对(i, j)，使得列表中的两个单词，words[i] + words[j]，可拼接成回文串。

示例 1:

输入: [abcd,dcba,lls,s,sssll]
输出: [[0,1],[1,0],[3,2],[2,4]] 
解释: 可拼接成的回文串为 [dcbaabcd,abcddcba,slls,llssssll]


示例 2:

输入: [bat,tab,cat]
输出: [[0,1],[1,0]] 
解释: 可拼接成的回文串为 [battab,tabbat]
回文对 - 领扣 (LeetCode)
给定一个含有n个正数的数组x。从点(0,0)开始，先向北移动x[0]米，然后向西移动x[1]米，向南移动x[2]米，向东移动x[3]米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。

编写一个O(1)空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。

示例1:

输入: [2,1,1,2]

?????
?   ?
???????&gt;
    ?

输出: true 
解释: 路径交叉了


示例2:

输入: [1,2,3,4]

????????
?      ?
?
?
?????????????&gt;

输出: false 
解释: 路径没有相交


示例 3:

输入: [1,1,1,1]

?????
?   ?
?????&gt;

输出: true 
解释: 路径相交了

路径交叉 - 领扣 (LeetCode)
给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。

数学表达式如下:

如果存在这样的i, j, k,且满足0 &le; i < j < k &le; n-1，
使得arr[i] < arr[j] < arr[k] ，返回 true ;否则返回 false 。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。

示例 1:

输入: [1,2,3,4,5]
输出: true


示例 2:

输入: [5,4,3,2,1]
输出: false
递增的三元子序列 - 领扣 (LeetCode)
给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 出发。

说明:


	如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [JFK, LGA] 与 [JFK, LGB] 相比就更小，排序更靠前
	所有的机场都用三个大写字母表示（机场代码）。
	假定所有机票至少存在一种合理的行程。


示例 1:

输入: [[MUC, LHR], [JFK, MUC], [SFO, SJC], [LHR, SFO]]
输出: [JFK, MUC, LHR, SFO, SJC]


示例 2:

输入: [[JFK,SFO],[JFK,ATL],[SFO,ATL],[ATL,JFK],[ATL,SFO]]
输出: [JFK,ATL,JFK,SFO,ATL,SFO]
解释: 另一种有效的行程是[JFK,SFO,ATL,JFK,ATL,SFO]。但是它自然排序更大更靠后。
重新安排行程 - 领扣 (LeetCode)
验证二叉树的前序序列化 - 领扣 (LeetCode)
序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。

     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #


例如，上面的二叉树可以被序列化为字符串 9,3,4,#,#,1,#,#,2,#,6,#,#，其中 # 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 &#39;#&#39; 。

你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如1,,3 。

示例 1:

输入: 9,3,4,#,#,1,#,#,2,#,6,#,#
输出: true

示例2:

输入: 1,#
输出: false


示例 3:

输入: 9,#,#,1
输出: false
按要求补齐数组 - 领扣 (LeetCode)
给定一个已排序的正整数数组 nums，和一个正整数n 。从[1, n]区间内选取任意个数字补充到nums中，使得[1, n]区间内的任何数字都可以用nums中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

示例1:

输入: nums = [1,3], n = 6
输出: 1 
解释:
根据 nums里现有的组合[1], [3], [1,3]，可以得出1, 3, 4。
现在如果我们将2添加到nums 中，组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
其和可以表示数字1, 2, 3, 4, 5, 6，能够覆盖[1, 6]区间里所有的数。
所以我们最少需要添加一个数字。

示例 2:

输入: nums = [1,5,10], n = 20
输出: 2
解释: 我们需要添加[2, 4]。


示例3:

输入: nums = [1,2,2], n = 5
输出: 0

给定一个整数矩阵，找出最长递增路径的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。

示例 1:

输入: nums = 
[
  [9,9,4],
  [6,6,8],
  [2,1,1]
] 
输出: 4 
解释: 最长递增路径为[1, 2, 6, 9]。

示例 2:

输入: nums = 
[
  [3,4,5],
  [3,2,6],
  [2,2,1]
] 
输出: 4 
解释: 最长递增路径是[3, 4, 5, 6]。注意不允许在对角线方向上移动。

矩阵中的最长递增路径 - 领扣 (LeetCode)
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例 1:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL


示例 2:

输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 
输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL

说明:


	应当保持奇数节点和偶数节点的相对顺序。
	链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。

奇偶链表 - 领扣 (LeetCode)
区间和的个数 - 领扣 (LeetCode)
给定一个整数数组nums，返回区间和在[lower, upper]之间的个数，包含lower和upper。
区间和S(i, j)表示在nums中，位置从i到j的元素之和，包含i和j(i &le; j)。

说明:
最直观的算法复杂度是O(n2) ，请在此基础上优化你的算法。

示例:

输入: nums = [-2,5,-1], lower = -2, upper = 2,
输出: 3 
解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。

3的幂 - 领扣 (LeetCode)
给定一个整数，写一个函数来判断它是否是 3的幂次方。

示例 1:

输入: 27
输出: true


示例 2:

输入: 0
输出: false

示例 3:

输入: 9
输出: true

示例 4:

输入: 45
输出: false

进阶：
你能不使用循环或者递归来完成本题吗？
给定一个无序的数组nums，将它重新排列成nums[0] < nums[1] &gt; nums[2] < nums[3]...的顺序。

示例1:

输入: nums = [1, 5, 1, 1, 6, 4]
输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]

示例 2:

输入: nums = [1, 3, 2, 2, 3, 1]
输出: 一个可能的答案是 [2, 3, 1, 3, 1, 2]

说明:
你可以假设所有输入都会得到有效的结果。

进阶:
你能用O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？
摆动排序 II - 领扣 (LeetCode)
零钱兑换 - 领扣 (LeetCode)
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。

示例1:

输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1

示例 2:

输入: coins = [2], amount = 3
输出: -1

说明:
你可以认为每种硬币的数量是无限的。
拼接最大数 - 领扣 (LeetCode)
给定长度分别为m和n的两个数组，其元素由0-9构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n)个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为k的数组。

说明: 请尽可能地优化你算法的时间和空间复杂度。

示例1:

输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]

示例 2:

输入:
nums1 = [6, 7]
nums2 = [6, 0, 4]
k = 5
输出:
[6, 7, 6, 0, 4]

示例 3:

输入:
nums1 = [3, 9]
nums2 = [8, 9]
k = 3
输出:
[9, 8, 9]
灯泡开关 - 领扣 (LeetCode)
初始时有n个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第i 轮，每i个灯泡切换一次开关。 对于第n轮，你只切换最后一个灯泡的开关。 找出n轮后有多少个亮着的灯泡。

示例:

输入: 3
输出: 1 
解释: 
初始时, 灯泡状态 [关闭, 关闭, 关闭].
第一轮后, 灯泡状态 [开启, 开启, 开启].
第二轮后, 灯泡状态 [开启, 关闭, 开启].
第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 

你应该返回 1，因为只有一个灯泡还亮着。

给定一个字符串数组words，找到length(word[i]) * length(word[j])的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。

示例1:

输入: [abcw,baz,foo,bar,xtfn,abcdef]
输出: 16 
解释: 这两个单词为 abcw, xtfn。

示例 2:

输入: [a,ab,abc,d,cd,bcd,abcd]
输出: 4 
解释: 这两个单词为 ab, cd。

示例 3:

输入: [a,aa,aaa,aaaa]
输出: 0 
解释: 不存在这样的两个单词。
最大单词长度乘积 - 领扣 (LeetCode)
去除重复字母 - 领扣 (LeetCode)
给定一个仅包含小写字母的字符串，去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

示例 1:

输入: bcabc
输出: abc


示例 2:

输入: cbacdcbc
输出: acdb
计算右侧小于当前元素的个数 - 领扣 (LeetCode)
给定一个整数数组 nums，按要求返回一个新数组counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于nums[i] 的元素的数量。

示例:

输入: [5,2,6,1]
输出: [2,1,1,0] 
解释:
5 的右侧有 2 个更小的元素 (2 和 1).
2 的右侧仅有 1 个更小的元素 (1).
6 的右侧有 1 个更小的元素 (1).
1 的右侧有 0 个更小的元素.

超级丑数 - 领扣 (LeetCode)
编写一段程序来查找第 n 个超级丑数。

超级丑数是指其所有质因数都是长度为k的质数列表primes中的正整数。

示例:

输入: n = 12, primes = [2,7,13,19]
输出: 32 
解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。

说明:


	1是任何给定primes的超级丑数。
	给定primes中的数字以升序排列。
	0 < k &le; 100, 0 < n &le; 106, 0 < primes[i] < 1000 。
	第n个超级丑数确保在 32 位有符整数范围内。

有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组nums中。

现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得nums[left] * nums[i] * nums[right]个硬币。这里的left和right代表和i相邻的两个气球的序号。注意当你戳破了气球 i 后，气球left和气球right就变成了相邻的气球。

求所能获得硬币的最大数量。

说明:


	你可以假设nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
	0 &le; n &le; 500, 0 &le; nums[i] &le; 100


示例:

输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []
    coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167

戳气球 - 领扣 (LeetCode)
对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。

格式

该图包含n个节点，标记为0到n - 1。给定数字n和一个无向边edges列表（每一个边都是一对标签）。

你可以假设没有重复的边会出现在edges中。由于所有的边都是无向边， [0, 1]和[1, 0]是相同的，因此不会同时出现在edges里。

示例 1:

输入: n = 4, edges = [[1, 0], [1, 2], [1, 3]]

        0
        |
        1
       / \
      2   3 

输出: [1]


示例 2:

输入: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]

     0  1  2
      \ | /
        3
        |
        4
        |
        5 

输出: [3, 4]

说明:


	根据树的定义，树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。
	树的高度是指根节点和叶子节点之间最长向下路径上边的数量。

最小高度树 - 领扣 (LeetCode)
最佳买卖股票时机含冷冻期 - 领扣 (LeetCode)
给定一个整数数组，其中第i个元素代表了第i天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:


	你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
	卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。


示例:

输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
给定一个整数数组 nums，求出数组从索引i到j(i&le;j) 范围内元素的总和，包含i, j两点。

update(i, val) 函数可以通过将下标为i的数值更新为val，从而对数列进行修改。

示例:

Given nums = [1, 3, 5]

sumRange(0, 2) -&gt; 9
update(1, 2)
sumRange(0, 2) -&gt; 8


说明:


	数组仅可以在update函数下进行修改。
	你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。

区域和检索 - 数组可修改 - 领扣 (LeetCode)
累加数 - 领扣 (LeetCode)
累加数是一个字符串，组成它的数字可以形成累加序列。

一个有效的累加序列必须至少包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。

给定一个只包含数字&#39;0&#39;-&#39;9&#39;的字符串，编写一个算法来判断给定输入是否是累加数。

说明:累加序列里的数不会以 0 开头，所以不会出现1, 2, 03 或者1, 02, 3的情况。

示例 1:

输入: 112358
输出: true 
解释: 累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8


示例2:

输入: 199100199
输出: true 
解释: 累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199

进阶:
你如何处理一个溢出的过大的整数输入?
给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1,col1) ，右下角为 (row2,col2)。


上图子矩阵左上角(row1, col1) = (2, 1)，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。

示例:

给定 matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -&gt; 8
sumRegion(1, 1, 2, 2) -&gt; 11
sumRegion(1, 2, 2, 4) -&gt; 12


说明:


	你可以假设矩阵不可变。
	会多次调用sumRegion方法。
	你可以假设row1 &le; row2 且col1 &le; col2。

二维区域和检索 - 矩阵不可变 - 领扣 (LeetCode)
区域和检索 - 数组不可变 - 领扣 (LeetCode)
给定一个整数数组 nums，求出数组从索引i到j(i&le;j) 范围内元素的总和，包含i, j两点。

示例：

给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -&gt; 1
sumRange(2, 5) -&gt; -1
sumRange(0, 5) -&gt; -3

说明:


	你可以假设数组不可变。
	会多次调用sumRange方法。

删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。

说明: 输入可能包含了除(和)以外的字符。

示例 1:

输入: ()())()
输出: [()()(), (())()]


示例 2:

输入: (a)())()
输出: [(a)()(), (a())()]


示例 3:

输入: )(
输出: []
删除无效的括号 - 领扣 (LeetCode)
给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是[2,3,7,101]，它的长度是 4。

说明:


	可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
	你算法的时间复杂度应该为O(n2) 。


进阶: 你能将算法的时间复杂度降低到O(n log n) 吗?
最长上升子序列 - 领扣 (LeetCode)
你正在和你的朋友玩猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为&ldquo;Bulls&rdquo;, 公牛），有多少位数字猜对了但是位置不对（称为&ldquo;Cows&rdquo;, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。

请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用B表示奶牛。

请注意秘密数字和朋友的猜测数都可能含有重复数字。

示例 1:

输入: secret = 1807, guess = 7810

输出: 1A3B

解释: 1公牛和3奶牛。公牛是 8，奶牛是 0, 1和 7。

示例 2:

输入: secret = 1123, guess = 0111

输出: 1A1B

解释: 朋友猜测数中的第一个 1是公牛，第二个或第三个 1可被视为奶牛。

说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。
猜数字游戏 - 领扣 (LeetCode)
序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

示例:

你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 [1,2,3,null,null,4,5]

提示:这与 LeetCode 目前使用的方式一致，详情请参阅LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

说明:不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。
二叉树的序列化与反序列化 - 领扣 (LeetCode)
数据流的中位数 - 领扣 (LeetCode)
中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4]的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：


	void addNum(int num) - 从数据流中添加一个整数到数据结构中。
	double findMedian() - 返回目前所有元素的中位数。


示例：

addNum(1)
addNum(2)
findMedian() -&gt; 1.5
addNum(3) 
findMedian() -&gt; 2

进阶:


	如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？
	如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？

Nim游戏 - 领扣 (LeetCode)
你和你的朋友，两个人一起玩Nim游戏：桌子上有一堆石头，每次你们轮流拿掉1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。

你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。

示例:

输入: 4
输出: false 
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
    因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。

单词模式 - 领扣 (LeetCode)
给定一种 pattern(模式)和一个字符串str，判断 str 是否遵循相同的模式。

这里的遵循指完全匹配，例如，pattern里的每个字母和字符串str中的每个非空单词之间存在着双向连接的对应模式。

示例1:

输入: pattern = abba, str = dog cat cat dog
输出: true

示例 2:

输入:pattern = abba, str = dog cat cat fish
输出: false

示例 3:

输入: pattern = aaaa, str = dog cat cat dog
输出: false

示例4:

输入: pattern = abba, str = dog dog dog dog
输出: false

说明:
你可以假设pattern只包含小写字母，str包含了由单个空格分隔的小写字母。 
根据百度百科，生命游戏，简称为生命，是英国数学家约翰&middot;何顿&middot;康威在1970年发明的细胞自动机。

给定一个包含 m &times; n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live（1）即为活细胞， 或 dead（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：


	如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
	如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
	如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
	如果死细胞周围正好有三个活细胞，则该位置死细胞复活；


根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。

示例:

输入: 
[
 [0,1,0],
 [0,0,1],
 [1,1,1],
 [0,0,0]
]
输出: 
[
 [0,0,0],
 [1,0,1],
 [0,1,1],
 [0,1,0]
]

进阶:


	你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。
	本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？

生命游戏 - 领扣 (LeetCode)
给定一个包含n + 1 个整数的数组nums，其数字都在 1 到 n之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例 1:

输入: [1,3,4,2,2]
输出: 2


示例 2:

输入: [3,1,3,4,2]
输出: 3


说明：


	不能更改原数组（假设数组是只读的）。
	只能使用额外的 O(1) 的空间。
	时间复杂度小于 O(n2) 。
	数组中只有一个重复的数字，但它可能不止重复出现一次。

寻找重复数 - 领扣 (LeetCode)
顶端迭代器 - 领扣 (LeetCode)
给定一个迭代器类的接口，接口包含两个方法：next()和hasNext()。设计并实现一个支持peek()操作的顶端迭代器 -- 其本质就是把原本应由next()方法返回的元素peek()出来。

示例:

假设迭代器被初始化为列表[1,2,3]。

调用next() 返回 1，得到列表中的第一个元素。
现在调用peek()返回 2，下一个元素。在此之后调用next() 仍然返回 2。
最后一次调用next()返回 3，末尾元素。在此之后调用hasNext()应该返回 false。


进阶：你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？
移动零 - 领扣 (LeetCode)
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]

说明:


	必须在原数组上操作，不能拷贝额外的数组。
	尽量减少操作次数。

给表达式添加运算符 - 领扣 (LeetCode)
给定一个仅包含数字0-9的字符串和一个目标值，在数字之间添加二元运算符（不是一元）+、-或*，返回所有能够得到目标值的表达式。

示例 1:

输入: num = 123, target = 6
输出: [1+2+3, 1*2*3] 


示例2:

输入: num = 232, target = 8
输出: [2*3+2, 2+3*2]

示例 3:

输入: num = 105, target = 5
输出: [1*0+5,10-5]

示例4:

输入: num = 00, target = 0
输出: [0+0, 0-0, 0*0]


示例 5:

输入: num = 3456237490, target = 9191
输出: []

完全平方数 - 领扣 (LeetCode)
给定正整数n，找到若干个完全平方数（比如1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

示例1:

输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.

示例 2:

输入: n = 13
输出: 2
解释: 13 = 4 + 9.
你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用bool isBadVersion(version)接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

示例:

给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -&gt; false
调用 isBadVersion(5)-&gt; true
调用 isBadVersion(4)-&gt; true

所以，4 是第一个错误的版本。
第一个错误的版本 - 领扣 (LeetCode)
H指数 II - 领扣 (LeetCode)
给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。

h 指数的定义: &ldquo;一位有h指数的学者，代表他（她）的 N 篇论文中至多有 h 篇论文，分别被引用了至少h 次，其余的N - h篇论文每篇被引用次数不多于 h 次。

示例:

输入: citations = [0,1,3,5,6]
输出: 3 
解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。
    由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。

说明:

如果 h 有多有种可能的值 ，h 指数是其中最大的那个。

进阶：


	这是H指数的延伸题目，本题中的citations数组是保证有序的。
	你可以优化你的算法到对数时间复杂度吗？

给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h指数。

h 指数的定义: &ldquo;一位有h指数的学者，代表他（她）的 N 篇论文中至多有 h 篇论文，分别被引用了至少h 次，其余的N - h篇论文每篇被引用次数不多于 h 次。&rdquo;

示例:

输入: citations = [3,0,6,1,5]
输出: 3 
解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
    由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。

说明:如果 h 有多种可能的值，h 指数是其中最大的那个。
H指数 - 领扣 (LeetCode)
整数转换英文表示 - 领扣 (LeetCode)
将非负整数转换为其对应的英文表示。可以保证给定输入小于231 - 1 。

示例 1:

输入: 123
输出: One Hundred Twenty Three


示例 2:

输入: 12345
输出: Twelve Thousand Three Hundred Forty Five

示例 3:

输入: 1234567
输出: One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven

示例 4:

输入: 1234567891
输出: One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One
给定一个包含 0, 1, 2, ..., n中n个数的序列，找出 0 .. n中没有出现在序列中的那个数。

示例 1:

输入: [3,0,1]
输出: 2


示例2:

输入: [9,6,4,2,3,5,7,0,1]
输出: 8


说明:
你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?
缺失数字 - 领扣 (LeetCode)
编写一个程序，找出第 n 个丑数。

丑数就是只包含质因数2, 3, 5 的正整数。

示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

说明:


	1是丑数。
	n不超过1690。

丑数 II - 领扣 (LeetCode)
丑数 - 领扣 (LeetCode)
编写一个程序判断给定的数是否为丑数。

丑数就是只包含质因数2, 3, 5的正整数。

示例 1:

输入: 6
输出: true
解释: 6 = 2 &times;3

示例 2:

输入: 8
输出: true
解释: 8 = 2 &times; 2 &times;2


示例3:

输入: 14
输出: false 
解释: 14 不是丑数，因为它包含了另外一个质因数7。

说明：


	1是丑数。
	输入不会超过 32 位有符号整数的范围:[&minus;231, 231&minus; 1]。

行程和用户 - 领扣 (LeetCode)
Trips表中存所有出租车的行程信息。每段行程有唯一键 Id，Client_Id 和Driver_Id 是Users表中 Users_Id 的外键。Status 是枚举类型，枚举成员为 (&lsquo;completed&rsquo;, &lsquo;cancelled_by_driver&rsquo;, &lsquo;cancelled_by_client&rsquo;)。

+----+-----------+-----------+---------+--------------------+----------+
| Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at|
+----+-----------+-----------+---------+--------------------+----------+
| 1  |     1     |    10     |    1    |     completed      |2013-10-01|
| 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01|
| 3  |     3     |    12     |    6    |     completed      |2013-10-01|
| 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01|
| 5  |     1     |    10     |    1    |     completed      |2013-10-02|
| 6  |     2     |    11     |    6    |     completed      |2013-10-02|
| 7  |     3     |    12     |    6    |     completed      |2013-10-02|
| 8  |     2     |    12     |    12   |     completed      |2013-10-03|
| 9  |     3     |    10     |    12   |     completed      |2013-10-03| 
| 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03|
+----+-----------+-----------+---------+--------------------+----------+


Users表存所有用户。每个用户有唯一键 Users_Id。Banned 表示这个用户是否被禁止，Role 则是一个表示（&lsquo;client&rsquo;, &lsquo;driver&rsquo;, &lsquo;partner&rsquo;）的枚举类型。

+----------+--------+--------+
| Users_Id | Banned |  Role  |
+----------+--------+--------+
|    1     |   No   | client |
|    2     |   Yes  | client |
|    3     |   No   | client |
|    4     |   No   | client |
|    10    |   No   | driver |
|    11    |   No   | driver |
|    12    |   No   | driver |
|    13    |   No   | driver |
+----------+--------+--------+


写一段 SQL 语句查出2013年10月1日至2013年10月3日期间非禁止用户的取消率。基于上表，你的 SQL 语句应返回如下结果，取消率（Cancellation Rate）保留两位小数。

+------------+-------------------+
|     Day    | Cancellation Rate |
+------------+-------------------+
| 2013-10-01 |       0.33        |
| 2013-10-02 |       0.00        |
| 2013-10-03 |       0.50        |
+------------+-------------------+


致谢:
非常感谢@cak1erlizhou详细的提供了这道题和相应的测试用例。
只出现一次的数字 III - 领扣 (LeetCode)
给定一个整数数组nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

示例 :

输入: [1,2,1,3,2,5]
输出: [3,5]

注意：


	结果输出的顺序并不重要，对于上面的例子，[5, 3]也是正确答案。
	你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。

示例:

输入: 38
输出: 2 
解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于2 是一位数，所以返回 2。


进阶:
你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？
各位相加 - 领扣 (LeetCode)
给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明:叶子节点是指没有子节点的节点。

示例:

输入:

   1
 /   \
2     3
 \
  5

输出: [1-&gt;2-&gt;5, 1-&gt;3]

解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3
二叉树的所有路径 - 领扣 (LeetCode)
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。

示例1:

输入: s = anagram, t = nagaram
输出: true


示例 2:

输入: s = rat, t = car
输出: false

说明:
你可以假设字符串只包含小写字母。

进阶:
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
有效的字母异位词 - 领扣 (LeetCode)
为运算表达式设计优先级 - 领扣 (LeetCode)
给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +,-以及*。

示例1:

输入: 2-1-1
输出: [0, 2]
解释: 
((2-1)-1) = 0 
(2-(1-1)) = 2

示例2:

输入: 2*3-4*5
输出: [-34, -14, -10, -10, 10]
解释: 
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
搜索二维矩阵 II - 领扣 (LeetCode)
编写一个高效的算法来搜索mxn矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：


	每行的元素从左到右升序排列。
	每列的元素从上到下升序排列。


示例:

现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]


给定 target=5，返回true。

给定target=20，返回false。
滑动窗口最大值 - 领扣 (LeetCode)
给定一个数组 nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。

返回滑动窗口最大值。

示例:

输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

注意：

你可以假设 k 总是有效的，1 &le; k &le;输入数组的大小，且输入数组不为空。

进阶：

你能在线性时间复杂度内解决此题吗？
除自身以外数组的乘积 - 领扣 (LeetCode)
给定长度为n的整数数组nums，其中n &gt; 1，返回输出数组output，其中 output[i]等于nums中除nums[i]之外其余各元素的乘积。

示例:

输入: [1,2,3,4]
输出: [24,12,8,6]

说明: 请不要使用除法，且在O(n) 时间复杂度内完成此题。

进阶：
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
删除链表中的节点 - 领扣 (LeetCode)
请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

现有一个链表 --head =[4,5,1,9]，它可以表示为:

    4 -&gt; 5 -&gt; 1 -&gt; 9


示例 1:

输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为5的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.


示例 2:

输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为1的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.


说明:


	链表至少包含两个节点。
	链表中所有节点的值都是唯一的。
	给定的节点为非末尾节点并且一定是链表中的一个有效节点。
	不要从你的函数中返回任何结果。

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：&ldquo;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。&rdquo;

例如，给定如下二叉树: root =[3,5,1,6,2,0,8,null,null,7,4]

        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4


示例 1:

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。


示例2:

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。


说明:


	所有节点的值都是唯一的。
	p、q 为不同节点且均存在于给定的二叉树中。

二叉树的最近公共祖先 - 领扣 (LeetCode)
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：&ldquo;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。&rdquo;

例如，给定如下二叉搜索树: root =[6,2,8,0,4,7,9,null,null,3,5]

        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5


示例 1:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。


示例 2:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。

说明:


	所有节点的值都是唯一的。
	p、q 为不同节点且均存在于给定的二叉搜索树中。

二叉搜索树的最近公共祖先 - 领扣 (LeetCode)
请判断一个链表是否为回文链表。

示例 1:

输入: 1-&gt;2
输出: false

示例 2:

输入: 1-&gt;2-&gt;2-&gt;1
输出: true


进阶：
你能否用O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
回文链表 - 领扣 (LeetCode)
给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。

示例:

输入: 13
输出: 6 
解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。
数字1的个数 - 领扣 (LeetCode)
使用栈实现队列的下列操作：


	push(x) -- 将一个元素放入队列的尾部。
	pop() -- 从队列首部移除元素。
	peek() -- 返回队列首部的元素。
	empty() -- 返回队列是否为空。


示例:

MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false

说明:


	你只能使用标准的栈操作 -- 也就是只有push to top,peek/pop from top,size, 和is empty操作是合法的。
	你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
	假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。

用栈实现队列 - 领扣 (LeetCode)
给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

示例1:

输入: 1
输出: true
解释: 20= 1

示例 2:

输入: 16
输出: true
解释: 24= 16

示例 3:

输入: 218
输出: false
2的幂 - 领扣 (LeetCode)
给定一个二叉搜索树，编写一个函数kthSmallest来查找其中第k个最小的元素。

说明：
你可以假设 k 总是有效的，1 &le; k &le; 二叉搜索树元素个数。

示例 1:

输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
  2
输出: 1

示例 2:

输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 3

进阶：
如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化kthSmallest函数？
二叉搜索树中第K小的元素 - 领扣 (LeetCode)
求众数 II - 领扣 (LeetCode)
给定一个大小为n的数组，找出其中所有出现超过&lfloor; n/3 &rfloor;次的元素。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

示例1:

输入: [3,2,3]
输出: [3]

示例 2:

输入: [1,1,1,3,3,2,2,2]
输出: [1,2]
给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。

示例 1:

输入: [0,1,2,4,5,7]
输出: [0-&gt;2,4-&gt;5,7]
解释: 0,1,2 可组成一个连续的区间;4,5 可组成一个连续的区间。

示例 2:

输入: [0,2,3,4,6,8,9]
输出: [0,2-&gt;4,6,8-&gt;9]
解释: 2,3,4 可组成一个连续的区间;8,9 可组成一个连续的区间。
汇总区间 - 领扣 (LeetCode)
基本计算器 II - 领扣 (LeetCode)
实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格。 整数除法仅保留整数部分。

示例1:

输入: 3+2*2
输出: 7


示例 2:

输入:  3/2 
输出: 1

示例 3:

输入:  3+5 / 2 
输出: 5


说明：


	你可以假设所给定的表达式都是有效的。
	请不要使用内置的库函数 eval。

翻转一棵二叉树。

示例：

输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9

输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1

备注:
这个问题是受到 Max Howell 的 原问题 启发的 ：

谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。
翻转二叉树 - 领扣 (LeetCode)
用队列实现栈 - 领扣 (LeetCode)
使用队列实现栈的下列操作：


	push(x) -- 元素 x 入栈
	pop() -- 移除栈顶元素
	top() -- 获取栈顶元素
	empty() -- 返回栈是否为空


注意:


	你只能使用队列的基本操作-- 也就是push to back, peek/pop from front, size, 和is empty这些操作是合法的。
	你所使用的语言也许不支持队列。你可以使用 list 或者 deque（双端队列）来模拟一个队列, 只要是标准的队列操作即可。
	你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

基本计算器 - 领扣 (LeetCode)
实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式可以包含左括号(，右括号)，加号+，减号-，非负整数和空格。

示例 1:

输入: 1 + 1
输出: 2


示例 2:

输入:  2-1 + 2 
输出: 3

示例 3:

输入: (1+(4+5+2)-3)+(6+8)
输出: 23

说明：


	你可以假设所给定的表达式都是有效的。
	请不要使用内置的库函数 eval。

在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。

每个矩形由其左下顶点和右上顶点坐标表示，如图所示。



示例:

输入: -3, 0, 3, 4, 0, -1, 9, 2
输出: 45

说明: 假设矩形面积不会超出int的范围。
矩形面积 - 领扣 (LeetCode)
完全二叉树的节点个数 - 领扣 (LeetCode)
给出一个完全二叉树，求出该树的节点个数。

说明：

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~2h个节点。

示例:

输入: 
    1
   / \
  2   3
 / \  /
4  5 6

输出: 6
最大正方形 - 领扣 (LeetCode)
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

示例:

输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
存在重复元素 III - 领扣 (LeetCode)
给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得nums [i] 和nums [j]的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。

示例1:

输入: nums = [1,2,3,1], k = 3, t = 0
输出: true

示例 2:

输入: nums = [1,0,1,1], k = 1, t = 2
输出: true

示例 3:

输入: nums = [1,5,9,1,5,9], k = 2, t = 3
输出: false
给定一个整数数组和一个整数k，判断数组中是否存在两个不同的索引i和j，使得nums [i] = nums [j]，并且 i 和 j的差的绝对值最大为 k。

示例1:

输入: nums = [1,2,3,1], k = 3
输出: true

示例 2:

输入: nums = [1,0,1,1], k = 1
输出: true

示例 3:

输入: nums = [1,2,3,1,2,3], k = 2
输出: false
存在重复元素 II - 领扣 (LeetCode)
城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。现在，假设您获得了城市风光照片（图A）上显示的所有建筑物的位置和高度，请编写一个程序以输出由这些建筑物形成的天际线（图B）。





      



每个建筑物的几何信息用三元组[Li，Ri，Hi] 表示，其中 Li 和 Ri 分别是第 i 座建筑物左右边缘的 x 坐标，Hi 是其高度。可以保证0 &le; Li, Ri &le; INT_MAX,0 < Hi &le; INT_MAX 和 Ri - Li &gt; 0。您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的完美矩形。



例如，图A中所有建筑物的尺寸记录为：[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] 。



输出是以[ [x1,y1], [x2, y2], [x3, y3], ... ] 格式的&ldquo;关键点&rdquo;（图B中的红点）的列表，它们唯一地定义了天际线。关键点是水平线段的左端点。请注意，最右侧建筑物的最后一个关键点仅用于标记天际线的终点，并始终为零高度。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。



例如，图B中的天际线应该表示为：[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]。



说明:





	任何输入列表中的建筑物数量保证在 [0, 10000]范围内。

	输入列表已经按升序排列在左边的 x 位置 Li 。

	输出列表必须按 x 位排序。

	输出天际线中不得有连续的相同高度的水平线。例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]

天际线问题 - 领扣 (LeetCode)
给定一个整数数组，判断是否存在重复元素。

如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。

示例 1:

输入: [1,2,3,1]
输出: true

示例 2:

输入: [1,2,3,4]
输出: false

示例3:

输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
存在重复元素 - 领扣 (LeetCode)
组合总和 III - 领扣 (LeetCode)
找出所有相加之和为n 的k个数的组合。组合中只允许含有 1 -9 的正整数，并且每种组合中不存在重复的数字。

说明：


	所有数字都是正整数。
	解集不能包含重复的组合。


示例 1:

输入: k = 3, n = 7
输出: [[1,2,4]]


示例 2:

输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]

数组中的第K个最大元素 - 领扣 (LeetCode)
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5


示例2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4

说明: 

你可以假设 k 总是有效的，且 1 &le; k &le; 数组的长度。
最短回文串 - 领扣 (LeetCode)
给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

示例1:

输入: aacecaaa
输出: aaacecaaa


示例 2:

输入: abcd
输出: dcbabcd
找工作备战技术面试？快来 LeetCode 练习、提升技术水平，轻松迎接挑战。Loading...
单词搜索 II - 领扣 (LeetCode)
给定一个二维网格board和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中&ldquo;相邻&rdquo;单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

示例:

输入: 
words = [oath,pea,eat,rain] and board =
[
  [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;],
  [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;],
  [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;],
  [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]
]

输出:[eat,oath]

说明:
你可以假设所有输入都由小写字母 a-z组成。

提示:


	你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？
	如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。

设计一个支持以下两种操作的数据结构：

void addWord(word)
bool search(word)


search(word)可以搜索文字或正则表达式字符串，字符串只包含字母.或a-z。. 可以表示任何一个字母。

示例:

addWord(bad)
addWord(dad)
addWord(mad)
search(pad) -&gt; false
search(bad) -&gt; true
search(.ad) -&gt; true
search(b..) -&gt; true


说明:

你可以假设所有单词都是由小写字母 a-z组成的。
添加与搜索单词 - 数据结构设计 - 领扣 (LeetCode)
现在你总共有 n 门课需要选，记为0到n-1。

在选修某些课程之前需要一些先修课程。例如，想要学习课程 0 ，你需要先完成课程1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

示例1:

输入: 2, [[1,0]] 
输出: [0,1]
解释:总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。

示例2:

输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释:总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
    因此，一个正确的课程顺序是[0,1,2,3] 。另一个正确的排序是[0,2,1,3] 。


说明:


	输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。
	你可以假定输入的先决条件中没有重复的边。


提示:


	这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。
	通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。
	
	拓扑排序也可以通过BFS完成。
	

课程表 II - 领扣 (LeetCode)
给定一个含有n个正整数的数组和一个正整数s ，找出该数组中满足其和 &ge; s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。

示例:

输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组[4,3]是该条件下的长度最小的连续子数组。


进阶:

如果你已经完成了O(n) 时间复杂度的解法, 请尝试O(n log n) 时间复杂度的解法。
长度最小的子数组 - 领扣 (LeetCode)
实现 Trie (前缀树) - 领扣 (LeetCode)
实现一个 Trie (前缀树)，包含insert,search, 和startsWith这三个操作。

示例:

Trie trie = new Trie();

trie.insert(apple);
trie.search(apple);   // 返回 true
trie.search(app);     // 返回 false
trie.startsWith(app); // 返回 true
trie.insert(app);   
trie.search(app);     // 返回 true

说明:


	你可以假设所有的输入都是由小写字母a-z构成的。
	保证所有输入均为非空字符串。

课程表 - 领扣 (LeetCode)
现在你总共有 n 门课需要选，记为0到n-1。

在选修某些课程之前需要一些先修课程。例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？

示例 1:

输入: 2, [[1,0]] 
输出: true
解释:总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。

示例 2:

输入: 2, [[1,0],[0,1]]
输出: false
解释:总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。

说明:


	输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。
	你可以假定输入的先决条件中没有重复的边。


提示:


	这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。
	通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。
	
	拓扑排序也可以通过BFS完成。
	

找工作备战技术面试？快来 LeetCode 练习、提升技术水平，轻松迎接挑战。Loading...
给定两个字符串s和t，判断它们是否是同构的。

如果s中的字符可以被替换得到t，那么这两个字符串是同构的。

所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。

示例 1:

输入: s = egg, t = add
输出: true


示例 2:

输入: s = foo, t = bar
输出: false

示例 3:

输入: s = paper, t = title
输出: true

说明:
你可以假设s和 t 具有相同的长度。
同构字符串 - 领扣 (LeetCode)
统计所有小于非负整数n的质数的数量。

示例:

输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。

计数质数 - 领扣 (LeetCode)
移除链表元素 - 领扣 (LeetCode)
删除链表中等于给定值val的所有节点。

示例:

输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6
输出: 1-&gt;2-&gt;3-&gt;4-&gt;5

编写一个算法来判断一个数是不是&ldquo;快乐数&rdquo;。

一个&ldquo;快乐数&rdquo;定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。

示例:

输入: 19
输出: true
解释: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

快乐数 - 领扣 (LeetCode)
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

示例 1:

输入: [5,7]
输出: 4

示例 2:

输入: [0,1]
输出: 0
数字范围按位与 - 领扣 (LeetCode)
给定一个由&#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。

示例 1:

输入:
11110
11010
11000
00000

输出:1


示例2:

输入:
11000
11000
00100
00011

输出: 3

岛屿的个数 - 领扣 (LeetCode)
二叉树的右视图 - 领扣 (LeetCode)
给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

输入:[1,2,3,null,5,null,4]
输出:[1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---

打家劫舍 - 领扣 (LeetCode)
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
    偷窃到的最高金额 = 1 + 3 = 4 。

示例 2:

输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
    偷窃到的最高金额 = 2 + 9 + 1 = 12 。

给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。

+---------+------------------+------------------+
| Id(INT) | RecordDate(DATE) | Temperature(INT) |
+---------+------------------+------------------+
|       1 |       2015-01-01 |               10 |
|       2 |       2015-01-02 |               25 |
|       3 |       2015-01-03 |               20 |
|       4 |       2015-01-04 |               30 |
+---------+------------------+------------------+

例如，根据上述给定的 Weather 表格，返回如下 Id:

+----+
| Id |
+----+
|  2 |
|  4 |
+----+
上升的温度 - 领扣 (LeetCode)
删除重复的电子邮箱 - 领扣 (LeetCode)
编写一个 SQL 查询，来删除Person表中所有重复的电子邮箱，重复的邮箱里只保留Id最小的那个。

+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Id 是这个表的主键。


例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行:

+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+

第十行 - 领扣 (LeetCode)
给定一个文本文件file.txt，请只打印这个文件中的第十行。

示例:

假设file.txt 有如下内容：

Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10


你的脚本应当显示第十行：

Line 10


说明:
1. 如果文件少于十行，你应当输出什么？
2. 至少有三种不同的解法，请尝试尽可能多的方法来解题。
给定一个文件file.txt，转置它的内容。

你可以假设每行列数相同，并且每个字段由&#39; &#39; 分隔.

示例:

假设file.txt文件内容如下：

name age
alice 21
ryan 30


应当输出：

name alice ryan
age 21 30

转置文件 - 领扣 (LeetCode)
给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个 bash 脚本输出所有有效的电话号码。

你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或xxx-xxx-xxxx。（x 表示一个数字）

你也可以假设每行前后没有多余的空格字符。

示例:

假设file.txt内容如下：

987-123-4567
123 456 7890
(123) 456-7890


你的脚本应当输出下列有效的电话号码：

987-123-4567
(123) 456-7890

有效电话号码 - 领扣 (LeetCode)
找工作备战技术面试？快来 LeetCode 练习、提升技术水平，轻松迎接挑战。Loading...
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 &lsquo;1&rsquo;的个数（也被称为汉明重量）。

示例:

输入: 11
输出: 3
解释: 整数 11 的二进制表示为 00000000000000000000000000001011



示例2:

输入: 128
输出: 1
解释: 整数 128 的二进制表示为 00000000000000000000000010000000
位1的个数 - 领扣 (LeetCode)
颠倒给定的 32 位无符号整数的二进制位。

示例:

输入: 43261596
输出: 964176192
解释: 43261596 的二进制表示形式为 00000010100101000001111010011100 ，
    返回 964176192，其二进制表示形式为 00111001011110000010100101000000 。

进阶:
如果多次调用这个函数，你将如何优化你的算法？
颠倒二进制位 - 领扣 (LeetCode)
给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数。

示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]


示例2:

输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]

说明:


	尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
	要求使用空间复杂度为O(1) 的原地算法。

旋转数组 - 领扣 (LeetCode)
买卖股票的最佳时机 IV - 领扣 (LeetCode)
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意:你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例1:

输入: [2,4,1], k = 2
输出: 2
解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。


示例 2:

输入: [3,2,6,5,0,3], k = 2
输出: 7
解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
    随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：&ldquo;ACGAATTCCG&rdquo;。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。

编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。

示例:

输入: s = AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT

输出: [AAAAACCCCC, CCCCCAAAAA]
重复的DNA序列 - 领扣 (LeetCode)
Employee 表包含所有员工信息，每个员工有其对应的Id, salary 和 department Id 。

+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
| 5  | Janet | 69000  | 1            |
| 6  | Randy | 85000  | 1            |
+----+-------+--------+--------------+


Department 表包含公司所有部门的信息。

+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+


编写一个SQL 查询，找出每个部门工资前三高的员工。例如，根据上述给定的表格，查询结果应返回：

+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Randy    | 85000  |
| IT         | Joe      | 70000  |
| Sales      | Henry    | 80000  |
| Sales      | Sam      | 60000  |
+------------+----------+--------+

部门工资前三高的员工 - 领扣 (LeetCode)
Employee 表包含所有员工信息，每个员工有其对应的Id, salary 和 department Id。

+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
+----+-------+--------+--------------+


Department表包含公司所有部门的信息。

+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+


编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。

+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+

部门工资最高的员工 - 领扣 (LeetCode)
某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。

Customers 表：

+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+


Orders 表：

+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+


例如给定上述表格，你的查询应返回：

+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+

从不订购的客户 - 领扣 (LeetCode)
编写一个 SQL 查询，查找Person 表中所有重复的电子邮箱。

示例：

+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+


根据以上输入，你的查询应返回以下结果：

+---------+
| Email   |
+---------+
| a@b.com |
+---------+


说明：所有电子邮箱都是小写字母。
查找重复的电子邮箱 - 领扣 (LeetCode)
超过经理收入的员工 - 领扣 (LeetCode)
Employee表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。

+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+


给定Employee表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。

+----------+
| Employee |
+----------+
| Joe      |
+----------+

连续出现的数字 - 领扣 (LeetCode)
编写一个 SQL 查询，查找所有至少连续出现三次的数字。

+----+-----+
| Id | Num |
+----+-----+
| 1  |  1  |
| 2  |  1  |
| 3  |  1  |
| 4  |  2  |
| 5  |  1  |
| 6  |  2  |
| 7  |  2  |
+----+-----+


例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。

+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+

给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。

示例 1:

输入: [10,2]
输出: 210

示例2:

输入: [3,30,34,5,9]
输出: 9534330

说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。
最大数 - 领扣 (LeetCode)
编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有&ldquo;间隔&rdquo;。

+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+


例如，根据上述给定的Scores 表，你的查询应该返回（按分数从高到低排列）：

+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
|3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+

分数排名 - 领扣 (LeetCode)
编写一个 SQL 查询，获取 Employee 表中第n高的薪水（Salary）。

+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+


例如上述Employee表，n = 2时，应返回第二高的薪水200。如果不存在第n高的薪水，那么查询应返回null。

+------------------------+
| getNthHighestSalary(2) |
+------------------------+
| 200                    |
+------------------------+

第N高的薪水 - 领扣 (LeetCode)
编写一个 SQL 查询，获取 Employee表中第二高的薪水（Salary）。

+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+


例如上述Employee表，SQL查询应该返回200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。

+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+

第二高的薪水 - 领扣 (LeetCode)
组合两个表 - 领扣 (LeetCode)
表1: Person

+-------------+---------+
| 列名         | 类型     |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId 是上表主键


表2: Address

+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId 是上表主键




编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供person 的以下信息：



FirstName, LastName, City, State

地下城游戏 - 领扣 (LeetCode)


table.dungeon, .dungeon th, .dungeon td {

  border:3px solid black;

}



 .dungeon th, .dungeon td {

    text-align: center;

    height: 70px;

    width: 70px;

}





一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。



骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。



有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。



为了尽快到达公主，骑士决定每次只向右或向下移动一步。







编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。



例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。





 

-2 (K) 

-3 

3 

 

 

-5 

-10 

1 

 

 

10 

30 

-5 (P) 

 











说明:





	

	骑士的健康点数没有上限。

	

	任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。

调用 next() 将返回二叉搜索树中的下一个最小的数。

注意: next() 和hasNext()操作的时间复杂度是O(1)，并使用O(h)内存，其中h是树的高度。
二叉搜索树迭代器 - 领扣 (LeetCode)
给定一个整数 n，返回 n! 结果尾数中零的数量。

示例 1:

输入: 3
输出: 0
解释:3! = 6, 尾数中没有零。

示例2:

输入: 5
输出: 1
解释:5! = 120, 尾数中有 1 个零.

说明: 你算法的时间复杂度应为O(logn)。
阶乘后的零 - 领扣 (LeetCode)
给定一个Excel表格中的列名称，返回其相应的列序号。

例如，

    A -&gt; 1
    B -&gt; 2
    C -&gt; 3
    ...
    Z -&gt; 26
    AA -&gt; 27
    AB -&gt; 28 
    ...


示例 1:

输入: A
输出: 1


示例2:

输入: AB
输出: 28


示例3:

输入: ZY
输出: 701

致谢：
特别感谢@ts添加此问题并创建所有测试用例。
Excel表列序号 - 领扣 (LeetCode)
给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于&lfloor; n/2 &rfloor;的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

示例1:

输入: [3,2,3]
输出: 3

示例2:

输入: [2,2,1,1,1,2,2]
输出: 2

求众数 - 领扣 (LeetCode)
给定一个正整数，返回它在 Excel 表中相对应的列名称。

例如，

    1 -&gt; A
    2 -&gt; B
    3 -&gt; C
    ...
    26 -&gt; Z
    27 -&gt; AA
    28 -&gt; AB 
    ...


示例 1:

输入: 1
输出: A


示例2:

输入: 28
输出: AB


示例3:

输入: 701
输出: ZY

Excel表列名称 - 领扣 (LeetCode)
给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1必须小于index2。

说明:


	返回的下标值（index1 和 index2）不是从零开始的。
	你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。


示例:

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
两数之和 II - 输入有序数组 - 领扣 (LeetCode)
分数到小数 - 领扣 (LeetCode)
给定两个整数，分别表示分数的分子numerator 和分母 denominator，以字符串形式返回小数。

如果小数部分为循环小数，则将循环的部分括在括号内。

示例 1:

输入: numerator = 1, denominator = 2
输出: 0.5


示例2:

输入: numerator = 2, denominator = 1
输出: 2

示例3:

输入: numerator = 2, denominator = 3
输出: 0.(6)

比较两个版本号 version1和 version2。
如果version1&gt;version2返回1，如果version1<version2 返回 -1， 除此之外返回 0。

你可以假设版本字符串非空，并且只包含数字和. 字符。

. 字符不代表小数点，而是用于分隔数字序列。

例如，2.5 不是&ldquo;两个半&rdquo;，也不是&ldquo;差一半到三&rdquo;，而是第二版中的第五个小版本。

示例1:

输入: version1 = 0.1, version2 = 1.1
输出: -1

示例 2:

输入: version1 = 1.0.1, version2 = 1
输出: 1

示例 3:

输入: version1 = 7.5.2.4, version2 = 7.5.3
输出: -1
比较版本号 - 领扣 (LeetCode)
给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。

如果数组元素个数小于 2，则返回 0。

示例1:

输入: [3,6,9,1]
输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。

示例2:

输入: [10]
输出: 0
解释: 数组元素个数小于 2，因此返回 0。

说明:


	你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。
	请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。

最大间距 - 领扣 (LeetCode)
峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组nums，其中 nums[i] &ne; nums[i+1]，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

你可以假设nums[-1] = nums[n] = -&infin;。

示例 1:

输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。

示例2:

输入: nums = [1,2,1,3,5,6,4]
输出: 1 或 5 
解释: 你的函数可以返回索引 1，其峰值元素为 2；
    或者返回索引 5， 其峰值元素为 6。


说明:

你的解法应该是O(logN)时间复杂度的。
寻找峰值 - 领扣 (LeetCode)
编写一个程序，找到两个单链表相交的起始节点。



例如，下面的两个链表：

A:          a1 &rarr; a2
                   ↘
                     c1 &rarr; c2 &rarr; c3
                   ↗            
B:     b1 &rarr; b2 &rarr; b3


在节点 c1 开始相交。



注意：


	如果两个链表没有交点，返回 null.
	在返回结果后，两个链表仍须保持原有的结构。
	可假定整个链表结构中没有循环。
	程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。




致谢:
特别感谢@stellari 添加此问题并创建所有测试用例。
相交链表 - 领扣 (LeetCode)
设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。


	push(x)-- 将元素 x 推入栈中。
	pop()-- 删除栈顶的元素。
	top()-- 获取栈顶元素。
	getMin() -- 检索栈中的最小元素。


示例:

MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.

最小栈 - 领扣 (LeetCode)
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组[0,1,2,4,5,6,7]  可能变为[4,5,6,7,0,1,2])。

请找出其中最小的元素。

注意数组中可能存在重复的元素。

示例 1：

输入: [1,3,5]
输出: 1

示例2：

输入: [2,2,2,0,1]
输出: 0

说明：


	这道题是寻找旋转排序数组中的最小值的延伸题目。
	允许重复会影响算法的时间复杂度吗？会如何影响，为什么？

寻找旋转排序数组中的最小值 II - 领扣 (LeetCode)
寻找旋转排序数组中的最小值 - 领扣 (LeetCode)
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组[0,1,2,4,5,6,7]  可能变为[4,5,6,7,0,1,2])。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

示例 1:

输入: [3,4,5,1,2]
输出: 1

示例 2:

输入: [4,5,6,7,0,1,2]
输出: 0
给定一个整数数组 nums，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

示例 1:

输入: [2,3,-2,4]
输出: 6
解释:子数组 [2,3] 有最大乘积 6。


示例 2:

输入: [-2,0,-1]
输出: 0
解释:结果不能为 2, 因为 [-2,-1] 不是子数组。
乘积最大子序列 - 领扣 (LeetCode)
给定一个字符串，逐个翻转字符串中的每个单词。

示例:

输入: the sky is blue,
输出:blue is sky the.


说明:


	无空格字符构成一个单词。
	输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
	如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。


进阶:请选用C语言的用户尝试使用O(1) 空间复杂度的原地解法。
翻转字符串里的单词 - 领扣 (LeetCode)
逆波兰表达式求值 - 领扣 (LeetCode)
根据逆波兰表示法，求表达式的值。

有效的运算符包括+,-,*,/。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：


	整数除法只保留整数部分。
	给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。


示例1：

输入: [2, 1, +, 3, *]
输出: 9
解释: ((2 + 1) * 3) = 9


示例2：

输入: [4, 13, 5, /, +]
输出: 6
解释: (4 + (13 / 5)) = 6


示例3：

输入: [10, 6, 9, 3, +, -11, *, /, *, 17, +, 5, +]
输出: 22
解释: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
直线上最多的点数 - 领扣 (LeetCode)
给定一个二维平面，平面上有n个点，求最多有多少个点在同一条直线上。

示例 1:

输入: [[1,1],[2,2],[3,3]]
输出: 3
解释:
^
|
|    o
|   o
| o 
+-------------&gt;
0 1 2 3  4


示例2:

输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出: 4
解释:
^
|
|  o
| o      o
|    o
| o       o
+-------------------&gt;
0 1 2 3 4 5 6
在O(nlogn) 时间复杂度和常数级空间复杂度下，对链表进行排序。

示例 1:

输入: 4-&gt;2-&gt;1-&gt;3
输出: 1-&gt;2-&gt;3-&gt;4


示例 2:

输入: -1-&gt;5-&gt;3-&gt;4-&gt;0
输出: -1-&gt;0-&gt;3-&gt;4-&gt;5
排序链表 - 领扣 (LeetCode)
对链表进行插入排序。


插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。



插入排序算法：


	插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
	每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
	重复直到所有输入数据插入完为止。




示例 1：

输入: 4-&gt;2-&gt;1-&gt;3
输出: 1-&gt;2-&gt;3-&gt;4


示例2：

输入: -1-&gt;5-&gt;3-&gt;4-&gt;0
输出: -1-&gt;0-&gt;3-&gt;4-&gt;5

对链表进行插入排序 - 领扣 (LeetCode)
运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

进阶:

你是否可以在O(1) 时间复杂度内完成这两种操作？

示例:

LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4

LRU缓存机制 - 领扣 (LeetCode)
给定一个二叉树，返回它的 后序遍历。

示例:

输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]

进阶:递归算法很简单，你可以通过迭代算法完成吗？
二叉树的后序遍历 - 领扣 (LeetCode)
给定一个二叉树，返回它的前序遍历。

示例:

输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]


进阶:递归算法很简单，你可以通过迭代算法完成吗？
二叉树的前序遍历 - 领扣 (LeetCode)
重排链表 - 领扣 (LeetCode)
给定一个单链表L：L0&rarr;L1&rarr;&hellip;&rarr;Ln-1&rarr;Ln ，
将其重新排列后变为： L0&rarr;Ln&rarr;L1&rarr;Ln-1&rarr;L2&rarr;Ln-2&rarr;&hellip;

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例1:

给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.

示例 2:

给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.
环形链表 II - 领扣 (LeetCode)
给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null。

说明：不允许修改给定的链表。

进阶：
你是否可以不用额外空间解决此题？
环形链表 - 领扣 (LeetCode)
给定一个链表，判断链表中是否有环。

进阶：
你能否不使用额外空间解决此题？
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。

说明：


	分隔时可以重复使用字典中的单词。
	你可以假设字典中没有重复的单词。


示例 1：

输入:
s = catsanddog
wordDict = [cat, cats, and, sand, dog]
输出:
[
 cats and dog,
 cat sand dog
]


示例 2：

输入:
s = pineapplepenapple
wordDict = [apple, pen, applepen, pine, pineapple]
输出:
[
 pine apple pen apple,
 pineapple pen apple,
 pine applepen apple
]
解释: 注意你可以重复使用字典中的单词。


示例3：

输入:
s = catsandog
wordDict = [cats, dog, sand, and, cat]
输出:
[]

单词拆分 II - 领扣 (LeetCode)
单词拆分 - 领扣 (LeetCode)
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：


	拆分时可以重复使用字典中的单词。
	你可以假设字典中没有重复的单词。


示例 1：

输入: s = leetcode, wordDict = [leet, code]
输出: true
解释: 返回 true 因为 leetcode 可以被拆分成 leet code。


示例 2：

输入: s = applepenapple, wordDict = [apple, pen]
输出: true
解释: 返回 true 因为 applepenapple 可以被拆分成 apple pen apple。
    注意你可以重复使用字典中的单词。


示例 3：

输入: s = catsandog, wordDict = [cats, dog, sand, and, cat]
输出: false

复制带随机指针的链表 - 领扣 (LeetCode)
给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。

要求返回这个链表的深度拷贝。
只出现一次的数字 II - 领扣 (LeetCode)
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,3,2]
输出: 3


示例2:

输入: [0,1,0,1,0,1,99]
输出: 99
只出现一次的数字 - 领扣 (LeetCode)
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1


示例2:

输入: [4,1,2,1,2]
输出: 4
老师想给孩子们分发糖果，有 N个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：


	每个孩子至少分配到 1 个糖果。
	相邻的孩子中，评分高的孩子必须获得更多的糖果。


那么这样下来，老师至少需要准备多少颗糖果呢？

示例1:

输入: [1,0,2]
输出: 5
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。


示例2:

输入: [1,2,2]
输出: 4
解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
分发糖果 - 领扣 (LeetCode)
加油站 - 领扣 (LeetCode)
在一条环路上有N个加油站，其中第i个加油站有汽油gas[i]升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1个加油站需要消耗汽油cost[i]升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

说明:


	如果题目有解，该答案即为唯一答案。
	输入数组均为非空数组，且长度相同。
	输入数组中的元素均为非负数。


示例1:

输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。

示例 2:

输入: 
gas  = [2,3,4]
cost = [3,4,3]

输出: -1

解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
找工作备战技术面试？快来 LeetCode 练习、提升技术水平，轻松迎接挑战。Loading...
分割回文串 II - 领扣 (LeetCode)
给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回符合要求的最少分割次数。

示例:

输入:aab
输出: 1
解释: 进行一次分割就可将s 分割成 [aa,b] 这样两个回文子串。

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回 s 所有可能的分割方案。

示例:

输入:aab
输出:
[
  [aa,b],
  [a,a,b]
]
分割回文串 - 领扣 (LeetCode)
被围绕的区域 - 领扣 (LeetCode)
给定一个二维的矩阵，包含&#39;X&#39;和&#39;O&#39;（字母 O）。

找到所有被 &#39;X&#39; 围绕的区域，并将这些区域里所有的&#39;O&#39; 用 &#39;X&#39; 填充。

示例:

X X X X
X O O X
X X O X
X O X X


运行你的函数后，矩阵变为：

X X X X
X X X X
X X X X
X O X X


解释:

被围绕的区间不会存在于边界上，换句话说，任何边界上的&#39;O&#39;都不会被填充为&#39;X&#39;。 任何不在边界上，或不与边界上的&#39;O&#39;相连的&#39;O&#39;最终都会被填充为&#39;X&#39;。如果两个元素在水平或垂直方向相邻，则称它们是&ldquo;相连&rdquo;的。
给定一个二叉树，它的每个结点都存放一个0-9的数字，每条从根到叶子节点的路径都代表一个数字。

例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。

计算从根到叶子节点生成的所有数字之和。

说明:叶子节点是指没有子节点的节点。

示例 1:

输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1-&gt;2 代表数字 12.
从根到叶子节点路径 1-&gt;3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.

示例 2:

输入: [4,9,0,5,1]
    4
   / \
  9   0
/ \
5   1
输出: 1026
解释:
从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.
从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.
从根到叶子节点路径 4-&gt;0 代表数字 40.
因此，数字总和 = 495 + 491 + 40 = 1026.
求根到叶子节点数字之和 - 领扣 (LeetCode)
给定一个未排序的整数数组，找出最长连续序列的长度。

要求算法的时间复杂度为O(n)。

示例:

输入:[100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
最长连续序列 - 领扣 (LeetCode)
单词接龙 - 领扣 (LeetCode)
给定两个单词（beginWord和 endWord）和一个字典，找到从beginWord 到endWord 的最短转换序列的长度。转换需遵循如下规则：


	每次转换只能改变一个字母。
	转换过程中的中间单词必须是字典中的单词。


说明:


	如果不存在这样的转换序列，返回 0。
	所有单词具有相同的长度。
	所有单词只由小写字母组成。
	字典中不存在重复的单词。
	你可以假设 beginWord 和 endWord 是非空的，且二者不相同。


示例1:

输入:
beginWord = hit,
endWord = cog,
wordList = [hot,dot,dog,lot,log,cog]

输出: 5

解释: 一个最短转换序列是 hit -&gt; hot -&gt; dot -&gt; dog -&gt; cog,
     返回它的长度 5。


示例 2:

输入:
beginWord = hit
endWord = cog
wordList = [hot,dot,dog,lot,log]

输出:0

解释:endWord cog 不在字典中，所以无法进行转换。
单词接龙 II - 领扣 (LeetCode)
给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：


	每次转换只能改变一个字母。
	转换过程中的中间单词必须是字典中的单词。


说明:


	如果不存在这样的转换序列，返回一个空列表。
	所有单词具有相同的长度。
	所有单词只由小写字母组成。
	字典中不存在重复的单词。
	你可以假设 beginWord 和 endWord 是非空的，且二者不相同。


示例 1:

输入:
beginWord = hit,
endWord = cog,
wordList = [hot,dot,dog,lot,log,cog]

输出:
[
  [hit,hot,dot,dog,cog],
 [hit,hot,lot,log,cog]
]


示例 2:

输入:
beginWord = hit
endWord = cog
wordList = [hot,dot,dog,lot,log]

输出: []

解释:endWord cog 不在字典中，所以不存在符合要求的转换序列。
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

示例 1:

输入: A man, a plan, a canal: Panama
输出: true


示例 2:

输入: race a car
输出: false

验证回文串 - 领扣 (LeetCode)
二叉树中的最大路径和 - 领扣 (LeetCode)
给定一个非空二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

示例 1:

输入: [1,2,3]

       1
      / \
     2   3

输出: 6


示例2:

输入: [-10,9,20,null,null,15,7]

  -10
 / \
 9 20
  / \
 15  7

输出: 42
买卖股票的最佳时机 III - 领扣 (LeetCode)
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成两笔交易。

注意:你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例1:

输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
    随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。  
    注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。  
    因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。


示例 3:

输入: [7,6,4,3,1] 
输出: 0 
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。
买卖股票的最佳时机 II - 领扣 (LeetCode)
给定一个数组，它的第i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
    随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。


示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
    注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
    因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。


示例3:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
给定一个数组，它的第i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。


示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

买卖股票的最佳时机 - 领扣 (LeetCode)
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]


自顶向下的最小路径和为11（即，2+3+5+1= 11）。

说明：

如果你可以只使用 O(n)的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。
三角形最小路径和 - 领扣 (LeetCode)
杨辉三角 II - 领扣 (LeetCode)
给定一个非负索引k，其中 k&le;33，返回杨辉三角的第 k 行。



在杨辉三角中，每个数是它左上方和右上方的数的和。

示例:

输入: 3
输出: [1,3,3,1]


进阶：

你可以优化你的算法到 O(k) 空间复杂度吗？
杨辉三角 - 领扣 (LeetCode)
给定一个非负整数numRows，生成杨辉三角的前numRows行。



在杨辉三角中，每个数是它左上方和右上方的数的和。

示例:

输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
给定一个二叉树

struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}


填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有next 指针都被设置为 NULL。

说明:


	你只能使用额外常数空间。
	使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。


示例:

给定二叉树，

     1
   /  \
  2    3
 / \    \
4   5    7


调用你的函数后，该二叉树变为：

     1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \    \
4-&gt; 5 -&gt; 7 -&gt; NULL
填充同一层的兄弟节点 II - 领扣 (LeetCode)
填充同一层的兄弟节点 - 领扣 (LeetCode)
给定一个二叉树

struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有next 指针都被设置为 NULL。

说明:


	你只能使用额外常数空间。
	使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
	你可以假设它是一个完美二叉树（即所有叶子节点都在同一层，每个父节点都有两个子节点）。


示例:

给定完美二叉树，

     1
   /  \
  2    3
 / \  / \
4  5  6  7

调用你的函数后，该完美二叉树变为：

     1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \  / \
4-&gt;5-&gt;6-&gt;7 -&gt; NULL
不同的子序列 - 领扣 (LeetCode)
给定一个字符串S和一个字符串T，计算在 S 的子序列中 T 出现的个数。

一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，ACE是ABCDE的一个子序列，而AEC不是）

示例1:

输入: S = rabbbit, T = rabbit
输出:3
解释:

如下图所示, 有 3 种可以从 S 中得到 rabbit 的方案。
(上箭头符号 ^ 表示选取的字母)

rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^


示例2:

输入: S = babgbag, T = bag
输出:5
解释:

如下图所示, 有 5 种可以从 S 中得到 bag 的方案。 
(上箭头符号 ^ 表示选取的字母)

babgbag
^^ ^
babgbag
^^    ^
babgbag
^    ^^
babgbag
  ^  ^^
babgbag
    ^^^
二叉树展开为链表 - 领扣 (LeetCode)
给定一个二叉树，原地将它展开为链表。

例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6

将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明:叶子节点是指没有子节点的节点。

示例:
给定如下二叉树，以及目标和sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1


返回:

[
   [5,4,11,2],
   [5,8,4,5]
]

路径总和 II - 领扣 (LeetCode)
路径总和 - 领扣 (LeetCode)
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明:叶子节点是指没有子节点的节点。

示例:
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1


返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。
找工作备战技术面试？快来 LeetCode 练习、提升技术水平，轻松迎接挑战。Loading...
平衡二叉树 - 领扣 (LeetCode)
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：


一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。


示例 1:

给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4


返回false 。
有序链表转换二叉搜索树 - 领扣 (LeetCode)
给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。

示例:

给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。

示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5

将有序数组转换为二叉搜索树 - 领扣 (LeetCode)
二叉树的层次遍历 II - 领扣 (LeetCode)
给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7


返回其自底向上的层次遍历为：

[
  [15,7],
  [9,20],
  [3]
]

从中序与后序遍历序列构造二叉树 - 领扣 (LeetCode)
根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

中序遍历 inorder =[9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]

返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder =[3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
从前序与中序遍历序列构造二叉树 - 领扣 (LeetCode)
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明:叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7

返回它的最大深度3 。
二叉树的最大深度 - 领扣 (LeetCode)
